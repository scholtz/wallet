{"version":3,"file":"js/707.99ba66d2.js","mappings":"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","sources":["webpack://wallet/./node_modules/@noble/hashes/esm/_md.js","webpack://wallet/./node_modules/@noble/hashes/esm/sha2.js","webpack://wallet/./node_modules/@noble/hashes/esm/hmac.js","webpack://wallet/./node_modules/viem/node_modules/@noble/curves/esm/utils.js","webpack://wallet/./node_modules/viem/node_modules/@noble/curves/esm/abstract/modular.js","webpack://wallet/./node_modules/viem/node_modules/@noble/curves/esm/abstract/curve.js","webpack://wallet/./node_modules/viem/node_modules/@noble/curves/esm/abstract/weierstrass.js","webpack://wallet/./node_modules/viem/node_modules/@noble/curves/esm/_shortw_utils.js","webpack://wallet/./node_modules/viem/node_modules/@noble/curves/esm/secp256k1.js"],"sourcesContent":["/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { Hash, abytes, aexists, aoutput, clean, createView, toBytes } from \"./utils.js\";\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nexport function Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        clean(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map","/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from \"./_md.js\";\nimport * as u64 from \"./_u64.js\";\nimport { clean, createHasher, rotr } from \"./utils.js\";\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD {\n    constructor(outputLen = 32) {\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        clean(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\nexport class SHA224 extends SHA256 {\n    constructor() {\n        super(28);\n        this.A = SHA224_IV[0] | 0;\n        this.B = SHA224_IV[1] | 0;\n        this.C = SHA224_IV[2] | 0;\n        this.D = SHA224_IV[3] | 0;\n        this.E = SHA224_IV[4] | 0;\n        this.F = SHA224_IV[5] | 0;\n        this.G = SHA224_IV[6] | 0;\n        this.H = SHA224_IV[7] | 0;\n    }\n}\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends HashMD {\n    constructor(outputLen = 64) {\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = SHA512_IV[0] | 0;\n        this.Al = SHA512_IV[1] | 0;\n        this.Bh = SHA512_IV[2] | 0;\n        this.Bl = SHA512_IV[3] | 0;\n        this.Ch = SHA512_IV[4] | 0;\n        this.Cl = SHA512_IV[5] | 0;\n        this.Dh = SHA512_IV[6] | 0;\n        this.Dl = SHA512_IV[7] | 0;\n        this.Eh = SHA512_IV[8] | 0;\n        this.El = SHA512_IV[9] | 0;\n        this.Fh = SHA512_IV[10] | 0;\n        this.Fl = SHA512_IV[11] | 0;\n        this.Gh = SHA512_IV[12] | 0;\n        this.Gl = SHA512_IV[13] | 0;\n        this.Hh = SHA512_IV[14] | 0;\n        this.Hl = SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        clean(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexport class SHA384 extends SHA512 {\n    constructor() {\n        super(48);\n        this.Ah = SHA384_IV[0] | 0;\n        this.Al = SHA384_IV[1] | 0;\n        this.Bh = SHA384_IV[2] | 0;\n        this.Bl = SHA384_IV[3] | 0;\n        this.Ch = SHA384_IV[4] | 0;\n        this.Cl = SHA384_IV[5] | 0;\n        this.Dh = SHA384_IV[6] | 0;\n        this.Dl = SHA384_IV[7] | 0;\n        this.Eh = SHA384_IV[8] | 0;\n        this.El = SHA384_IV[9] | 0;\n        this.Fh = SHA384_IV[10] | 0;\n        this.Fl = SHA384_IV[11] | 0;\n        this.Gh = SHA384_IV[12] | 0;\n        this.Gl = SHA384_IV[13] | 0;\n        this.Hh = SHA384_IV[14] | 0;\n        this.Hl = SHA384_IV[15] | 0;\n    }\n}\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\nexport class SHA512_224 extends SHA512 {\n    constructor() {\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nexport class SHA512_256 extends SHA512 {\n    constructor() {\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexport const sha256 = /* @__PURE__ */ createHasher(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224 = /* @__PURE__ */ createHasher(() => new SHA224());\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512 = /* @__PURE__ */ createHasher(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384 = /* @__PURE__ */ createHasher(() => new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256 = /* @__PURE__ */ createHasher(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224 = /* @__PURE__ */ createHasher(() => new SHA512_224());\n//# sourceMappingURL=sha2.js.map","/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean, Hash, toBytes } from \"./utils.js\";\nexport class HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        ahash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        clean(pad);\n    }\n    update(buf) {\n        aexists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        abytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { abytes as abytes_, bytesToHex as bytesToHex_, concatBytes as concatBytes_, hexToBytes as hexToBytes_, isBytes as isBytes_, } from '@noble/hashes/utils.js';\nexport { abytes, anumber, bytesToHex, bytesToUtf8, concatBytes, hexToBytes, isBytes, randomBytes, utf8ToBytes, } from '@noble/hashes/utils.js';\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport function abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(title + ' boolean expected, got ' + value);\n}\n// tmp name until v2\nexport function _abool2(value, title = '') {\n    if (typeof value !== 'boolean') {\n        const prefix = title && `\"${title}\"`;\n        throw new Error(prefix + 'expected boolean, got type=' + typeof value);\n    }\n    return value;\n}\n// tmp name until v2\n/** Asserts something is Uint8Array. */\nexport function _abytes2(value, length, title = '') {\n    const bytes = isBytes_(value);\n    const len = value?.length;\n    const needsLen = length !== undefined;\n    if (!bytes || (needsLen && len !== length)) {\n        const prefix = title && `\"${title}\" `;\n        const ofLen = needsLen ? ` of length ${length}` : '';\n        const got = bytes ? `length=${len}` : `type=${typeof value}`;\n        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n    }\n    return value;\n}\n// Used in weierstrass, der\nexport function numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex_(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    abytes_(bytes);\n    return hexToNumber(bytesToHex_(Uint8Array.from(bytes).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes_(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes_(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'secret key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes_(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if (isBytes_(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */\nexport function copyBytes(bytes) {\n    return Uint8Array.from(bytes);\n}\n/**\n * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols\n * Should be safe to use for things expected to be ASCII.\n * Returns exact same result as utf8ToBytes for ASCII or throws.\n */\nexport function asciiToBytes(ascii) {\n    return Uint8Array.from(ascii, (c, i) => {\n        const charCode = c.charCodeAt(0);\n        if (c.length !== 1 || charCode > 127) {\n            throw new Error(`string contains non-ASCII character \"${ascii[i]}\" with code ${charCode} at position ${i}`);\n        }\n        return charCode;\n    });\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\n// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\n// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nexport function inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_1n << BigInt(n)) - _1n;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    const u8n = (len) => new Uint8Array(len); // creates Uint8Array\n    const u8of = (byte) => Uint8Array.of(byte); // another shortcut\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0)) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes_(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes_(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nexport function validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\nexport function isHash(val) {\n    return typeof val === 'function' && Number.isSafeInteger(val.outputLen);\n}\nexport function _validateObject(object, fields, optFields = {}) {\n    if (!object || typeof object !== 'object')\n        throw new Error('expected valid options object');\n    function checkField(fieldName, expectedType, isOpt) {\n        const val = object[fieldName];\n        if (isOpt && val === undefined)\n            return;\n        const current = typeof val;\n        if (current !== expectedType || val === null)\n            throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n    }\n    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));\n    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));\n}\n/**\n * throws not implemented error\n */\nexport const notImplemented = () => {\n    throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map","/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { _validateObject, anumber, bitMask, bytesToNumberBE, bytesToNumberLE, ensureBytes, numberToBytesBE, numberToBytesLE, } from \"../utils.js\";\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);\n// prettier-ignore\nconst _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction assertIsSquare(Fp, root, n) {\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    assertIsSquare(Fp, root, n);\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    assertIsSquare(Fp, root, n);\n    return root;\n}\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P) {\n    const Fp_ = Field(P);\n    const tn = tonelliShanks(P);\n    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    return (Fp, n) => {\n        let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4\n        let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1\n        const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1\n        const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1\n        const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n        const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n        tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n        const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n        assertIsSquare(Fp, root, n);\n        return root;\n    };\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Initialization (precomputation).\n    // Caching initialization could boost perf by 7%.\n    if (P < _3n)\n        throw new Error('sqrt is not defined for small field');\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while (Q % _2n === _0n) {\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while (FpLegendre(_Fp, Z) === 1) {\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000)\n            throw new Error('Cannot find square root: probably non-prime P');\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1)\n        return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n))\n            return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1)\n            throw new Error('Cannot find square root');\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while (!Fp.eql(t, Fp.ONE)) {\n            if (Fp.is0(t))\n                return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i)  1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while (!Fp.eql(t_tmp, Fp.ONE)) {\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M)\n                    throw new Error('Cannot find square root');\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P  3 (mod 4)\n * 2. P  5 (mod 8)\n * 3. P  9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P) {\n    // P  3 (mod 4) => n = n^((P+1)/4)\n    if (P % _4n === _3n)\n        return sqrt3mod4;\n    // P  5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n)\n        return sqrt5mod8;\n    // P  9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n    if (P % _16n === _9n)\n        return sqrt9mod16(P);\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'number',\n        BITS: 'number',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    _validateObject(field, opts);\n    // const max = 16384;\n    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n    return field;\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(Fp, num, power) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return Fp.ONE;\n    if (power === _1n)\n        return num;\n    let p = Fp.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nexport function FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p)  1    if a is a square (mod p), quadratic residue\n * * (a | p)  -1   if a is not a square (mod p), quadratic non residue\n * * (a | p)  0    if a  0 (mod p)\n */\nexport function FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no)\n        throw new Error('invalid Legendre symbol result');\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined)\n        anumber(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, bitLenOrOpts, // TODO: use opts only in v2?\nisLE = false, opts = {}) {\n    if (ORDER <= _0n)\n        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    let _nbitLength = undefined;\n    let _sqrt = undefined;\n    let modFromBytes = false;\n    let allowedLengths = undefined;\n    if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {\n        if (opts.sqrt || isLE)\n            throw new Error('cannot specify opts in two arguments');\n        const _opts = bitLenOrOpts;\n        if (_opts.BITS)\n            _nbitLength = _opts.BITS;\n        if (_opts.sqrt)\n            _sqrt = _opts.sqrt;\n        if (typeof _opts.isLE === 'boolean')\n            isLE = _opts.isLE;\n        if (typeof _opts.modFromBytes === 'boolean')\n            modFromBytes = _opts.modFromBytes;\n        allowedLengths = _opts.allowedLengths;\n    }\n    else {\n        if (typeof bitLenOrOpts === 'number')\n            _nbitLength = bitLenOrOpts;\n        if (opts.sqrt)\n            _sqrt = opts.sqrt;\n    }\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);\n    if (BYTES > 2048)\n        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: bitMask(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        allowedLengths: allowedLengths,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        // is valid and invertible\n        isValidNot0: (num) => !f.is0(num) && f.isValid(num),\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: _sqrt ||\n            ((n) => {\n                if (!sqrtP)\n                    sqrtP = FpSqrt(ORDER);\n                return sqrtP(f, n);\n            }),\n        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n        fromBytes: (bytes, skipValidation = true) => {\n            if (allowedLengths) {\n                if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n                    throw new Error('Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length);\n                }\n                const padded = new Uint8Array(BYTES);\n                // isLE add 0 to right, !isLE to the left.\n                padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n                bytes = padded;\n            }\n            if (bytes.length !== BYTES)\n                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n            if (modFromBytes)\n                scalar = mod(scalar, ORDER);\n            if (!skipValidation)\n                if (!f.isValid(scalar))\n                    throw new Error('invalid field element: outside of range 0..ORDER');\n            // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n            // protocol may allow non-reduced scalar that reduced later or changed some other way.\n            return scalar;\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c) => (c ? b : a),\n    });\n    return Object.freeze(f);\n}\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nexport function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = ensureBytes('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n    const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitLen, bitMask, validateObject } from \"../utils.js\";\nimport { Field, FpInvertBatch, nLength, validateField } from \"./modular.js\";\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nexport function negateCt(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */\nexport function normalizeZ(c, points) {\n    const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));\n    return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = bitMask(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return { windows, windowSize, mask, maxNumber, shiftBy };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    // To disable precomputes:\n    // return 1;\n    return pointWindowSizes.get(P) || 1;\n}\nfunction assert0(n) {\n    if (n !== _0n)\n        throw new Error('invalid wNAF');\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Table generation takes **30MB of ram and 10ms on high-end CPU**,\n * but may take much longer on slow devices. Actual generation will happen on\n * first call of `multiply()`. By default, `BASE` point is precomputed.\n *\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport class wNAF {\n    // Parametrized with a given Point class (not individual point)\n    constructor(Point, bits) {\n        this.BASE = Point.BASE;\n        this.ZERO = Point.ZERO;\n        this.Fn = Point.Fn;\n        this.bits = bits;\n    }\n    // non-const time multiplication ladder\n    _unsafeLadder(elm, n, p = this.ZERO) {\n        let d = elm;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(1) * (Math.ceil( / ) + 1), where:\n     * -  is the window size\n     * -  is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param point Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(point, W) {\n        const { windows, windowSize } = calcWOpts(W, this.bits);\n        const points = [];\n        let p = point;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            // i=1, bc we skip 0\n            for (let i = 1; i < windowSize; i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * More compact implementation:\n     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W, precomputes, n) {\n        // Scalar should be smaller than field order\n        if (!this.Fn.isValid(n))\n            throw new Error('invalid scalar');\n        // Accumulators\n        let p = this.ZERO;\n        let f = this.BASE;\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n        const wo = calcWOpts(W, this.bits);\n        for (let window = 0; window < wo.windows; window++) {\n            // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // bits are 0: add garbage to fake point\n                // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                f = f.add(negateCt(isNegF, precomputes[offsetF]));\n            }\n            else {\n                // bits are 1: add to result point\n                p = p.add(negateCt(isNeg, precomputes[offset]));\n            }\n        }\n        assert0(n);\n        // Return both real and fake points: JIT won't eliminate f.\n        // At this point there is a way to F be infinity-point even if p is not,\n        // which makes it less const-time: around 1 bigint multiply.\n        return { p, f };\n    }\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {\n        const wo = calcWOpts(W, this.bits);\n        for (let window = 0; window < wo.windows; window++) {\n            if (n === _0n)\n                break; // Early-exit, skip 0 value\n            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // Window bits are 0: skip processing.\n                // Move to next window.\n                continue;\n            }\n            else {\n                const item = precomputes[offset];\n                acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n            }\n        }\n        assert0(n);\n        return acc;\n    }\n    getPrecomputes(W, point, transform) {\n        // Calculate precomputes on a first run, reuse them after\n        let comp = pointPrecomputes.get(point);\n        if (!comp) {\n            comp = this.precomputeWindow(point, W);\n            if (W !== 1) {\n                // Doing transform outside of if brings 15% perf hit\n                if (typeof transform === 'function')\n                    comp = transform(comp);\n                pointPrecomputes.set(point, comp);\n            }\n        }\n        return comp;\n    }\n    cached(point, scalar, transform) {\n        const W = getW(point);\n        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n    }\n    unsafe(point, scalar, transform, prev) {\n        const W = getW(point);\n        if (W === 1)\n            return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster\n        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n    }\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    createCache(P, W) {\n        validateW(W, this.bits);\n        pointWindowSizes.set(P, W);\n        pointPrecomputes.delete(P);\n    }\n    hasCache(elm) {\n        return getW(elm) !== 1;\n    }\n}\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */\nexport function mulEndoUnsafe(Point, point, k1, k2) {\n    let acc = point;\n    let p1 = Point.ZERO;\n    let p2 = Point.ZERO;\n    while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n)\n            p1 = p1.add(acc);\n        if (k2 & _1n)\n            p2 = p2.add(acc);\n        acc = acc.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n    }\n    return { p1, p2 };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka secret keys / bigints)\n */\nexport function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength)\n        throw new Error('arrays of points and scalars must have equal length');\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = bitLen(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12)\n        windowSize = wbits - 3;\n    else if (wbits > 4)\n        windowSize = wbits - 2;\n    else if (wbits > 0)\n        windowSize = 2;\n    const MASK = bitMask(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < slength; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar  256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255  32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16  255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = bitMask(windowSize);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\n// TODO: remove\n/** @deprecated */\nexport function validateBasic(curve) {\n    validateField(curve.Fp);\n    validateObject(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...nLength(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\nfunction createField(order, field, isLE) {\n    if (field) {\n        if (field.ORDER !== order)\n            throw new Error('Field.ORDER must match order: Fp == p, Fn == n');\n        validateField(field);\n        return field;\n    }\n    else {\n        return Field(order, { isLE });\n    }\n}\n/** Validates CURVE opts and creates fields */\nexport function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {\n    if (FpFnLE === undefined)\n        FpFnLE = type === 'edwards';\n    if (!CURVE || typeof CURVE !== 'object')\n        throw new Error(`expected valid ${type} CURVE object`);\n    for (const p of ['p', 'n', 'h']) {\n        const val = CURVE[p];\n        if (!(typeof val === 'bigint' && val > _0n))\n            throw new Error(`CURVE.${p} must be positive bigint`);\n    }\n    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n    const _b = type === 'weierstrass' ? 'b' : 'd';\n    const params = ['Gx', 'Gy', 'a', _b];\n    for (const p of params) {\n        // @ts-ignore\n        if (!Fp.isValid(CURVE[p]))\n            throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n    }\n    CURVE = Object.freeze(Object.assign({}, CURVE));\n    return { CURVE, Fp, Fn };\n}\n//# sourceMappingURL=curve.js.map","/**\n * Short Weierstrass curve methods. The formula is: y = x + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac as nobleHmac } from '@noble/hashes/hmac.js';\nimport { ahash } from '@noble/hashes/utils';\nimport { _validateObject, _abool2 as abool, _abytes2 as abytes, aInRange, bitLen, bitMask, bytesToHex, bytesToNumberBE, concatBytes, createHmacDrbg, ensureBytes, hexToBytes, inRange, isBytes, memoized, numberToHexUnpadded, randomBytes as randomBytesWeb, } from \"../utils.js\";\nimport { _createCurveFields, mulEndoUnsafe, negateCt, normalizeZ, pippenger, wNAF, } from \"./curve.js\";\nimport { Field, FpInvertBatch, getMinHashLength, mapHashToField, nLength, validateField, } from \"./modular.js\";\n// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)\nconst divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n) / den;\n/**\n * Splits scalar for GLV endomorphism.\n */\nexport function _splitEndoScalar(k, basis, n) {\n    // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`\n    // Since part can be negative, we need to do this on point.\n    // TODO: verifyScalar function which consumes lambda\n    const [[a1, b1], [a2, b2]] = basis;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    // |k1|/|k2| is < sqrt(N), but can be negative.\n    // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.\n    let k1 = k - c1 * a1 - c2 * a2;\n    let k2 = -c1 * b1 - c2 * b2;\n    const k1neg = k1 < _0n;\n    const k2neg = k2 < _0n;\n    if (k1neg)\n        k1 = -k1;\n    if (k2neg)\n        k2 = -k2;\n    // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.\n    // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.\n    const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n; // Half bits of N\n    if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {\n        throw new Error('splitScalar (endomorphism): failed, k=' + k);\n    }\n    return { k1neg, k1, k2neg, k2 };\n}\nfunction validateSigFormat(format) {\n    if (!['compact', 'recovered', 'der'].includes(format))\n        throw new Error('Signature format must be \"compact\", \"recovered\", or \"der\"');\n    return format;\n}\nfunction validateSigOpts(opts, def) {\n    const optsn = {};\n    for (let optName of Object.keys(def)) {\n        // @ts-ignore\n        optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];\n    }\n    abool(optsn.lowS, 'lowS');\n    abool(optsn.prehash, 'prehash');\n    if (optsn.format !== undefined)\n        validateSigFormat(optsn.format);\n    return optsn;\n}\nexport class DERErr extends Error {\n    constructor(m = '') {\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = numberToHexUnpadded(dataLen);\n            if ((len.length / 2) & 128)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? numberToHexUnpadded((len.length / 2) | 128) : '';\n            const t = numberToHexUnpadded(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = numberToHexUnpadded(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = DER;\n            if (data[0] & 128)\n                throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 128))\n                throw new E('invalid signature integer: unnecessary leading zero');\n            return bytesToNumberBE(data);\n        },\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = ensureBytes('signature', hex);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nexport function _normFnElement(Fn, key) {\n    const { BYTES: expected } = Fn;\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else {\n        let bytes = ensureBytes('private key', key);\n        try {\n            num = Fn.fromBytes(bytes);\n        }\n        catch (error) {\n            throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);\n        }\n    }\n    if (!Fn.isValidNot0(num))\n        throw new Error('invalid private key: out of range [1..N-1]');\n    return num;\n}\n/**\n * Creates weierstrass Point constructor, based on specified curve options.\n *\n * @example\n```js\nconst opts = {\n  p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  h: BigInt(1),\n  a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),\n  b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n};\nconst p256_Point = weierstrass(opts);\n```\n */\nexport function weierstrassN(params, extraOpts = {}) {\n    const validated = _createCurveFields('weierstrass', params, extraOpts);\n    const { Fp, Fn } = validated;\n    let CURVE = validated.CURVE;\n    const { h: cofactor, n: CURVE_ORDER } = CURVE;\n    _validateObject(extraOpts, {}, {\n        allowInfinityPoint: 'boolean',\n        clearCofactor: 'function',\n        isTorsionFree: 'function',\n        fromBytes: 'function',\n        toBytes: 'function',\n        endo: 'object',\n        wrapPrivateKey: 'boolean',\n    });\n    const { endo } = extraOpts;\n    if (endo) {\n        // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\n        if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || !Array.isArray(endo.basises)) {\n            throw new Error('invalid endo: expected \"beta\": bigint and \"basises\": array');\n        }\n    }\n    const lengths = getWLengths(Fp, Fn);\n    function assertCompressionIsSupported() {\n        if (!Fp.isOdd)\n            throw new Error('compression is not supported: Field does not have .isOdd()');\n    }\n    // Implements IEEE P1363 point encoding\n    function pointToBytes(_c, point, isCompressed) {\n        const { x, y } = point.toAffine();\n        const bx = Fp.toBytes(x);\n        abool(isCompressed, 'isCompressed');\n        if (isCompressed) {\n            assertCompressionIsSupported();\n            const hasEvenY = !Fp.isOdd(y);\n            return concatBytes(pprefix(hasEvenY), bx);\n        }\n        else {\n            return concatBytes(Uint8Array.of(0x04), bx, Fp.toBytes(y));\n        }\n    }\n    function pointFromBytes(bytes) {\n        abytes(bytes, undefined, 'Point');\n        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65\n        const length = bytes.length;\n        const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // No actual validation is done here: use .assertValidity()\n        if (length === comp && (head === 0x02 || head === 0x03)) {\n            const x = Fp.fromBytes(tail);\n            if (!Fp.isValid(x))\n                throw new Error('bad point: is not on curve, wrong x');\n            const y2 = weierstrassEquation(x); // y = x + ax + b\n            let y;\n            try {\n                y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n            }\n            catch (sqrtError) {\n                const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                throw new Error('bad point: is not on curve, sqrt error' + err);\n            }\n            assertCompressionIsSupported();\n            const isYOdd = Fp.isOdd(y); // (y & _1n) === _1n;\n            const isHeadOdd = (head & 1) === 1; // ECDSA-specific\n            if (isHeadOdd !== isYOdd)\n                y = Fp.neg(y);\n            return { x, y };\n        }\n        else if (length === uncomp && head === 0x04) {\n            // TODO: more checks\n            const L = Fp.BYTES;\n            const x = Fp.fromBytes(tail.subarray(0, L));\n            const y = Fp.fromBytes(tail.subarray(L, L * 2));\n            if (!isValidXY(x, y))\n                throw new Error('bad point: is not on curve');\n            return { x, y };\n        }\n        else {\n            throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);\n        }\n    }\n    const encodePoint = extraOpts.toBytes || pointToBytes;\n    const decodePoint = extraOpts.fromBytes || pointFromBytes;\n    function weierstrassEquation(x) {\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // x + a * x + b\n    }\n    // TODO: move top-level\n    /** Checks whether equation holds for given x, y: y == x + ax + b */\n    function isValidXY(x, y) {\n        const left = Fp.sqr(y); // y\n        const right = weierstrassEquation(x); // x + ax + b\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // Test 1: equation y = x + ax + b should work for generator point.\n    if (!isValidXY(CURVE.Gx, CURVE.Gy))\n        throw new Error('bad curve params: generator point');\n    // Test 2: discriminant  part should be non-zero: 4a + 27b != 0.\n    // Guarantees curve is genus-1, smooth (non-singular).\n    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n    if (Fp.is0(Fp.add(_4a3, _27b2)))\n        throw new Error('bad curve params: a or b');\n    /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */\n    function acoord(title, n, banZero = false) {\n        if (!Fp.isValid(n) || (banZero && Fp.is0(n)))\n            throw new Error(`bad point coordinate ${title}`);\n        return n;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    function splitEndoScalarN(k) {\n        if (!endo || !endo.basises)\n            throw new Error('no endo');\n        return _splitEndoScalar(k, endo.basises, Fn.ORDER);\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (X, Y, Z)  (x=X/Z, y=Y/Z)\n    const toAffineMemo = memoized((p, iz) => {\n        const { X, Y, Z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(Z, Fp.ONE))\n            return { x: X, y: Y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(Z);\n        const x = Fp.mul(X, iz);\n        const y = Fp.mul(Y, iz);\n        const zz = Fp.mul(Z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x, y };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = memoized((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not field elements');\n        if (!isValidXY(x, y))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {\n        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);\n        k1p = negateCt(k1neg, k1p);\n        k2p = negateCt(k2neg, k2p);\n        return k1p.add(k2p);\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z)  (x=X/Z, y=Y/Z).\n     * Default Point works in 2d / affine coordinates: (x, y).\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n        constructor(X, Y, Z) {\n            this.X = acoord('x', X);\n            this.Y = acoord('y', Y, true);\n            this.Z = acoord('z', Z);\n            Object.freeze(this);\n        }\n        static CURVE() {\n            return CURVE;\n        }\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\n            if (Fp.is0(x) && Fp.is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        static fromBytes(bytes) {\n            const P = Point.fromAffine(decodePoint(abytes(bytes, undefined, 'point')));\n            P.assertValidity();\n            return P;\n        }\n        static fromHex(hex) {\n            return Point.fromBytes(ensureBytes('pointHex', hex));\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         *\n         * @param windowSize\n         * @param isLazy true will defer table computation until the first multiplication\n         * @returns\n         */\n        precompute(windowSize = 8, isLazy = true) {\n            wnaf.createCache(this, windowSize);\n            if (!isLazy)\n                this.multiply(_3n); // random number\n            return this;\n        }\n        // TODO: return `this`\n        /** A point on curve is valid if it conforms to equation. */\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (!Fp.isOdd)\n                throw new Error(\"Field doesn't support isOdd\");\n            return !Fp.isOdd(y);\n        }\n        /** Compare one point to another. */\n        equals(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\n        negate() {\n            return new Point(this.X, Fp.neg(this.Y), this.Z);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo } = extraOpts;\n            if (!Fn.isValidNot0(scalar))\n                throw new Error('invalid scalar: out of range'); // 0 is invalid\n            let point, fake; // Fake point is used to const-time mult\n            const mul = (n) => wnaf.cached(this, n, (p) => normalizeZ(Point, p));\n            /** See docs for {@link EndomorphismOpts} */\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);\n                const { p: k1p, f: k1f } = mul(k1);\n                const { p: k2p, f: k2f } = mul(k2);\n                fake = k1f.add(k2f);\n                point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\n            }\n            else {\n                const { p, f } = mul(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return normalizeZ(Point, [point, fake])[0];\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed secret key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            const { endo } = extraOpts;\n            const p = this;\n            if (!Fn.isValid(sc))\n                throw new Error('invalid scalar: out of range'); // 0 is valid\n            if (sc === _0n || p.is0())\n                return Point.ZERO;\n            if (sc === _1n)\n                return p; // fast-path\n            if (wnaf.hasCache(this))\n                return this.multiply(sc);\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);\n                const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2); // 30% faster vs wnaf.unsafe\n                return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\n            }\n            else {\n                return wnaf.unsafe(p, sc);\n            }\n        }\n        multiplyAndAddUnsafe(Q, a, b) {\n            const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));\n            return sum.is0() ? undefined : sum;\n        }\n        /**\n         * Converts Projective point to affine (x, y) coordinates.\n         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n         */\n        toAffine(invertedZ) {\n            return toAffineMemo(this, invertedZ);\n        }\n        /**\n         * Checks whether Point is free of torsion elements (is in prime subgroup).\n         * Always torsion-free for cofactor=1 curves.\n         */\n        isTorsionFree() {\n            const { isTorsionFree } = extraOpts;\n            if (cofactor === _1n)\n                return true;\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            return wnaf.unsafe(this, CURVE_ORDER).is0();\n        }\n        clearCofactor() {\n            const { clearCofactor } = extraOpts;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(cofactor);\n        }\n        isSmallOrder() {\n            // can we use this.clearCofactor()?\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        toBytes(isCompressed = true) {\n            abool(isCompressed, 'isCompressed');\n            this.assertValidity();\n            return encodePoint(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return bytesToHex(this.toBytes(isCompressed));\n        }\n        toString() {\n            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n        }\n        // TODO: remove\n        get px() {\n            return this.X;\n        }\n        get py() {\n            return this.X;\n        }\n        get pz() {\n            return this.Z;\n        }\n        toRawBytes(isCompressed = true) {\n            return this.toBytes(isCompressed);\n        }\n        _setWindowSize(windowSize) {\n            this.precompute(windowSize);\n        }\n        static normalizeZ(points) {\n            return normalizeZ(Point, points);\n        }\n        static msm(points, scalars) {\n            return pippenger(Point, Fn, points, scalars);\n        }\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(_normFnElement(Fn, privateKey));\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    // math field\n    Point.Fp = Fp;\n    // scalar field\n    Point.Fn = Fn;\n    const bits = Fn.BITS;\n    const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);\n    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    return Point;\n}\n// Points start with byte 0x02 when y is even; otherwise 0x03\nfunction pprefix(hasEvenY) {\n    return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU(Fp, opts) {\n    validateField(Fp);\n    const { A, B, Z } = opts;\n    if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, Z);\n    if (!Fp.isOdd)\n        throw new Error('Field does not have .isOdd()');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];\n        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\nfunction getWLengths(Fp, Fn) {\n    return {\n        secretKey: Fn.BYTES,\n        publicKey: 1 + Fp.BYTES,\n        publicKeyUncompressed: 1 + 2 * Fp.BYTES,\n        publicKeyHasPrefix: true,\n        signature: 2 * Fn.BYTES,\n    };\n}\n/**\n * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.\n * This helper ensures no signature functionality is present. Less code, smaller bundle size.\n */\nexport function ecdh(Point, ecdhOpts = {}) {\n    const { Fn } = Point;\n    const randomBytes_ = ecdhOpts.randomBytes || randomBytesWeb;\n    const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: getMinHashLength(Fn.ORDER) });\n    function isValidSecretKey(secretKey) {\n        try {\n            return !!_normFnElement(Fn, secretKey);\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    function isValidPublicKey(publicKey, isCompressed) {\n        const { publicKey: comp, publicKeyUncompressed } = lengths;\n        try {\n            const l = publicKey.length;\n            if (isCompressed === true && l !== comp)\n                return false;\n            if (isCompressed === false && l !== publicKeyUncompressed)\n                return false;\n            return !!Point.fromBytes(publicKey);\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    /**\n     * Produces cryptographically secure secret key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */\n    function randomSecretKey(seed = randomBytes_(lengths.seed)) {\n        return mapHashToField(abytes(seed, lengths.seed, 'seed'), Fn.ORDER);\n    }\n    /**\n     * Computes public key for a secret key. Checks for validity of the secret key.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(secretKey, isCompressed = true) {\n        return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);\n    }\n    function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return { secretKey, publicKey: getPublicKey(secretKey) };\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        if (typeof item === 'bigint')\n            return false;\n        if (item instanceof Point)\n            return true;\n        const { secretKey, publicKey, publicKeyUncompressed } = lengths;\n        if (Fn.allowedLengths || secretKey === publicKey)\n            return undefined;\n        const l = ensureBytes('key', item).length;\n        return l === publicKey || l === publicKeyUncompressed;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from secret key A and public key B.\n     * Checks: 1) secret key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {\n        if (isProbPub(secretKeyA) === true)\n            throw new Error('first arg must be private key');\n        if (isProbPub(publicKeyB) === false)\n            throw new Error('second arg must be public key');\n        const s = _normFnElement(Fn, secretKeyA);\n        const b = Point.fromHex(publicKeyB); // checks for being on-curve\n        return b.multiply(s).toBytes(isCompressed);\n    }\n    const utils = {\n        isValidSecretKey,\n        isValidPublicKey,\n        randomSecretKey,\n        // TODO: remove\n        isValidPrivateKey: isValidSecretKey,\n        randomPrivateKey: randomSecretKey,\n        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),\n        precompute(windowSize = 8, point = Point.BASE) {\n            return point.precompute(windowSize, false);\n        },\n    };\n    return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });\n}\n/**\n * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.\n * We need `hash` for 2 features:\n * 1. Message prehash-ing. NOT used if `sign` / `verify` are called with `prehash: false`\n * 2. k generation in `sign`, using HMAC-drbg(hash)\n *\n * ECDSAOpts are only rarely needed.\n *\n * @example\n * ```js\n * const p256_Point = weierstrass(...);\n * const p256_sha256 = ecdsa(p256_Point, sha256);\n * const p256_sha224 = ecdsa(p256_Point, sha224);\n * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });\n * ```\n */\nexport function ecdsa(Point, hash, ecdsaOpts = {}) {\n    ahash(hash);\n    _validateObject(ecdsaOpts, {}, {\n        hmac: 'function',\n        lowS: 'boolean',\n        randomBytes: 'function',\n        bits2int: 'function',\n        bits2int_modN: 'function',\n    });\n    const randomBytes = ecdsaOpts.randomBytes || randomBytesWeb;\n    const hmac = ecdsaOpts.hmac ||\n        ((key, ...msgs) => nobleHmac(hash, key, concatBytes(...msgs)));\n    const { Fp, Fn } = Point;\n    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;\n    const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);\n    const defaultSigOpts = {\n        prehash: false,\n        lowS: typeof ecdsaOpts.lowS === 'boolean' ? ecdsaOpts.lowS : false,\n        format: undefined, //'compact' as ECDSASigFormat,\n        extraEntropy: false,\n    };\n    const defaultSigOpts_format = 'compact';\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function validateRS(title, num) {\n        if (!Fn.isValidNot0(num))\n            throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);\n        return num;\n    }\n    function validateSigLength(bytes, format) {\n        validateSigFormat(format);\n        const size = lengths.signature;\n        const sizer = format === 'compact' ? size : format === 'recovered' ? size + 1 : undefined;\n        return abytes(bytes, sizer, `${format} signature`);\n    }\n    /**\n     * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = validateRS('r', r); // r in [1..N-1];\n            this.s = validateRS('s', s); // s in [1..N-1];\n            if (recovery != null)\n                this.recovery = recovery;\n            Object.freeze(this);\n        }\n        static fromBytes(bytes, format = defaultSigOpts_format) {\n            validateSigLength(bytes, format);\n            let recid;\n            if (format === 'der') {\n                const { r, s } = DER.toSig(abytes(bytes));\n                return new Signature(r, s);\n            }\n            if (format === 'recovered') {\n                recid = bytes[0];\n                format = 'compact';\n                bytes = bytes.subarray(1);\n            }\n            const L = Fn.BYTES;\n            const r = bytes.subarray(0, L);\n            const s = bytes.subarray(L, L * 2);\n            return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);\n        }\n        static fromHex(hex, format) {\n            return this.fromBytes(hexToBytes(hex), format);\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(messageHash) {\n            const FIELD_ORDER = Fp.ORDER;\n            const { r, s, recovery: rec } = this;\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            // ECDSA recovery is hard for cofactor > 1 curves.\n            // In sign, `r = q.x mod n`, and here we recover q.x from r.\n            // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\n            // However, for cofactor>1, r+n may not get q.x:\n            // r+n*i would need to be done instead where i is unknown.\n            // To easily get i, we either need to:\n            // a. increase amount of valid recid values (4, 5...); OR\n            // b. prohibit non-prime-order signatures (recid > 1).\n            const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;\n            if (hasCofactor && rec > 1)\n                throw new Error('recovery id is ambiguous for h>1 curve');\n            const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;\n            if (!Fp.isValid(radj))\n                throw new Error('recovery id 2 or 3 invalid');\n            const x = Fp.toBytes(radj);\n            const R = Point.fromBytes(concatBytes(pprefix((rec & 1) === 0), x));\n            const ir = Fn.inv(radj); // r^-1\n            const h = bits2int_modN(ensureBytes('msgHash', messageHash)); // Truncate hash\n            const u1 = Fn.create(-h * ir); // -hr^-1\n            const u2 = Fn.create(s * ir); // sr^-1\n            // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\n            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n            if (Q.is0())\n                throw new Error('point at infinify');\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        toBytes(format = defaultSigOpts_format) {\n            validateSigFormat(format);\n            if (format === 'der')\n                return hexToBytes(DER.hexFromSig(this));\n            const r = Fn.toBytes(this.r);\n            const s = Fn.toBytes(this.s);\n            if (format === 'recovered') {\n                if (this.recovery == null)\n                    throw new Error('recovery bit must be present');\n                return concatBytes(Uint8Array.of(this.recovery), r, s);\n            }\n            return concatBytes(r, s);\n        }\n        toHex(format) {\n            return bytesToHex(this.toBytes(format));\n        }\n        // TODO: remove\n        assertValidity() { }\n        static fromCompact(hex) {\n            return Signature.fromBytes(ensureBytes('sig', hex), 'compact');\n        }\n        static fromDER(hex) {\n            return Signature.fromBytes(ensureBytes('sig', hex), 'der');\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;\n        }\n        toDERRawBytes() {\n            return this.toBytes('der');\n        }\n        toDERHex() {\n            return bytesToHex(this.toBytes('der'));\n        }\n        toCompactRawBytes() {\n            return this.toBytes('compact');\n        }\n        toCompactHex() {\n            return bytesToHex(this.toBytes('compact'));\n        }\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = ecdsaOpts.bits2int ||\n        function bits2int_def(bytes) {\n            // Our custom check \"just in case\", for protection against DoS\n            if (bytes.length > 8192)\n                throw new Error('input is too large');\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = ecdsaOpts.bits2int_modN ||\n        function bits2int_modN_def(bytes) {\n            return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // Pads output with zero as per spec\n    const ORDER_MASK = bitMask(fnBits);\n    /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */\n    function int2octets(num) {\n        // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\n        aInRange('num < 2^' + fnBits, num, _0n, ORDER_MASK);\n        return Fn.toBytes(num);\n    }\n    function validateMsgAndHash(message, prehash) {\n        abytes(message, undefined, 'message');\n        return prehash ? abytes(hash(message), undefined, 'prehashed message') : message;\n    }\n    /**\n     * Steps A, D of RFC6979 3.2.\n     * Creates RFC6979 seed; converts msg/privKey to numbers.\n     * Used only in sign, not in verify.\n     *\n     * Warning: we cannot assume here that message has same amount of bytes as curve order,\n     * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.\n     */\n    function prepSig(message, privateKey, opts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);\n        message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(message);\n        const d = _normFnElement(Fn, privateKey); // validate secret key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (extraEntropy != null && extraEntropy !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            // gen random bytes OR pass as-is\n            const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;\n            seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n        }\n        const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        // To transform k => Signature:\n        // q = kG\n        // r = q.x mod n\n        // s = k^-1(m + rd) mod n\n        // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n        // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n        // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            // Important: all mod() calls here must be done over N\n            const k = bits2int(kBytes); // mod n, not mod p\n            if (!Fn.isValidNot0(k))\n                return; // Valid scalars (including k) must be in 1..N-1\n            const ik = Fn.inv(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = kG\n            const r = Fn.create(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = Fn.neg(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    /**\n     * Signs message hash with a secret key.\n     *\n     * ```\n     * sign(m, d) where\n     *   k = rfc6979_hmac_drbg(m, d)\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr) / k mod n\n     * ```\n     */\n    function sign(message, secretKey, opts = {}) {\n        message = ensureBytes('message', message);\n        const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.\n        const drbg = createHmacDrbg(hash.outputLen, Fn.BYTES, hmac);\n        const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G\n        return sig;\n    }\n    function tryParsingSig(sg) {\n        // Try to deduce format\n        let sig = undefined;\n        const isHex = typeof sg === 'string' || isBytes(sg);\n        const isObj = !isHex &&\n            sg !== null &&\n            typeof sg === 'object' &&\n            typeof sg.r === 'bigint' &&\n            typeof sg.s === 'bigint';\n        if (!isHex && !isObj)\n            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n        if (isObj) {\n            sig = new Signature(sg.r, sg.s);\n        }\n        else if (isHex) {\n            try {\n                sig = Signature.fromBytes(ensureBytes('sig', sg), 'der');\n            }\n            catch (derError) {\n                if (!(derError instanceof DER.Err))\n                    throw derError;\n            }\n            if (!sig) {\n                try {\n                    sig = Signature.fromBytes(ensureBytes('sig', sg), 'compact');\n                }\n                catch (error) {\n                    return false;\n                }\n            }\n        }\n        if (!sig)\n            return false;\n        return sig;\n    }\n    /**\n     * Verifies a signature against message and public key.\n     * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.\n     * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   u1 = hs^-1 mod n\n     *   u2 = rs^-1 mod n\n     *   R = u1G + u2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, message, publicKey, opts = {}) {\n        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);\n        publicKey = ensureBytes('publicKey', publicKey);\n        message = validateMsgAndHash(ensureBytes('message', message), prehash);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const sig = format === undefined\n            ? tryParsingSig(signature)\n            : Signature.fromBytes(ensureBytes('sig', signature), format);\n        if (sig === false)\n            return false;\n        try {\n            const P = Point.fromBytes(publicKey);\n            if (lowS && sig.hasHighS())\n                return false;\n            const { r, s } = sig;\n            const h = bits2int_modN(message); // mod n, not mod p\n            const is = Fn.inv(s); // s^-1 mod n\n            const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\n            const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\n            const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1G + u2P\n            if (R.is0())\n                return false;\n            const v = Fn.create(R.x); // v = r.x mod n\n            return v === r;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    function recoverPublicKey(signature, message, opts = {}) {\n        const { prehash } = validateSigOpts(opts, defaultSigOpts);\n        message = validateMsgAndHash(message, prehash);\n        return Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes();\n    }\n    return Object.freeze({\n        keygen,\n        getPublicKey,\n        getSharedSecret,\n        utils,\n        lengths,\n        Point,\n        sign,\n        verify,\n        recoverPublicKey,\n        Signature,\n        hash,\n    });\n}\n/** @deprecated use `weierstrass` in newer releases */\nexport function weierstrassPoints(c) {\n    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n    const Point = weierstrassN(CURVE, curveOpts);\n    return _weierstrass_new_output_to_legacy(c, Point);\n}\nfunction _weierstrass_legacy_opts_to_new(c) {\n    const CURVE = {\n        a: c.a,\n        b: c.b,\n        p: c.Fp.ORDER,\n        n: c.n,\n        h: c.h,\n        Gx: c.Gx,\n        Gy: c.Gy,\n    };\n    const Fp = c.Fp;\n    let allowedLengths = c.allowedPrivateKeyLengths\n        ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2))))\n        : undefined;\n    const Fn = Field(CURVE.n, {\n        BITS: c.nBitLength,\n        allowedLengths: allowedLengths,\n        modFromBytes: c.wrapPrivateKey,\n    });\n    const curveOpts = {\n        Fp,\n        Fn,\n        allowInfinityPoint: c.allowInfinityPoint,\n        endo: c.endo,\n        isTorsionFree: c.isTorsionFree,\n        clearCofactor: c.clearCofactor,\n        fromBytes: c.fromBytes,\n        toBytes: c.toBytes,\n    };\n    return { CURVE, curveOpts };\n}\nfunction _ecdsa_legacy_opts_to_new(c) {\n    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n    const ecdsaOpts = {\n        hmac: c.hmac,\n        randomBytes: c.randomBytes,\n        lowS: c.lowS,\n        bits2int: c.bits2int,\n        bits2int_modN: c.bits2int_modN,\n    };\n    return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };\n}\nexport function _legacyHelperEquat(Fp, a, b) {\n    /**\n     * y = x + ax + b: Short weierstrass curve formula. Takes x, returns y.\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x + a * x + b\n    }\n    return weierstrassEquation;\n}\nfunction _weierstrass_new_output_to_legacy(c, Point) {\n    const { Fp, Fn } = Point;\n    function isWithinCurveOrder(num) {\n        return inRange(num, _1n, Fn.ORDER);\n    }\n    const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);\n    return Object.assign({}, {\n        CURVE: c,\n        Point: Point,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),\n        weierstrassEquation,\n        isWithinCurveOrder,\n    });\n}\nfunction _ecdsa_new_output_to_legacy(c, _ecdsa) {\n    const Point = _ecdsa.Point;\n    return Object.assign({}, _ecdsa, {\n        ProjectivePoint: Point,\n        CURVE: Object.assign({}, c, nLength(Point.Fn.ORDER, Point.Fn.BITS)),\n    });\n}\n// _ecdsa_legacy\nexport function weierstrass(c) {\n    const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);\n    const Point = weierstrassN(CURVE, curveOpts);\n    const signs = ecdsa(Point, hash, ecdsaOpts);\n    return _ecdsa_new_output_to_legacy(c, signs);\n}\n//# sourceMappingURL=weierstrass.js.map","/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { weierstrass } from \"./abstract/weierstrass.js\";\n/** connects noble-curves to noble-hashes */\nexport function getHash(hash) {\n    return { hash };\n}\n/** @deprecated use new `weierstrass()` and `ecdsa()` methods */\nexport function createCurve(curveDef, defHash) {\n    const create = (hash) => weierstrass({ ...curveDef, hash: hash });\n    return { ...create(defHash), create };\n}\n//# sourceMappingURL=_shortw_utils.js.map","/**\n * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism ,\n * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { randomBytes } from '@noble/hashes/utils.js';\nimport { createCurve } from \"./_shortw_utils.js\";\nimport { createHasher, isogenyMap, } from \"./abstract/hash-to-curve.js\";\nimport { Field, mapHashToField, mod, pow2 } from \"./abstract/modular.js\";\nimport { _normFnElement, mapToCurveSimpleSWU, } from \"./abstract/weierstrass.js\";\nimport { bytesToNumberBE, concatBytes, ensureBytes, inRange, numberToBytesBE, utf8ToBytes, } from \"./utils.js\";\n// Seems like generator was produced from some seed:\n// `Point.BASE.multiply(Point.Fn.inv(2n, N)).toAffine().x`\n// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n\nconst secp256k1_CURVE = {\n    p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n    h: BigInt(1),\n    a: BigInt(0),\n    b: BigInt(7),\n    Gx: BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n    Gy: BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'),\n};\nconst secp256k1_ENDO = {\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n    basises: [\n        [BigInt('0x3086d221a7d46bcde86c90e49284eb15'), -BigInt('0xe4437ed6010e88286f547fa90abfe4c3')],\n        [BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'), BigInt('0x3086d221a7d46bcde86c90e49284eb15')],\n    ],\n};\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1_CURVE.p;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = (pow2(b3, _3n, P) * b3) % P;\n    const b9 = (pow2(b6, _3n, P) * b3) % P;\n    const b11 = (pow2(b9, _2n, P) * b2) % P;\n    const b22 = (pow2(b11, _11n, P) * b11) % P;\n    const b44 = (pow2(b22, _22n, P) * b22) % P;\n    const b88 = (pow2(b44, _44n, P) * b44) % P;\n    const b176 = (pow2(b88, _88n, P) * b88) % P;\n    const b220 = (pow2(b176, _44n, P) * b44) % P;\n    const b223 = (pow2(b220, _3n, P) * b3) % P;\n    const t1 = (pow2(b223, _23n, P) * b22) % P;\n    const t2 = (pow2(t1, _6n, P) * b2) % P;\n    const root = pow2(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });\n/**\n * secp256k1 curve, ECDSA and ECDH methods.\n *\n * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1';\n * const { secretKey, publicKey } = secp256k1.keygen();\n * const msg = new TextEncoder().encode('hello');\n * const sig = secp256k1.sign(msg, secretKey);\n * const isValid = secp256k1.verify(sig, msg, publicKey) === true;\n * ```\n */\nexport const secp256k1 = createCurve({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = sha256(utf8ToBytes(tag));\n        tagP = concatBytes(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return sha256(concatBytes(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toBytes(true).slice(1);\nconst Pointk1 = /* @__PURE__ */ (() => secp256k1.Point)();\nconst hasEven = (y) => y % _2n === _0n;\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    const { Fn, BASE } = Pointk1;\n    const d_ = _normFnElement(Fn, priv);\n    const p = BASE.multiply(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);\n    return { scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    const Fp = Fpk1;\n    if (!Fp.isValidNot0(x))\n        throw new Error('invalid x: Fail if x  p');\n    const xx = Fp.create(x * x);\n    const c = Fp.create(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = Fp.sqrt(c); // Let y = c^(p+1)/4 mod p. Same as sqrt().\n    // Return the unique point P such that x(P) = x and\n    // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    if (!hasEven(y))\n        y = Fp.neg(y);\n    const p = Pointk1.fromAffine({ x, y });\n    p.assertValidity();\n    return p;\n}\nconst num = bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return Pointk1.Fn.create(num(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(secretKey) {\n    return schnorrGetExtPubKey(secretKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, secretKey, auxRand = randomBytes(32)) {\n    const { Fn } = Pointk1;\n    const m = ensureBytes('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey); // checks for isWithinCurveOrder\n    const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = Fn.toBytes(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    // Let k' = int(rand) mod n. Fail if k' = 0. Let R = k'G\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const { Fn, BASE } = Pointk1;\n    const sig = ensureBytes('signature', signature, 64);\n    const m = ensureBytes('message', message);\n    const pub = ensureBytes('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!inRange(r, _1n, secp256k1_CURVE.p))\n            return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!inRange(s, _1n, secp256k1_CURVE.n))\n            return false;\n        // int(challenge(bytes(r)||bytes(P)||m))%n\n        const e = challenge(Fn.toBytes(r), pointToBytes(P), m);\n        // R = sG - eP, where -eP == (n-e)P\n        const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));\n        const { x, y } = R.toAffine();\n        // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n        if (R.is0() || !hasEven(y) || x !== r)\n            return false;\n        return true;\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1';\n * const { secretKey, publicKey } = schnorr.keygen();\n * // const publicKey = schnorr.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, secretKey);\n * const isValid = schnorr.verify(sig, msg, publicKey);\n * ```\n */\nexport const schnorr = /* @__PURE__ */ (() => {\n    const size = 32;\n    const seedLength = 48;\n    const randomSecretKey = (seed = randomBytes(seedLength)) => {\n        return mapHashToField(seed, secp256k1_CURVE.n);\n    };\n    // TODO: remove\n    secp256k1.utils.randomSecretKey;\n    function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };\n    }\n    return {\n        keygen,\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        Point: Pointk1,\n        utils: {\n            randomSecretKey: randomSecretKey,\n            randomPrivateKey: randomSecretKey,\n            taggedHash,\n            // TODO: remove\n            lift_x,\n            pointToBytes,\n            numberToBytesBE,\n            bytesToNumberBE,\n            mod,\n        },\n        lengths: {\n            secretKey: size,\n            publicKey: size,\n            publicKeyHasPrefix: false,\n            signature: size * 2,\n            seed: seedLength,\n        },\n    };\n})();\nconst isoMap = /* @__PURE__ */ (() => isogenyMap(Fpk1, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n}))();\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */\nexport const secp256k1_hasher = /* @__PURE__ */ (() => createHasher(secp256k1.Point, (scalars) => {\n    const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fpk1.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n}))();\n/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */\nexport const hashToCurve = /* @__PURE__ */ (() => secp256k1_hasher.hashToCurve)();\n/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */\nexport const encodeToCurve = /* @__PURE__ */ (() => secp256k1_hasher.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map"],"names":["setBigUint64","view","byteOffset","value","isLE","_32n","BigInt","_u32_max","wh","Number","wl","h","l","setUint32","Chi","a","b","c","Maj","HashMD","constructor","blockLen","outputLen","padOffset","super","this","finished","length","pos","destroyed","buffer","Uint8Array","update","data","len","take","Math","min","dataView","process","set","subarray","roundClean","digestInto","out","i","oview","Error","outLen","state","get","digest","res","slice","destroy","_cloneInto","to","clone","SHA256_IV","Uint32Array","from","SHA256_K","SHA256_W","SHA256","A","B","C","D","E","F","G","H","offset","getUint32","W15","W2","s0","s1","sigma1","T1","sigma0","T2","HMAC","hash","_key","key","iHash","create","pad","oHash","buf","Object","getPrototypeOf","message","_0n","_1n","_abool2","title","prefix","_abytes2","bytes","needsLen","undefined","ofLen","got","numberToHexUnpadded","num","hex","toString","hexToNumber","reverse","n","padStart","numberToBytesLE","expectedLength","e","isPosBig","max","aInRange","bitLen","createHmacDrbg","hashLen","qByteLen","hmacFn","u8n","u8of","byte","of","v","k","reset","fill","reseed","seed","gen","sl","push","genUntil","pred","_validateObject","object","fields","optFields","checkField","fieldName","expectedType","isOpt","val","current","entries","forEach","memoized","fn","map","WeakMap","arg","args","computed","_2n","_3n","_4n","_5n","_7n","_8n","_9n","_16n","result","pow2","x","power","modulo","invert","number","y","u","q","r","m","gcd","assertIsSquare","Fp","root","eql","sqr","sqrt3mod4","p1div4","ORDER","pow","sqrt5mod8","p5div8","n2","mul","nv","sub","ONE","sqrt9mod16","P","Fp_","Field","tn","tonelliShanks","c1","neg","c2","c3","c4","tv1","tv2","tv3","tv4","e1","e2","cmov","e3","Q","S","Z","_Fp","FpLegendre","cc","Q1div2","is0","M","t","R","ZERO","t_tmp","exponent","FpSqrt","FIELD_FIELDS","field","initial","MASK","BYTES","BITS","opts","reduce","FpPow","p","d","nums","passZero","inverted","Array","multipliedAcc","acc","invertedAcc","inv","reduceRight","p1mod2","powered","yes","zero","no","nBitLength","_nBitLength","nByteLength","ceil","bitLenOrOpts","_nbitLength","_sqrt","allowedLengths","modFromBytes","sqrt","_opts","sqrtP","f","freeze","isValid","isValidNot0","isOdd","lhs","rhs","add","div","sqrN","addN","subN","mulN","toBytes","fromBytes","skipValidation","includes","padded","scalar","invertBatch","lst","getFieldBytesLength","fieldOrder","bitLength","getMinHashLength","fieldLen","minLen","reduced","negateCt","condition","item","negate","normalizeZ","points","invertedZs","fromAffine","toAffine","validateW","W","bits","isSafeInteger","calcWOpts","scalarBits","windows","windowSize","maxNumber","mask","shiftBy","calcOffsets","window","wOpts","wbits","nextN","offsetStart","abs","isZero","isNeg","isNegF","offsetF","validateMSMPoints","isArray","validateMSMScalars","scalars","s","pointPrecomputes","pointWindowSizes","getW","assert0","wNAF","Point","BASE","Fn","_unsafeLadder","elm","double","precomputeWindow","point","base","precomputes","wo","wNAFUnsafe","getPrecomputes","transform","comp","cached","unsafe","prev","createCache","delete","hasCache","mulEndoUnsafe","k1","k2","p1","p2","pippenger","fieldN","plength","slength","buckets","lastBits","floor","sum","j","resI","sumI","createField","order","_createCurveFields","type","CURVE","curveOpts","FpFnLE","_b","params","assign","divNearest","den","_splitEndoScalar","basis","a1","b1","a2","b2","k1neg","k2neg","MAX_NUM","validateSigFormat","format","validateSigOpts","def","optsn","optName","keys","lowS","prehash","DERErr","DER","Err","_tlv","encode","tag","dataLen","lenLen","decode","first","isLong","lengthBytes","_int","parseInt","toSig","int","tlv","seqBytes","seqLeftBytes","rBytes","rLeftBytes","sBytes","sLeftBytes","hexFromSig","sig","rs","ss","seq","expected","error","weierstrassN","extraOpts","validated","cofactor","CURVE_ORDER","allowInfinityPoint","clearCofactor","isTorsionFree","endo","wrapPrivateKey","beta","basises","lengths","getWLengths","assertCompressionIsSupported","pointToBytes","_c","isCompressed","bx","hasEvenY","pprefix","pointFromBytes","publicKey","publicKeyUncompressed","uncomp","head","tail","L","isValidXY","y2","weierstrassEquation","sqrtError","err","isYOdd","isHeadOdd","encodePoint","decodePoint","x2","x3","left","right","Gx","Gy","_4a3","_27b2","acoord","banZero","aprjpoint","other","splitEndoScalarN","toAffineMemo","iz","X","Y","zz","assertValidMemo","finishEndo","endoBeta","k1p","k2p","assertValidity","fromHex","precompute","isLazy","wnaf","multiply","equals","X1","Y1","Z1","X2","Y2","Z2","U1","U2","b3","X3","Y3","Z3","t0","t1","t2","t3","t4","t5","subtract","fake","k1f","k2f","multiplyUnsafe","sc","multiplyAndAddUnsafe","invertedZ","isSmallOrder","toHex","px","py","pz","toRawBytes","_setWindowSize","msm","fromPrivateKey","privateKey","secretKey","publicKeyHasPrefix","signature","ecdh","ecdhOpts","randomBytes_","randomBytes","isValidSecretKey","isValidPublicKey","randomSecretKey","getPublicKey","keygen","isProbPub","getSharedSecret","secretKeyA","publicKeyB","utils","isValidPrivateKey","randomPrivateKey","normPrivateKeyToScalar","ecdsa","ecdsaOpts","hmac","bits2int","bits2int_modN","msgs","fnBits","defaultSigOpts","extraEntropy","defaultSigOpts_format","isBiggerThanHalfOrder","HALF","validateRS","validateSigLength","size","sizer","Signature","recovery","recid","addRecoveryBit","recoverPublicKey","messageHash","FIELD_ORDER","rec","hasCofactor","radj","ir","u1","u2","hasHighS","fromCompact","fromDER","normalizeS","toDERRawBytes","toDERHex","toCompactRawBytes","toCompactHex","delta","ORDER_MASK","int2octets","validateMsgAndHash","prepSig","some","h1int","seedArgs","k2sig","kBytes","ik","normS","sign","drbg","tryParsingSig","sg","isHex","isObj","derError","verify","is","_weierstrass_legacy_opts_to_new","allowedPrivateKeyLengths","Set","_ecdsa_legacy_opts_to_new","_ecdsa_new_output_to_legacy","_ecdsa","ProjectivePoint","weierstrass","signs","createCurve","curveDef","defHash","secp256k1_CURVE","secp256k1_ENDO","sqrtMod","_6n","_11n","_22n","_23n","_44n","_88n","b6","b9","b11","b22","b44","b88","b176","b220","b223","Fpk1","secp256k1"],"sourceRoot":""}