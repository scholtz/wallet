{"version":3,"file":"js/548.f31b1c74.js","mappings":"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","sources":["webpack://wallet/./src/scripts/encoding/base642base64url.ts","webpack://wallet/./src/scripts/interface/CAsset.ts","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/util.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/logging.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/config.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/config.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/transaction/perform-atomic-transaction-composer-simulate.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/debugging/simulate-and-persist-response.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/transaction/transaction.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/app.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/app.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/indexer-lookup.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/app-deploy.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/debugging.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/debugging/debugging.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/transfer/transfer-algos.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/logic-error.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/app-client.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/asset.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/app-client.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/dispenser-client.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/urlTokenBaseHTTPClient.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/algo-http-client-with-retry.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/client-manager.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/amount.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/amount.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/composer.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/account-manager.mjs","webpack://wallet/./node_modules/biatec-scheduler/dist/index.mjs"],"sourcesContent":["const base642base64url = (input: string) => {\n  return input.replaceAll(\"+\", \"-\").replaceAll(\"/\", \"_\").replaceAll(\"=\", \"\");\n};\nexport default base642base64url;\n","import IAsset from \"./IAsset\";\n\nclass CAsset implements IAsset {\n  \"asset-id\": number = 0;\n  amount: number = 0;\n  name: string = \"\";\n  decimals: number = 0;\n  \"unit-name\": string = \"\";\n  type: string = \"\";\n  label: string = \"\";\n}\n\nexport default CAsset;\n","/**\n * Converts a value which might be a number or a bigint into a number to be used with apis that don't support bigint.\n *\n * Throws an UnsafeConversionError if the conversion would result in an unsafe integer for the Number type\n * @param value\n */\nconst toNumber = (value) => {\n    if (typeof value === 'number')\n        return value;\n    if (value > BigInt(Number.MAX_SAFE_INTEGER)) {\n        throw new UnsafeConversionError(`Cannot convert ${value} to a Number as it is larger than the maximum safe integer the Number type can hold.`);\n    }\n    else if (value < BigInt(Number.MIN_SAFE_INTEGER)) {\n        throw new UnsafeConversionError(`Cannot convert ${value} to a Number as it is smaller than the minimum safe integer the Number type can hold.`);\n    }\n    return Number(value);\n};\nclass UnsafeConversionError extends Error {\n}\n/**\n * Calculates the amount of funds to add to a wallet to bring it up to the minimum spending balance.\n * @param minSpendingBalance The minimum spending balance for the wallet\n * @param currentSpendingBalance The current spending balance for the wallet\n * @param minFundingIncrement The minimum amount of funds that can be added to the wallet\n * @returns The amount of funds to add to the wallet or null if the wallet is already above the minimum spending balance\n */\nconst calculateFundAmount = (minSpendingBalance, currentSpendingBalance, minFundingIncrement) => {\n    if (minSpendingBalance > currentSpendingBalance) {\n        const minFundAmount = minSpendingBalance - currentSpendingBalance;\n        return Math.max(minFundAmount, minFundingIncrement);\n    }\n    else {\n        return null;\n    }\n};\n/**\n * Checks if the current environment is Node.js\n *\n * @returns A boolean indicating whether the current environment is Node.js\n */\nconst isNode = () => {\n    return typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\n};\n\nexport { UnsafeConversionError, calculateFundAmount, isNode, toNumber };\n//# sourceMappingURL=util.mjs.map\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable no-console */\n/** A logger implementation that writes to console */\nconst consoleLogger = {\n    error: console.error,\n    warn: console.warn,\n    info: console.info,\n    verbose: () => { },\n    debug: console.debug,\n};\nconst infoConsoleLogger = {\n    error: console.error,\n    warn: console.warn,\n    info: console.info,\n    verbose: () => { },\n    debug: () => { },\n};\nconst verboseConsoleLogger = {\n    error: console.error,\n    warn: console.warn,\n    info: console.info,\n    verbose: console.trace,\n    debug: console.debug,\n};\nconst warningConsoleLogger = {\n    error: console.error,\n    warn: console.warn,\n    info: () => { },\n    verbose: () => { },\n    debug: () => { },\n};\n/** A logger implementation that does nothing */\nconst nullLogger = {\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    error: function (message, ...optionalParams) { },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    warn: function (message, ...optionalParams) { },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    info: function (message, ...optionalParams) { },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    verbose: function (message, ...optionalParams) { },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    debug: function (message, ...optionalParams) { },\n};\n\nexport { consoleLogger, infoConsoleLogger, nullLogger, verboseConsoleLogger, warningConsoleLogger };\n//# sourceMappingURL=logging.mjs.map\n","import { isNode } from '../util.mjs';\nimport { nullLogger, consoleLogger } from './logging.mjs';\n\n/** Updatable AlgoKit config */\nclass UpdatableConfig {\n    get populateAppCallResources() {\n        return this.config.populateAppCallResources;\n    }\n    get logger() {\n        return this.config.logger;\n    }\n    get debug() {\n        return this.config.debug;\n    }\n    get projectRoot() {\n        return this.config.projectRoot;\n    }\n    get traceAll() {\n        return this.config.traceAll;\n    }\n    get traceBufferSizeMb() {\n        return this.config.traceBufferSizeMb;\n    }\n    get maxSearchDepth() {\n        return this.config.maxSearchDepth;\n    }\n    /**\n     * Returns the current logger, or the null logger if true is passed in to `returnNullLogger`\n     * @param returnNullLogger Whether or not to return the null logger\n     * @returns The requested logger\n     */\n    getLogger(returnNullLogger) {\n        if (returnNullLogger) {\n            return nullLogger;\n        }\n        return this.logger;\n    }\n    /**\n     * Temporarily run with debug set to true.\n     * @param lambda A lambda expression with code to run with debug config set to true\n     */\n    withDebug(lambda) {\n        const original = this.config.debug;\n        try {\n            this.config.debug = true;\n            lambda();\n        }\n        finally {\n            this.config.debug = original;\n        }\n    }\n    constructor() {\n        this.config = {\n            logger: consoleLogger,\n            debug: false,\n            projectRoot: null,\n            traceAll: false,\n            traceBufferSizeMb: 256,\n            maxSearchDepth: 10,\n            populateAppCallResources: false,\n        };\n        if (isNode()) {\n            this.configureProjectRoot();\n        }\n    }\n    /**\n     * Configures the project root by searching for a specific file within a depth limit.\n     * This is only supported in a Node environment.\n     */\n    async configureProjectRoot() {\n        if (!isNode()) {\n            throw new Error('`configureProjectRoot` can only be called in Node.js environment.');\n        }\n        const fs = await import('fs');\n        const path = await import('path');\n        const _dirname = await import('path').then(async (path) => path.dirname(await import('url').then((url) => url.fileURLToPath(import.meta.url))));\n        if (!_dirname) {\n            return;\n        }\n        let currentPath = path.resolve(_dirname);\n        for (let i = 0; i < this.config.maxSearchDepth; i++) {\n            if (fs.existsSync(`${currentPath}/.algokit.toml`)) {\n                this.config.projectRoot = currentPath;\n                break;\n            }\n            currentPath = path.dirname(currentPath);\n        }\n    }\n    /**\n     * Update the AlgoKit configuration with your own configuration settings\n     * @param newConfig Partial or complete config to replace\n     */\n    configure(newConfig) {\n        this.config = { ...this.config, ...newConfig };\n    }\n}\n\nexport { UpdatableConfig };\n//# sourceMappingURL=config.mjs.map\n","import { UpdatableConfig } from './types/config.mjs';\n\n/** The AlgoKit config. To update it use the configure method. */\nconst Config = new UpdatableConfig();\n\nexport { Config };\n//# sourceMappingURL=config.mjs.map\n","import algosdk from 'algosdk';\n\nvar modelsv2 = algosdk.modelsv2;\n/**\n * Performs a simulation of the transactions loaded into the given AtomicTransactionComposer.\n * @param atc The AtomicTransactionComposer with transaction(s) loaded.\n * @param algod An Algod client to perform the simulation.\n * @returns The simulation result, which includes various details about how the transactions would be processed.\n */\nasync function performAtomicTransactionComposerSimulate(atc, algod) {\n    const unsignedTransactionsSigners = atc.buildGroup();\n    const decodedSignedTransactions = unsignedTransactionsSigners.map((ts) => algosdk.encodeUnsignedSimulateTransaction(ts.txn));\n    const simulateRequest = new modelsv2.SimulateRequest({\n        allowEmptySignatures: true,\n        allowMoreLogging: true,\n        execTraceConfig: new modelsv2.SimulateTraceConfig({\n            enable: true,\n            scratchChange: true,\n            stackChange: true,\n            stateChange: true,\n        }),\n        txnGroups: [\n            new modelsv2.SimulateRequestTransactionGroup({\n                txns: decodedSignedTransactions.map((txn) => algosdk.decodeObj(txn)),\n            }),\n        ],\n    });\n    const simulateResult = await algod.simulateTransactions(simulateRequest).do();\n    return simulateResult;\n}\n\nexport { performAtomicTransactionComposerSimulate };\n//# sourceMappingURL=perform-atomic-transaction-composer-simulate.mjs.map\n","import { Config } from '../config.mjs';\nimport { performAtomicTransactionComposerSimulate } from '../transaction/perform-atomic-transaction-composer-simulate.mjs';\nimport { isNode } from '../util.mjs';\n\nconst TRACES_FILE_EXT = '.trace.avm.json';\nconst DEBUG_TRACES_DIR = 'debug_traces';\n/**\n * This function simulates the atomic transactions using the provided `AtomicTransactionComposer` object and `Algodv2` object,\n * and persists the simulation response to an AlgoKit AVM Debugger compliant JSON file.\n *\n * @param param0 The parameters to control the simulation and persistence.\n *\n * @returns The simulation result, which includes various details about how the transactions would be processed.\n *\n * @example\n * const atc = new AtomicTransactionComposer();\n * const algod = new algosdk.Algodv2(token, server, port);\n * const projectRoot = '/path/to/project';\n * const bufferSizeMb = 10;\n *\n * const result = await simulateAndPersistResponse({ atc, projectRoot, algod, bufferSizeMb });\n * console.log(result);\n */\nasync function simulateAndPersistResponse({ atc, projectRoot, algod, bufferSizeMb }) {\n    if (!isNode()) {\n        throw new Error('Sourcemaps can only be persisted in Node.js environment.');\n    }\n    const fs = await import('fs');\n    const path = await import('path');\n    try {\n        const atcToSimulate = atc.clone();\n        const simulateResult = await performAtomicTransactionComposerSimulate(atcToSimulate, algod);\n        const txnGroups = simulateResult.txnGroups;\n        const txnTypesCount = txnGroups.reduce((acc, txnGroup) => {\n            const txnType = txnGroup.txnResults[0].txnResult.txn.txn.type;\n            acc[txnType] = (acc[txnType] || 0) + 1;\n            return acc;\n        }, {});\n        const txnTypesStr = Object.entries(txnTypesCount)\n            .map(([type, count]) => `${count}#${type}`)\n            .join('_');\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '');\n        const outputRootDir = path.join(projectRoot, DEBUG_TRACES_DIR);\n        const outputFileName = `${timestamp}_lr${simulateResult.lastRound}_${txnTypesStr}${TRACES_FILE_EXT}`;\n        const outputFilePath = path.join(outputRootDir, outputFileName);\n        try {\n            await fs.promises.access(path.dirname(outputFilePath));\n        }\n        catch (error) {\n            const err = error;\n            if (err.code === 'ENOENT') {\n                await fs.promises.mkdir(path.dirname(outputFilePath), { recursive: true });\n            }\n            else {\n                throw err;\n            }\n        }\n        // cleanup old files if buffer size is exceeded\n        let totalSize = (await Promise.all((await fs.promises.readdir(outputRootDir)).map(async (file) => (await fs.promises.stat(path.join(outputRootDir, file))).size))).reduce((a, b) => a + b, 0);\n        if (totalSize > bufferSizeMb * 1024 * 1024) {\n            const sortedFiles = (await fs.promises.readdir(outputRootDir)).map(async (file) => {\n                const stats = await fs.promises.stat(path.join(outputRootDir, file));\n                return { file, mtime: stats.mtime };\n            });\n            // Since map returns an array of promises, we need to await all of them\n            const resolvedFiles = await Promise.all(sortedFiles);\n            resolvedFiles.sort((a, b) => a.mtime.getTime() - b.mtime.getTime());\n            while (totalSize > bufferSizeMb * 1024 * 1024) {\n                const oldestFilePromise = sortedFiles.shift();\n                if (oldestFilePromise) {\n                    const oldestFile = await oldestFilePromise;\n                    const stats = await fs.promises.stat(path.join(outputRootDir, oldestFile.file));\n                    totalSize -= stats.size;\n                    await fs.promises.unlink(path.join(outputRootDir, oldestFile.file));\n                }\n            }\n        }\n        await fs.promises.writeFile(outputFilePath, JSON.stringify(simulateResult.get_obj_for_encoding(), null, 2));\n        return simulateResult;\n    }\n    catch (error) {\n        const err = error instanceof Error ? error : new Error(String(error));\n        Config.getLogger().error(`Failed to simulate and persist avm traces: ${err.stack ?? err.message ?? err}.`);\n        throw err;\n    }\n}\n\nexport { simulateAndPersistResponse };\n//# sourceMappingURL=simulate-and-persist-response.mjs.map\n","import algosdk from 'algosdk';\nimport { Buffer } from 'buffer';\nimport { Config } from '../config.mjs';\nimport { simulateAndPersistResponse } from '../debugging/simulate-and-persist-response.mjs';\nimport { toNumber } from '../util.mjs';\nimport { performAtomicTransactionComposerSimulate } from './perform-atomic-transaction-composer-simulate.mjs';\n\nvar AtomicTransactionComposer = algosdk.AtomicTransactionComposer;\nvar modelsv2 = algosdk.modelsv2;\nconst MAX_TRANSACTION_GROUP_SIZE = 16;\nconst MAX_APP_CALL_FOREIGN_REFERENCES = 8;\nconst MAX_APP_CALL_ACCOUNT_REFERENCES = 4;\n/** Encodes a transaction note into a byte array ready to be included in an Algorand transaction.\n *\n * @param note The transaction note\n * @returns the transaction note ready for inclusion in a transaction\n *\n *  Case on the value of `data` this either be:\n *   * `null` | `undefined`: `undefined`\n *   * `string`: The string value\n *   * Uint8Array: passthrough\n *   * Arc2TransactionNote object: ARC-0002 compatible transaction note\n *   * Else: The object/value converted into a JSON string representation\n */\nfunction encodeTransactionNote(note) {\n    if (note == null || typeof note === 'undefined') {\n        return undefined;\n    }\n    else if (typeof note === 'object' && note.constructor === Uint8Array) {\n        return note;\n    }\n    else if (typeof note === 'object' && 'dAppName' in note) {\n        const arc2Payload = `${note.dAppName}:${note.format}${typeof note.data === 'string' ? note.data : JSON.stringify(note.data)}`;\n        const encoder = new TextEncoder();\n        return encoder.encode(arc2Payload);\n    }\n    else {\n        const n = typeof note === 'string' ? note : JSON.stringify(note);\n        const encoder = new TextEncoder();\n        return encoder.encode(n);\n    }\n}\n/** Encodes a transaction lease into a 32-byte array ready to be included in an Algorand transaction.\n *\n * @param lease The transaction lease as a string or binary array or null/undefined if there is no lease\n * @returns the transaction lease ready for inclusion in a transaction or `undefined` if there is no lease\n * @throws if the length of the data is > 32 bytes or empty\n * @example algokit.encodeLease('UNIQUE_ID')\n * @example algokit.encodeLease(new Uint8Array([1, 2, 3]))\n */\nfunction encodeLease(lease) {\n    if (lease === null || typeof lease === 'undefined') {\n        return undefined;\n    }\n    else if (typeof lease === 'object' && lease.constructor === Uint8Array) {\n        if (lease.length === 0 || lease.length > 32) {\n            throw new Error(`Received invalid lease; expected something with length between 1 and 32, but received bytes with length ${lease.length}`);\n        }\n        if (lease.length === 32)\n            return lease;\n        const lease32 = new Uint8Array(32);\n        lease32.set(lease, 0);\n        return lease32;\n    }\n    else if (typeof lease === 'string') {\n        if (lease.length === 0 || lease.length > 32) {\n            throw new Error(`Received invalid lease; expected something with length between 1 and 32, but received '${lease}' with length ${lease.length}`);\n        }\n        const encoder = new TextEncoder();\n        const lease32 = new Uint8Array(32);\n        lease32.set(encoder.encode(lease), 0);\n        return lease32;\n    }\n    else {\n        throw new Error(`Unknown lease type received of ${typeof lease}`);\n    }\n}\n/**\n * Returns the public address of the given transaction sender.\n * @param sender A transaction sender\n * @returns The public address\n */\nconst getSenderAddress = function (sender) {\n    return typeof sender === 'string' ? sender : 'addr' in sender ? sender.addr : sender.address();\n};\n/**\n * Given a transaction in a variety of supported formats, returns a TransactionWithSigner object ready to be passed to an\n * AtomicTransactionComposer's addTransaction method.\n * @param transaction One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the\n * signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by\n * one of algokit utils' helpers (signer is obtained from the defaultSender parameter)\n * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not\n * include a signer.\n * @returns A TransactionWithSigner object.\n */\nconst getTransactionWithSigner = async (transaction, defaultSender) => {\n    if ('txn' in transaction)\n        return transaction;\n    if (defaultSender === undefined)\n        throw new Error('Default sender must be provided when passing in a transaction object that does not contain its own signer');\n    return transaction instanceof Promise\n        ? {\n            txn: (await transaction).transaction,\n            signer: getSenderTransactionSigner(defaultSender),\n        }\n        : 'transaction' in transaction\n            ? {\n                txn: transaction.transaction,\n                signer: getSenderTransactionSigner(transaction.signer),\n            }\n            : {\n                txn: transaction,\n                signer: getSenderTransactionSigner(defaultSender),\n            };\n};\nconst memoize = (fn) => {\n    const cache = new Map();\n    const cached = function (val) {\n        return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);\n    };\n    cached.cache = cache;\n    return cached;\n};\n/**\n * Returns a `TransactionSigner` for the given transaction sender.\n * This function has memoization, so will return the same transaction signer for a given sender.\n * @param sender A transaction sender\n * @returns A transaction signer\n */\nconst getSenderTransactionSigner = memoize(function (sender) {\n    return 'signer' in sender\n        ? sender.signer\n        : 'lsig' in sender\n            ? algosdk.makeLogicSigAccountTransactionSigner(sender)\n            : algosdk.makeBasicAccountTransactionSigner(sender);\n});\n/**\n * Signs a single transaction by the given signer.\n * @param transaction The transaction to sign\n * @param signer The signer to sign\n * @returns The signed transaction as a `Uint8Array`\n */\nconst signTransaction = async (transaction, signer) => {\n    return 'sk' in signer\n        ? transaction.signTxn(signer.sk)\n        : 'lsig' in signer\n            ? algosdk.signLogicSigTransactionObject(transaction, signer).blob\n            : 'sign' in signer\n                ? signer.sign(transaction)\n                : (await signer.signer([transaction], [0]))[0];\n};\n/** Prepares a transaction for sending and then (if instructed) signs and sends the given transaction to the chain.\n *\n * @param send The details for the transaction to prepare/send, including:\n *   * `transaction`: The unsigned transaction\n *   * `from`: The account to sign the transaction with: either an account with private key loaded or a logic signature account\n *   * `config`: The sending configuration for this transaction\n * @param algod An algod client\n *\n * @returns An object with transaction (`transaction`) and (if `skipWaiting` is `false` or `undefined`) confirmation (`confirmation`)\n */\nconst sendTransaction = async function (send, algod) {\n    const { transaction, from, sendParams } = send;\n    const { skipSending, skipWaiting, fee, maxFee, suppressLog, maxRoundsToWaitForConfirmation, atc } = sendParams ?? {};\n    controlFees(transaction, { fee, maxFee });\n    if (atc) {\n        atc.addTransaction({ txn: transaction, signer: getSenderTransactionSigner(from) });\n        return { transaction };\n    }\n    if (skipSending) {\n        return { transaction };\n    }\n    let txnToSend = transaction;\n    const populateResources = sendParams?.populateAppCallResources ?? Config.populateAppCallResources;\n    // Populate  resources if the transaction is an appcall and populateAppCallResources wasn't explicitly set to false\n    // NOTE: Temporary false by default until this algod bug is fixed: https://github.com/algorand/go-algorand/issues/5914\n    if (txnToSend.type === algosdk.TransactionType.appl && populateResources) {\n        const newAtc = new AtomicTransactionComposer();\n        newAtc.addTransaction({ txn: txnToSend, signer: getSenderTransactionSigner(from) });\n        const packed = await populateAppCallResources(newAtc, algod);\n        txnToSend = packed.buildGroup()[0].txn;\n    }\n    const signedTransaction = await signTransaction(txnToSend, from);\n    await algod.sendRawTransaction(signedTransaction).do();\n    Config.getLogger(suppressLog).verbose(`Sent transaction ID ${txnToSend.txID()} ${txnToSend.type} from ${getSenderAddress(from)}`);\n    let confirmation = undefined;\n    if (!skipWaiting) {\n        confirmation = await waitForConfirmation(txnToSend.txID(), maxRoundsToWaitForConfirmation ?? 5, algod);\n    }\n    return { transaction: txnToSend, confirmation };\n};\n/**\n * Get all of the unamed resources used by the group in the given ATC\n *\n * @param algod The algod client to use for the simulation\n * @param atc The ATC containing the txn group\n * @returns The unnamed resources accessed by the group and by each transaction in the group\n */\nasync function getUnnamedAppCallResourcesAccessed(atc, algod) {\n    const simReq = new algosdk.modelsv2.SimulateRequest({\n        txnGroups: [],\n        allowUnnamedResources: true,\n        allowEmptySignatures: true,\n    });\n    const signerWithFixedSgnr = async (txns, indexes) => {\n        const stxns = await algosdk.makeEmptyTransactionSigner()(txns, indexes);\n        return Promise.all(stxns.map(async (stxn) => {\n            const decodedStxn = algosdk.decodeSignedTransaction(stxn);\n            const sender = algosdk.encodeAddress(decodedStxn.txn.from.publicKey);\n            const authAddr = (await algod.accountInformation(sender).do())['auth-addr'];\n            const stxnObj = { txn: decodedStxn.txn.get_obj_for_encoding() };\n            if (authAddr !== undefined) {\n                stxnObj.sgnr = Buffer.from(algosdk.decodeAddress(authAddr).publicKey);\n            }\n            return algosdk.encodeObj(stxnObj);\n        }));\n    };\n    const emptySignerAtc = atc.clone();\n    emptySignerAtc['transactions'].forEach((t) => {\n        t.signer = signerWithFixedSgnr;\n    });\n    const result = await emptySignerAtc.simulate(algod, simReq);\n    const groupResponse = result.simulateResponse.txnGroups[0];\n    if (groupResponse.failureMessage) {\n        throw Error(`Error during resource population simulation in transaction ${groupResponse.failedAt}: ${groupResponse.failureMessage}`);\n    }\n    return {\n        group: groupResponse.unnamedResourcesAccessed,\n        txns: groupResponse.txnResults.map(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (t) => t.unnamedResourcesAccessed),\n    };\n}\n/**\n * Take an existing Atomic Transaction Composer and return a new one with the required\n *  app call resources packed into it\n *\n * @param algod The algod client to use for the simulation\n * @param atc The ATC containing the txn group\n * @returns A new ATC with the resources packed into the transactions\n *\n * @privateRemarks\n *\n * This entire function will eventually be implemented in simulate upstream in algod. The simulate endpoint will return\n * an array of refference arrays for each transaction, so this eventually will eventually just call simulate and set the\n * reference arrays in the transactions to the reference arrays returned by simulate.\n *\n * See https://github.com/algorand/go-algorand/pull/5684\n *\n */\nasync function populateAppCallResources(atc, algod) {\n    const unnamedResourcesAccessed = await getUnnamedAppCallResourcesAccessed(atc, algod);\n    const group = atc.buildGroup();\n    unnamedResourcesAccessed.txns.forEach((r, i) => {\n        if (r === undefined)\n            return;\n        if (r.boxes || r.extraBoxRefs)\n            throw Error('Unexpected boxes at the transaction level');\n        if (r.appLocals)\n            throw Error('Unexpected app local at the transaction level');\n        if (r.assetHoldings)\n            throw Error('Unexpected asset holding at the transaction level');\n        // Do accounts first because the account limit is 4\n        r.accounts?.forEach((a) => {\n            group[i].txn.appAccounts = [...(group[i].txn.appAccounts ?? []), algosdk.decodeAddress(a)];\n        });\n        r.apps?.forEach((a) => {\n            group[i].txn.appForeignApps = [...(group[i].txn.appForeignApps ?? []), Number(a)];\n        });\n        r.assets?.forEach((a) => {\n            group[i].txn.appForeignAssets = [...(group[i].txn.appForeignAssets ?? []), Number(a)];\n        });\n        const accounts = group[i].txn.appAccounts?.length || 0;\n        if (accounts > MAX_APP_CALL_ACCOUNT_REFERENCES)\n            throw Error(`Account reference limit of ${MAX_APP_CALL_ACCOUNT_REFERENCES} exceeded in transaction ${i}`);\n        const assets = group[i].txn.appForeignAssets?.length || 0;\n        const apps = group[i].txn.appForeignApps?.length || 0;\n        const boxes = group[i].txn.boxes?.length || 0;\n        if (accounts + assets + apps + boxes > MAX_APP_CALL_FOREIGN_REFERENCES) {\n            throw Error(`Resource reference limit of ${MAX_APP_CALL_FOREIGN_REFERENCES} exceeded in transaction ${i}`);\n        }\n    });\n    const populateGroupResource = (txns, reference, type) => {\n        const isApplBelowLimit = (t) => {\n            if (t.txn.type !== algosdk.TransactionType.appl)\n                return false;\n            const accounts = t.txn.appAccounts?.length || 0;\n            const assets = t.txn.appForeignAssets?.length || 0;\n            const apps = t.txn.appForeignApps?.length || 0;\n            const boxes = t.txn.boxes?.length || 0;\n            return accounts + assets + apps + boxes < MAX_APP_CALL_FOREIGN_REFERENCES;\n        };\n        // If this is a asset holding or app local, first try to find a transaction that already has the account available\n        if (type === 'assetHolding' || type === 'appLocal') {\n            const { account } = reference;\n            let txnIndex = txns.findIndex((t) => {\n                if (!isApplBelowLimit(t))\n                    return false;\n                return (\n                // account is in the foreign accounts array\n                t.txn.appAccounts?.map((a) => algosdk.encodeAddress(a.publicKey)).includes(account) ||\n                    // account is available as an app account\n                    t.txn.appForeignApps?.map((a) => algosdk.getApplicationAddress(a)).includes(account) ||\n                    // account is available since it's in one of the fields\n                    Object.values(t.txn)\n                        .map((f) => JSON.stringify(f))\n                        .includes(JSON.stringify(algosdk.decodeAddress(account))));\n            });\n            if (txnIndex > -1) {\n                if (type === 'assetHolding') {\n                    const { asset } = reference;\n                    txns[txnIndex].txn.appForeignAssets = [...(txns[txnIndex].txn.appForeignAssets ?? []), Number(asset)];\n                }\n                else {\n                    const { app } = reference;\n                    txns[txnIndex].txn.appForeignApps = [...(txns[txnIndex].txn.appForeignApps ?? []), Number(app)];\n                }\n                return;\n            }\n            // Now try to find a txn that already has that app or asset available\n            txnIndex = txns.findIndex((t) => {\n                if (!isApplBelowLimit(t))\n                    return false;\n                // check if there is space in the accounts array\n                if ((t.txn.appAccounts?.length || 0) >= MAX_APP_CALL_ACCOUNT_REFERENCES)\n                    return false;\n                if (type === 'assetHolding') {\n                    const { asset } = reference;\n                    return t.txn.appForeignAssets?.includes(Number(asset));\n                }\n                else {\n                    const { app } = reference;\n                    return t.txn.appForeignApps?.includes(Number(app)) || t.txn.appIndex === Number(app);\n                }\n            });\n            if (txnIndex > -1) {\n                const { account } = reference;\n                txns[txnIndex].txn.appAccounts = [...(txns[txnIndex].txn.appAccounts ?? []), algosdk.decodeAddress(account)];\n                return;\n            }\n        }\n        // If this is a box, first try to find a transaction that already has the app available\n        if (type === 'box') {\n            const { app, name } = reference;\n            const txnIndex = txns.findIndex((t) => {\n                if (!isApplBelowLimit(t))\n                    return false;\n                // If the app is in the foreign array OR the app being called, then we know it's available\n                return t.txn.appForeignApps?.includes(Number(app)) || t.txn.appIndex === Number(app);\n            });\n            if (txnIndex > -1) {\n                txns[txnIndex].txn.boxes = [...(txns[txnIndex].txn.boxes ?? []), { appIndex: Number(app), name }];\n                return;\n            }\n        }\n        // Find the txn index to put the reference(s)\n        const txnIndex = txns.findIndex((t) => {\n            if (t.txn.type !== algosdk.TransactionType.appl)\n                return false;\n            const accounts = t.txn.appAccounts?.length || 0;\n            if (type === 'account')\n                return accounts < MAX_APP_CALL_ACCOUNT_REFERENCES;\n            const assets = t.txn.appForeignAssets?.length || 0;\n            const apps = t.txn.appForeignApps?.length || 0;\n            const boxes = t.txn.boxes?.length || 0;\n            // If we're adding local state or asset holding, we need space for the acocunt and the other reference\n            if (type === 'assetHolding' || type === 'appLocal') {\n                return accounts + assets + apps + boxes < MAX_APP_CALL_FOREIGN_REFERENCES - 1 && accounts < MAX_APP_CALL_ACCOUNT_REFERENCES;\n            }\n            // If we're adding a box, we need space for both the box ref and the app ref\n            if (type === 'box' && BigInt(reference.app) !== BigInt(0)) {\n                return accounts + assets + apps + boxes < MAX_APP_CALL_FOREIGN_REFERENCES - 1;\n            }\n            return accounts + assets + apps + boxes < MAX_APP_CALL_FOREIGN_REFERENCES;\n        });\n        if (txnIndex === -1) {\n            throw Error('No more transactions below reference limit. Add another app call to the group.');\n        }\n        if (type === 'account') {\n            txns[txnIndex].txn.appAccounts = [...(txns[txnIndex].txn.appAccounts ?? []), algosdk.decodeAddress(reference)];\n        }\n        else if (type === 'app') {\n            txns[txnIndex].txn.appForeignApps = [...(txns[txnIndex].txn.appForeignApps ?? []), Number(reference)];\n        }\n        else if (type === 'box') {\n            const { app, name } = reference;\n            txns[txnIndex].txn.boxes = [...(txns[txnIndex].txn.boxes ?? []), { appIndex: Number(app), name }];\n            if (app.toString() !== '0') {\n                txns[txnIndex].txn.appForeignApps = [...(txns[txnIndex].txn.appForeignApps ?? []), Number(app)];\n            }\n        }\n        else if (type === 'assetHolding') {\n            const { asset, account } = reference;\n            txns[txnIndex].txn.appForeignAssets = [...(txns[txnIndex].txn.appForeignAssets ?? []), Number(asset)];\n            txns[txnIndex].txn.appAccounts = [...(txns[txnIndex].txn.appAccounts ?? []), algosdk.decodeAddress(account)];\n        }\n        else if (type === 'appLocal') {\n            const { app, account } = reference;\n            txns[txnIndex].txn.appAccounts = [...(txns[txnIndex].txn.appAccounts ?? []), algosdk.decodeAddress(account)];\n            txns[txnIndex].txn.appForeignApps = [...(txns[txnIndex].txn.appForeignApps ?? []), Number(app)];\n        }\n        else if (type === 'asset') {\n            txns[txnIndex].txn.appForeignAssets = [...(txns[txnIndex].txn.appForeignAssets ?? []), Number(reference)];\n        }\n    };\n    const g = unnamedResourcesAccessed.group;\n    if (g) {\n        // Do cross-reference resources first because they are the most restrictive in terms\n        // of which transactions can be used\n        g.appLocals?.forEach((a) => {\n            populateGroupResource(group, a, 'appLocal');\n            // Remove resources from the group if we're adding them here\n            g.accounts = g.accounts?.filter((acc) => acc !== a.account);\n            g.apps = g.apps?.filter((app) => BigInt(app) !== BigInt(a.app));\n        });\n        g.assetHoldings?.forEach((a) => {\n            populateGroupResource(group, a, 'assetHolding');\n            // Remove resources from the group if we're adding them here\n            g.accounts = g.accounts?.filter((acc) => acc !== a.account);\n            g.assets = g.assets?.filter((asset) => BigInt(asset) !== BigInt(a.asset));\n        });\n        // Do accounts next because the account limit is 4\n        g.accounts?.forEach((a) => {\n            populateGroupResource(group, a, 'account');\n        });\n        g.boxes?.forEach((b) => {\n            populateGroupResource(group, b, 'box');\n            // Remove apps as resource from the group if we're adding it here\n            g.apps = g.apps?.filter((app) => BigInt(app) !== BigInt(b.app));\n        });\n        g.assets?.forEach((a) => {\n            populateGroupResource(group, a, 'asset');\n        });\n        g.apps?.forEach((a) => {\n            populateGroupResource(group, a, 'app');\n        });\n        if (g.extraBoxRefs) {\n            for (let i = 0; i < g.extraBoxRefs; i += 1) {\n                const ref = new algosdk.modelsv2.BoxReference({ app: 0, name: new Uint8Array(0) });\n                populateGroupResource(group, ref, 'box');\n            }\n        }\n    }\n    const newAtc = new algosdk.AtomicTransactionComposer();\n    group.forEach((t) => {\n        // eslint-disable-next-line no-param-reassign\n        t.txn.group = undefined;\n        newAtc.addTransaction(t);\n    });\n    newAtc['methodCalls'] = atc['methodCalls'];\n    return newAtc;\n}\n/**\n * Signs and sends transactions that have been collected by an `AtomicTransactionComposer`.\n * @param atcSend The parameters controlling the send, including:\n *  * `atc` The `AtomicTransactionComposer`\n *  * `sendParams` The parameters to control the send behaviour\n * @param algod An algod client\n * @returns An object with transaction IDs, transactions, group transaction ID (`groupTransactionId`) if more than 1 transaction sent, and (if `skipWaiting` is `false` or unset) confirmation (`confirmation`)\n */\nconst sendAtomicTransactionComposer = async function (atcSend, algod) {\n    const { atc: givenAtc, sendParams } = atcSend;\n    let atc;\n    // const hasAppCalls = () =>\n    //   givenAtc\n    //     .buildGroup()\n    //     .map((t) => t.txn.type)\n    //     .includes(algosdk.TransactionType.appl)\n    atc = givenAtc;\n    try {\n        // If populateAppCallResources is true OR if populateAppCallResources is undefined and there are app calls, then populate resources\n        // NOTE: Temporary false by default until this algod bug is fixed: https://github.com/algorand/go-algorand/issues/5914\n        const populateResources = sendParams?.populateAppCallResources ?? Config.populateAppCallResources;\n        if (populateResources) {\n            atc = await populateAppCallResources(givenAtc, algod);\n        }\n        const transactionsWithSigner = atc.buildGroup();\n        const transactionsToSend = transactionsWithSigner.map((t) => {\n            return t.txn;\n        });\n        let groupId = undefined;\n        if (transactionsToSend.length > 1) {\n            groupId = transactionsToSend[0].group ? Buffer.from(transactionsToSend[0].group).toString('base64') : '';\n            Config.getLogger(sendParams?.suppressLog).verbose(`Sending group of ${transactionsToSend.length} transactions (${groupId})`, {\n                transactionsToSend,\n            });\n            Config.getLogger(sendParams?.suppressLog).debug(`Transaction IDs (${groupId})`, transactionsToSend.map((t) => t.txID()));\n        }\n        if (Config.debug && Config.projectRoot && Config.traceAll) {\n            // Dump the traces to a file for use with AlgoKit AVM debugger\n            await simulateAndPersistResponse({\n                atc,\n                projectRoot: Config.projectRoot,\n                algod,\n                bufferSizeMb: Config.traceBufferSizeMb,\n            });\n        }\n        const result = await atc.execute(algod, sendParams?.maxRoundsToWaitForConfirmation ?? 5);\n        if (transactionsToSend.length > 1) {\n            Config.getLogger(sendParams?.suppressLog).verbose(`Group transaction (${groupId}) sent with ${transactionsToSend.length} transactions`);\n        }\n        else {\n            Config.getLogger(sendParams?.suppressLog).verbose(`Sent transaction ID ${transactionsToSend[0].txID()} ${transactionsToSend[0].type} from ${algosdk.encodeAddress(transactionsToSend[0].from.publicKey)}`);\n        }\n        let confirmations = undefined;\n        if (!sendParams?.skipWaiting) {\n            confirmations = await Promise.all(transactionsToSend.map(async (t) => modelsv2.PendingTransactionResponse.from_obj_for_encoding(await algod.pendingTransactionInformation(t.txID()).do())));\n        }\n        return {\n            groupId,\n            confirmations,\n            txIds: transactionsToSend.map((t) => t.txID()),\n            transactions: transactionsToSend,\n            returns: result.methodResults.map((r) => ({\n                decodeError: r.decodeError,\n                returnValue: r.returnValue,\n                rawReturnValue: r.rawReturnValue,\n            })),\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    }\n    catch (e) {\n        // Remove headers as it doesn't have anything useful.\n        delete e.response?.headers;\n        if (Config.debug && typeof e === 'object') {\n            e.traces = [];\n            Config.logger.error('Received error executing Atomic Transaction Composer and debug flag enabled; attempting simulation to get more information', e);\n            let simulate = undefined;\n            if (Config.debug && Config.projectRoot && !Config.traceAll) {\n                // Dump the traces to a file for use with AlgoKit AVM debugger\n                // Checks for false on traceAll because it should have been already\n                // executed above\n                simulate = await simulateAndPersistResponse({\n                    atc,\n                    projectRoot: Config.projectRoot,\n                    algod,\n                    bufferSizeMb: Config.traceBufferSizeMb,\n                });\n            }\n            else {\n                simulate = await performAtomicTransactionComposerSimulate(atc, algod);\n            }\n            if (simulate && simulate.txnGroups[0].failedAt) {\n                for (const txn of simulate.txnGroups[0].txnResults) {\n                    e.traces.push({\n                        trace: txn.execTrace?.get_obj_for_encoding(),\n                        appBudget: txn.appBudgetConsumed,\n                        logicSigBudget: txn.logicSigBudgetConsumed,\n                        logs: txn.txnResult.logs,\n                        message: simulate.txnGroups[0].failureMessage,\n                    });\n                }\n            }\n        }\n        else {\n            Config.logger.error('Received error executing Atomic Transaction Composer, for more information enable the debug flag', e);\n        }\n        throw e;\n    }\n};\n/**\n * Performs a dry run of the transactions loaded into the given AtomicTransactionComposer`\n * @param atc The AtomicTransactionComposer` with transaction(s) loaded\n * @param algod An Algod client\n * @returns The dryrun result\n */\nasync function performAtomicTransactionComposerDryrun(atc, algod) {\n    const signedTransactions = await atc.gatherSignatures();\n    const txns = signedTransactions.map((t) => {\n        return algosdk.decodeSignedTransaction(t);\n    });\n    const dryrun = await algosdk.createDryrun({ client: algod, txns });\n    return new algosdk.DryrunResult(await algod.dryrun(dryrun).do());\n}\n/**\n * Signs and sends a group of [up to 16](https://developer.algorand.org/docs/get-details/atomic_transfers/#create-transactions) transactions to the chain\n *\n * @param groupSend The group details to send, with:\n *   * `transactions`: The array of transactions to send along with their signing account\n *   * `sendParams`: The parameters to dictate how the group is sent\n * @param algod An algod client\n * @returns An object with transaction IDs, transactions, group transaction ID (`groupTransactionId`) if more than 1 transaction sent, and (if `skipWaiting` is `false` or unset) confirmation (`confirmation`)\n */\nconst sendGroupOfTransactions = async function (groupSend, algod) {\n    const { transactions, signer, sendParams } = groupSend;\n    const defaultTransactionSigner = signer ? getSenderTransactionSigner(signer) : undefined;\n    const transactionsWithSigner = await Promise.all(transactions.map(async (t) => {\n        if ('signer' in t)\n            return {\n                txn: t.transaction,\n                signer: getSenderTransactionSigner(t.signer),\n                sender: t.signer,\n            };\n        const txn = 'then' in t ? (await t).transaction : t;\n        if (!signer) {\n            throw new Error(`Attempt to send transaction ${txn.txID()} as part of a group transaction, but no signer parameter was provided.`);\n        }\n        return {\n            txn,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            signer: defaultTransactionSigner,\n            sender: signer,\n        };\n    }));\n    const atc = new AtomicTransactionComposer();\n    transactionsWithSigner.forEach((txn) => atc.addTransaction(txn));\n    return (await sendAtomicTransactionComposer({ atc, sendParams }, algod));\n};\n/**\n * Wait until the transaction is confirmed or rejected, or until `timeout`\n * number of rounds have passed.\n *\n * @param algod An algod client\n * @param transactionId The transaction ID to wait for\n * @param maxRoundsToWait Maximum number of rounds to wait\n *\n * @return Pending transaction information\n * @throws Throws an error if the transaction is not confirmed or rejected in the next `timeout` rounds\n */\nconst waitForConfirmation = async function (transactionId, maxRoundsToWait, algod) {\n    if (maxRoundsToWait < 0) {\n        throw new Error(`Invalid timeout, received ${maxRoundsToWait}, expected > 0`);\n    }\n    // Get current round\n    const status = modelsv2.NodeStatusResponse.from_obj_for_encoding(await algod.status().do());\n    if (status === undefined) {\n        throw new Error('Unable to get node status');\n    }\n    // Loop for up to `timeout` rounds looking for a confirmed transaction\n    const startRound = BigInt(status.lastRound) + 1n;\n    let currentRound = startRound;\n    while (currentRound < startRound + BigInt(maxRoundsToWait)) {\n        try {\n            const pendingInfo = modelsv2.PendingTransactionResponse.from_obj_for_encoding(await algod.pendingTransactionInformation(transactionId).do());\n            if (pendingInfo !== undefined) {\n                const confirmedRound = pendingInfo.confirmedRound;\n                if (confirmedRound && confirmedRound > 0) {\n                    return pendingInfo;\n                }\n                else {\n                    const poolError = pendingInfo.poolError;\n                    if (poolError != null && poolError.length > 0) {\n                        // If there was a pool error, then the transaction has been rejected!\n                        throw new Error(`Transaction ${transactionId} was rejected; pool error: ${poolError}`);\n                    }\n                }\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            if (e.name === 'URLTokenBaseHTTPError') {\n                currentRound++;\n                continue;\n            }\n        }\n        await algod.statusAfterBlock(toNumber(currentRound)).do();\n        currentRound++;\n    }\n    throw new Error(`Transaction ${transactionId} not confirmed after ${maxRoundsToWait} rounds`);\n};\n/**\n * Limit the acceptable fee to a defined amount of ALGOs.\n * This also sets the transaction to be flatFee to ensure the transaction only succeeds at\n * the estimated rate.\n * @param transaction The transaction to cap or suggested params object about to be used to create a transaction\n * @param maxAcceptableFee The maximum acceptable fee to pay\n */\nfunction capTransactionFee(transaction, maxAcceptableFee) {\n    // If a flat fee hasn't already been defined\n    if (!transaction.flatFee) {\n        // Once a transaction has been constructed by algosdk, transaction.fee indicates what the total transaction fee\n        // Will be based on the current suggested fee-per-byte value.\n        if (transaction.fee > maxAcceptableFee.microAlgos) {\n            throw new Error(`Cancelled transaction due to high network congestion fees. Algorand suggested fees would cause this transaction to cost ${transaction.fee} ALGOs. Cap for this transaction is ${maxAcceptableFee.microAlgos} ALGOs.`);\n        }\n        else if (transaction.fee > algosdk.ALGORAND_MIN_TX_FEE) {\n            Config.logger.warn(`Algorand network congestion fees are in effect. This transaction will incur a fee of ${transaction.fee} ALGOs.`);\n        }\n        // Now set the flat on the transaction. Otherwise the network may increase the fee above our cap and perform the transaction.\n        transaction.flatFee = true;\n    }\n}\n/**\n * Allows for control of fees on a `Transaction` or `SuggestedParams` object\n * @param transaction The transaction or suggested params\n * @param feeControl The fee control parameters\n */\nfunction controlFees(transaction, feeControl) {\n    const { fee, maxFee } = feeControl;\n    if (fee) {\n        transaction.fee = fee.microAlgos;\n        transaction.flatFee = true;\n    }\n    if (maxFee !== undefined) {\n        capTransactionFee(transaction, maxFee);\n    }\n    return transaction;\n}\n/**\n * Returns suggested transaction parameters from algod unless some are already provided.\n * @param params Optionally provide parameters to use\n * @param algod Algod algod\n * @returns The suggested transaction parameters\n */\nasync function getTransactionParams(params, algod) {\n    return params ? { ...params } : await algod.getTransactionParams().do();\n}\n/**\n * Returns the array of transactions currently present in the given `AtomicTransactionComposer`\n * @param atc The atomic transaction composer\n * @returns The array of transactions with signers\n */\nfunction getAtomicTransactionComposerTransactions(atc) {\n    try {\n        return atc.clone().buildGroup();\n    }\n    catch {\n        return [];\n    }\n}\n\nexport { MAX_APP_CALL_ACCOUNT_REFERENCES, MAX_APP_CALL_FOREIGN_REFERENCES, MAX_TRANSACTION_GROUP_SIZE, capTransactionFee, controlFees, encodeLease, encodeTransactionNote, getAtomicTransactionComposerTransactions, getSenderAddress, getSenderTransactionSigner, getTransactionParams, getTransactionWithSigner, performAtomicTransactionComposerDryrun, populateAppCallResources, sendAtomicTransactionComposer, sendGroupOfTransactions, sendTransaction, signTransaction, waitForConfirmation };\n//# sourceMappingURL=transaction.mjs.map\n","/** The name of the TEAL template variable for deploy-time immutability control */\nconst UPDATABLE_TEMPLATE_NAME = 'TMPL_UPDATABLE';\n/** The name of the TEAL template variable for deploy-time permanence control */\nconst DELETABLE_TEMPLATE_NAME = 'TMPL_DELETABLE';\n/** The app create/update ARC-2 transaction note prefix */\nconst APP_DEPLOY_NOTE_DAPP = 'ALGOKIT_DEPLOYER';\n/** The maximum number of bytes in a single app code page */\nconst APP_PAGE_MAX_SIZE = 2048;\n/** First 4 bytes of SHA-512/256 hash of \"return\" for retrieving ABI return values */\nconst ABI_RETURN_PREFIX = new Uint8Array([21, 31, 124, 117]);\n/** What action to perform when deploying an app and an update is detected in the TEAL code */\nvar OnUpdate;\n(function (OnUpdate) {\n    /** Fail the deployment */\n    OnUpdate[OnUpdate[\"Fail\"] = 0] = \"Fail\";\n    /** Update the app */\n    OnUpdate[OnUpdate[\"UpdateApp\"] = 1] = \"UpdateApp\";\n    /** Delete the app and create a new one in its place */\n    OnUpdate[OnUpdate[\"ReplaceApp\"] = 2] = \"ReplaceApp\";\n    /** Create a new app */\n    OnUpdate[OnUpdate[\"AppendApp\"] = 3] = \"AppendApp\";\n})(OnUpdate || (OnUpdate = {}));\n/** What action to perform when deploying an app and a breaking schema change is detected */\nvar OnSchemaBreak;\n(function (OnSchemaBreak) {\n    /** Fail the deployment */\n    OnSchemaBreak[OnSchemaBreak[\"Fail\"] = 0] = \"Fail\";\n    /** Delete the app and create a new one in its place */\n    OnSchemaBreak[OnSchemaBreak[\"ReplaceApp\"] = 1] = \"ReplaceApp\";\n    /** Create a new app */\n    OnSchemaBreak[OnSchemaBreak[\"AppendApp\"] = 2] = \"AppendApp\";\n})(OnSchemaBreak || (OnSchemaBreak = {}));\n\nexport { ABI_RETURN_PREFIX, APP_DEPLOY_NOTE_DAPP, APP_PAGE_MAX_SIZE, DELETABLE_TEMPLATE_NAME, OnSchemaBreak, OnUpdate, UPDATABLE_TEMPLATE_NAME };\n//# sourceMappingURL=app.mjs.map\n","import algosdk from 'algosdk';\nimport { Buffer } from 'buffer';\nimport { Config } from './config.mjs';\nimport { getAtomicTransactionComposerTransactions, controlFees, getTransactionParams, encodeTransactionNote, sendAtomicTransactionComposer, getSenderAddress, sendTransaction, encodeLease, getSenderTransactionSigner } from './transaction/transaction.mjs';\nimport { APP_PAGE_MAX_SIZE } from './types/app.mjs';\nimport { toNumber } from './util.mjs';\n\nvar ABIMethod = algosdk.ABIMethod;\nvar AtomicTransactionComposer = algosdk.AtomicTransactionComposer;\nvar modelsv2 = algosdk.modelsv2;\nvar OnApplicationComplete = algosdk.OnApplicationComplete;\nvar SourceMap = algosdk.SourceMap;\n/**\n * Creates a smart contract app, returns the details of the created app.\n * @param create The parameters to create the app with\n * @param algod An algod client\n * @returns The details of the created app, or the transaction to create it if `skipSending` and the compilation result\n */\nasync function createApp(create, algod) {\n    const { from, approvalProgram: approval, clearStateProgram: clear, schema, note, transactionParams, args, onCompleteAction, ...sendParams } = create;\n    const compiledApproval = typeof approval === 'string' ? await compileTeal(approval, algod) : undefined;\n    const approvalProgram = compiledApproval ? compiledApproval.compiledBase64ToBytes : approval;\n    const compiledClear = typeof clear === 'string' ? await compileTeal(clear, algod) : undefined;\n    const clearProgram = compiledClear ? compiledClear.compiledBase64ToBytes : clear;\n    if (args && args.method) {\n        const atc = attachATC(sendParams);\n        const before = getAtomicTransactionComposerTransactions(atc);\n        atc.addMethodCall({\n            appID: 0,\n            approvalProgram: approvalProgram,\n            clearProgram: clearProgram,\n            numLocalInts: schema.localInts,\n            numLocalByteSlices: schema.localByteSlices,\n            numGlobalInts: schema.globalInts,\n            numGlobalByteSlices: schema.globalByteSlices,\n            extraPages: schema.extraPages ?? Math.floor((approvalProgram.length + clearProgram.length) / APP_PAGE_MAX_SIZE),\n            onComplete: getAppOnCompleteAction(onCompleteAction),\n            suggestedParams: controlFees(await getTransactionParams(transactionParams, algod), sendParams),\n            note: encodeTransactionNote(note),\n            ...(await getAppArgsForABICall(args, from)),\n        });\n        if (sendParams.skipSending) {\n            const after = atc.clone().buildGroup();\n            return {\n                transaction: after[after.length - 1].txn,\n                transactions: after.slice(before.length).map((t) => t.txn),\n                appId: 0,\n                appAddress: '',\n                compiledApproval,\n                compiledClear,\n            };\n        }\n        const result = await sendAtomicTransactionComposer({ atc, sendParams }, algod);\n        const confirmation = result.confirmations ? result.confirmations[result.confirmations?.length - 1] : undefined;\n        if (confirmation) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const appId = confirmation.applicationIndex;\n            Config.getLogger(sendParams.suppressLog).debug(`Created app ${appId} from creator ${getSenderAddress(from)}`);\n            return {\n                transactions: result.transactions,\n                confirmations: result.confirmations,\n                return: confirmation ? getABIReturn(args, confirmation) : undefined,\n                transaction: result.transactions[result.transactions.length - 1],\n                confirmation: confirmation,\n                appId,\n                appAddress: algosdk.getApplicationAddress(appId),\n                compiledApproval,\n                compiledClear,\n            };\n        }\n        else {\n            return {\n                transactions: result.transactions,\n                confirmations: result.confirmations,\n                return: confirmation ? getABIReturn(args, confirmation) : undefined,\n                transaction: result.transactions[result.transactions.length - 1],\n                confirmation: confirmation,\n                appId: 0,\n                appAddress: '',\n                compiledApproval,\n                compiledClear,\n            };\n        }\n    }\n    else {\n        const transaction = algosdk.makeApplicationCreateTxnFromObject({\n            approvalProgram: approvalProgram,\n            clearProgram: clearProgram,\n            numLocalInts: schema.localInts,\n            numLocalByteSlices: schema.localByteSlices,\n            numGlobalInts: schema.globalInts,\n            numGlobalByteSlices: schema.globalByteSlices,\n            extraPages: schema.extraPages ?? Math.floor((approvalProgram.length + clearProgram.length) / APP_PAGE_MAX_SIZE),\n            onComplete: getAppOnCompleteAction(onCompleteAction),\n            suggestedParams: await getTransactionParams(transactionParams, algod),\n            from: getSenderAddress(from),\n            note: encodeTransactionNote(note),\n            ...getAppArgsForTransaction(args),\n            rekeyTo: args?.rekeyTo ? (typeof args.rekeyTo === 'string' ? args.rekeyTo : getSenderAddress(args.rekeyTo)) : undefined,\n        });\n        const { confirmation } = await sendTransaction({ transaction, from, sendParams }, algod);\n        if (confirmation) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const appId = confirmation.applicationIndex;\n            Config.getLogger(sendParams.suppressLog).debug(`Created app ${appId} from creator ${getSenderAddress(from)}`);\n            return {\n                transaction,\n                transactions: [transaction],\n                confirmation,\n                confirmations: confirmation ? [confirmation] : undefined,\n                appId,\n                appAddress: algosdk.getApplicationAddress(appId),\n                return: getABIReturn(args, confirmation),\n                compiledApproval,\n                compiledClear,\n            };\n        }\n        else {\n            return { transaction, transactions: [transaction], appId: 0, appAddress: '', compiledApproval, compiledClear };\n        }\n    }\n}\n/**\n * Updates a smart contract app.\n * @param update The parameters to update the app with\n * @param algod An algod client\n * @returns The transaction send result and the compilation result\n */\nasync function updateApp(update, algod) {\n    const { appId, from, approvalProgram: approval, clearStateProgram: clear, note, transactionParams, args, ...sendParams } = update;\n    const compiledApproval = typeof approval === 'string' ? await compileTeal(approval, algod) : undefined;\n    const approvalProgram = compiledApproval ? compiledApproval.compiledBase64ToBytes : approval;\n    const compiledClear = typeof clear === 'string' ? await compileTeal(clear, algod) : undefined;\n    const clearProgram = compiledClear ? compiledClear.compiledBase64ToBytes : clear;\n    Config.getLogger(sendParams.suppressLog).debug(`Updating app ${appId}`);\n    if (args && args.method) {\n        const atc = attachATC(sendParams);\n        const before = getAtomicTransactionComposerTransactions(atc);\n        atc.addMethodCall({\n            appID: toNumber(appId),\n            onComplete: OnApplicationComplete.UpdateApplicationOC,\n            approvalProgram: approvalProgram,\n            clearProgram: clearProgram,\n            suggestedParams: controlFees(await getTransactionParams(transactionParams, algod), sendParams),\n            note: encodeTransactionNote(note),\n            ...(await getAppArgsForABICall(args, from)),\n        });\n        if (sendParams.skipSending) {\n            const after = atc.clone().buildGroup();\n            return {\n                transaction: after[after.length - 1].txn,\n                transactions: after.slice(before.length).map((t) => t.txn),\n            };\n        }\n        const result = await sendAtomicTransactionComposer({ atc, sendParams }, algod);\n        const confirmation = result.confirmations ? result.confirmations[result.confirmations?.length - 1] : undefined;\n        return {\n            transactions: result.transactions,\n            confirmations: result.confirmations,\n            return: confirmation ? getABIReturn(args, confirmation) : undefined,\n            transaction: result.transactions[result.transactions.length - 1],\n            confirmation: confirmation,\n        };\n    }\n    else {\n        const transaction = algosdk.makeApplicationUpdateTxnFromObject({\n            appIndex: toNumber(appId),\n            approvalProgram: approvalProgram,\n            clearProgram: clearProgram,\n            suggestedParams: await getTransactionParams(transactionParams, algod),\n            from: getSenderAddress(from),\n            note: encodeTransactionNote(note),\n            ...getAppArgsForTransaction(args),\n            rekeyTo: args?.rekeyTo ? (typeof args.rekeyTo === 'string' ? args.rekeyTo : getSenderAddress(args.rekeyTo)) : undefined,\n        });\n        const result = await sendTransaction({ transaction, from, sendParams }, algod);\n        return {\n            ...result,\n            transactions: [result.transaction],\n            confirmations: result.confirmation ? [result.confirmation] : undefined,\n            return: getABIReturn(args, result.confirmation),\n            compiledApproval,\n            compiledClear,\n        };\n    }\n}\nfunction attachATC(sendParams) {\n    if (sendParams.atc) {\n        sendParams.skipSending = true;\n    }\n    sendParams.atc = sendParams.atc ?? new AtomicTransactionComposer();\n    return sendParams.atc;\n}\n/** Returns an `algosdk.OnApplicationComplete` for the given onCompleteAction.\n *\n * If given `undefined` will return `OnApplicationComplete.NoOpOC`.\n *\n * If given an `AppCallType` will convert the string enum to the correct underlying `algosdk.OnApplicationComplete`.\n *\n * @param onCompletionAction The on completion action\n * @returns The `algosdk.OnApplicationComplete`\n */\nfunction getAppOnCompleteAction(onCompletionAction) {\n    switch (onCompletionAction) {\n        case undefined:\n        case 'no_op':\n        case OnApplicationComplete.NoOpOC:\n            return OnApplicationComplete.NoOpOC;\n        case 'opt_in':\n        case OnApplicationComplete.OptInOC:\n            return OnApplicationComplete.OptInOC;\n        case 'close_out':\n        case OnApplicationComplete.CloseOutOC:\n            return OnApplicationComplete.CloseOutOC;\n        case 'clear_state':\n        case OnApplicationComplete.ClearStateOC:\n            return OnApplicationComplete.ClearStateOC;\n        case 'update_application':\n        case OnApplicationComplete.UpdateApplicationOC:\n            return OnApplicationComplete.UpdateApplicationOC;\n        case 'delete_application':\n        case OnApplicationComplete.DeleteApplicationOC:\n            return OnApplicationComplete.DeleteApplicationOC;\n    }\n}\n/**\n * Issues a call to a given app.\n * @param call The call details.\n * @param algod An algod client\n * @returns The result of the call\n */\nasync function callApp(call, algod) {\n    const { appId, callType, from, args, note, transactionParams, ...sendParams } = call;\n    if (args && args.method) {\n        const atc = attachATC(sendParams);\n        const before = getAtomicTransactionComposerTransactions(atc);\n        atc.addMethodCall({\n            appID: toNumber(appId),\n            suggestedParams: controlFees(await getTransactionParams(transactionParams, algod), sendParams),\n            note: encodeTransactionNote(note),\n            onComplete: getAppOnCompleteAction(callType),\n            ...(await getAppArgsForABICall(args, from)),\n        });\n        if (sendParams.skipSending) {\n            const after = atc.clone().buildGroup();\n            return {\n                transaction: after[after.length - 1].txn,\n                transactions: after.slice(before.length).map((t) => t.txn),\n            };\n        }\n        const result = await sendAtomicTransactionComposer({ atc, sendParams }, algod);\n        const confirmation = result.confirmations ? result.confirmations[result.confirmations?.length - 1] : undefined;\n        return {\n            transactions: result.transactions,\n            confirmations: result.confirmations,\n            return: confirmation ? getABIReturn(args, confirmation) : undefined,\n            transaction: result.transactions[result.transactions.length - 1],\n            confirmation: confirmation,\n        };\n    }\n    const appCallParams = {\n        appIndex: toNumber(appId),\n        from: getSenderAddress(from),\n        suggestedParams: await getTransactionParams(transactionParams, algod),\n        ...getAppArgsForTransaction(args),\n        note: encodeTransactionNote(note),\n        rekeyTo: args?.rekeyTo ? (typeof args.rekeyTo === 'string' ? args.rekeyTo : getSenderAddress(args.rekeyTo)) : undefined,\n    };\n    let transaction;\n    switch (getAppOnCompleteAction(callType)) {\n        case OnApplicationComplete.OptInOC:\n            transaction = algosdk.makeApplicationOptInTxnFromObject(appCallParams);\n            break;\n        case OnApplicationComplete.ClearStateOC:\n            transaction = algosdk.makeApplicationClearStateTxnFromObject(appCallParams);\n            break;\n        case OnApplicationComplete.CloseOutOC:\n            transaction = algosdk.makeApplicationCloseOutTxnFromObject(appCallParams);\n            break;\n        case OnApplicationComplete.DeleteApplicationOC:\n            transaction = algosdk.makeApplicationDeleteTxnFromObject(appCallParams);\n            break;\n        case OnApplicationComplete.NoOpOC:\n            transaction = algosdk.makeApplicationNoOpTxnFromObject(appCallParams);\n            break;\n        default:\n            throw new Error(`Received unexpected call type ${callType}`);\n    }\n    const result = await sendTransaction({ transaction, from, sendParams }, algod);\n    return {\n        ...result,\n        transactions: [result.transaction],\n        confirmations: result.confirmation ? [result.confirmation] : undefined,\n        return: getABIReturn(args, result.confirmation),\n    };\n}\n/**\n * Returns any ABI return values for the given app call arguments and transaction confirmation.\n * @param args The arguments that were used for the call\n * @param confirmation The transaction confirmation from algod\n * @returns The return value for the method call\n */\nfunction getABIReturn(args, confirmation) {\n    if (!args || !args.method) {\n        return undefined;\n    }\n    const method = 'txnCount' in args.method ? args.method : new ABIMethod(args.method);\n    if (method.returns.type !== 'void' && confirmation) {\n        // The parseMethodResponse method mutates the second parameter :(\n        const resultDummy = {\n            txID: '',\n            method,\n            rawReturnValue: new Uint8Array(),\n        };\n        const response = AtomicTransactionComposer.parseMethodResponse(method, resultDummy, confirmation);\n        return !response.decodeError\n            ? {\n                rawReturnValue: response.rawReturnValue,\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                returnValue: response.returnValue,\n                decodeError: undefined,\n            }\n            : {\n                rawReturnValue: undefined,\n                returnValue: undefined,\n                decodeError: response.decodeError,\n            };\n    }\n    return undefined;\n}\n/**\n * Returns the current global state values for the given app ID\n * @param appId The ID of the app return global state for\n * @param algod An algod client instance\n * @returns The current global state\n */\nasync function getAppGlobalState(appId, algod) {\n    const appInfo = await getAppById(appId, algod);\n    if (!appInfo.params || !appInfo.params.globalState) {\n        throw new Error(\"Couldn't find global state\");\n    }\n    return decodeAppState(appInfo.params.globalState);\n}\n/**\n * Returns the current global state values for the given app ID and account\n * @param appId The ID of the app return global state for\n * @param account Either the string address of an account or an account object for the account to get local state for the given app\n * @param algod An algod client instance\n * @returns The current local state for the given (app, account) combination\n */\nasync function getAppLocalState(appId, account, algod) {\n    const accountAddress = typeof account === 'string' ? account : getSenderAddress(account);\n    const appInfo = modelsv2.AccountApplicationResponse.from_obj_for_encoding(await algod.accountApplicationInformation(accountAddress, toNumber(appId)).do());\n    if (!appInfo.appLocalState?.keyValue) {\n        throw new Error(\"Couldn't find local state\");\n    }\n    return decodeAppState(appInfo.appLocalState.keyValue);\n}\n/**\n * Returns the names of the boxes for the given app.\n * @param appId The ID of the app return box names for\n * @param algod An algod client instance\n * @returns The current box names\n */\nasync function getAppBoxNames(appId, algod) {\n    const boxResult = await algod.getApplicationBoxes(toNumber(appId)).do();\n    return boxResult.boxes.map((b) => {\n        return {\n            nameRaw: b.name,\n            nameBase64: Buffer.from(b.name).toString('base64'),\n            name: Buffer.from(b.name).toString('utf-8'),\n        };\n    });\n}\n/**\n * Returns the value of the given box name for the given app.\n * @param appId The ID of the app return box names for\n * @param boxName The name of the box to return either as a string, binary array or `BoxName`\n * @param algod An algod client instance\n * @returns The current box value as a byte array\n */\nasync function getAppBoxValue(appId, boxName, algod) {\n    const name = typeof boxName === 'string' ? new Uint8Array(Buffer.from(boxName, 'utf-8')) : 'name' in boxName ? boxName.nameRaw : boxName;\n    const boxResult = await algod.getApplicationBoxByName(toNumber(appId), name).do();\n    return boxResult.value;\n}\n/**\n * Returns the value of the given box names for the given app.\n * @param appId The ID of the app return box names for\n * @param boxNames The names of the boxes to return either as a string, binary array or `BoxName`\n * @param algod An algod client instance\n * @returns The current box values as a byte array in the same order as the passed in box names\n */\nasync function getAppBoxValues(appId, boxNames, algod) {\n    return await Promise.all(boxNames.map(async (boxName) => await getAppBoxValue(appId, boxName, algod)));\n}\n/**\n * Returns the value of the given box name for the given app decoded based on the given ABI type.\n * @param request The parameters for the box value request\n * @param algod An algod client instance\n * @returns The current box value as an ABI value\n */\nasync function getAppBoxValueFromABIType(request, algod) {\n    const { appId, boxName, type } = request;\n    const value = await getAppBoxValue(appId, boxName, algod);\n    return type.decode(value);\n}\n/**\n * Returns the value of the given box names for the given app decoded based on the given ABI type.\n * @param request The parameters for the box value request\n * @param algod An algod client instance\n * @returns The current box values as an ABI value in the same order as the passed in box names\n */\nasync function getAppBoxValuesFromABIType(request, algod) {\n    const { appId, boxNames, type } = request;\n    return await Promise.all(boxNames.map(async (boxName) => await getAppBoxValueFromABIType({ appId, boxName, type }, algod)));\n}\n/**\n * Converts an array of global/local state values from the algod api to a more friendly\n * generic object keyed by the UTF-8 value of the key.\n * @param state A `global-state`, `local-state`, `global-state-deltas` or `local-state-deltas`\n * @returns An object keyeed by the UTF-8 representation of the key with various parsings of the values\n */\nfunction decodeAppState(state) {\n    const stateValues = {};\n    // Start with empty set\n    for (const stateVal of state) {\n        const keyBase64 = stateVal.key;\n        const keyRaw = Buffer.from(keyBase64, 'base64');\n        const key = keyRaw.toString('utf-8');\n        const tealValue = stateVal.value;\n        const dataTypeFlag = 'action' in tealValue ? tealValue.action : tealValue.type;\n        let valueBase64;\n        let valueRaw;\n        switch (dataTypeFlag) {\n            case 1:\n                valueBase64 = tealValue.bytes ?? '';\n                valueRaw = Buffer.from(valueBase64, 'base64');\n                stateValues[key] = {\n                    keyRaw,\n                    keyBase64,\n                    valueRaw: new Uint8Array(valueRaw),\n                    valueBase64: valueBase64,\n                    value: valueRaw.toString('utf-8'),\n                };\n                break;\n            case 2: {\n                const value = tealValue.uint ?? 0;\n                stateValues[key] = {\n                    keyRaw,\n                    keyBase64,\n                    value,\n                };\n                break;\n            }\n            default:\n                throw new Error(`Received unknown state data type of ${dataTypeFlag}`);\n        }\n    }\n    return stateValues;\n}\n/**\n * Returns the app args ready to load onto an app `Transaction` object\n * @param args The app call args\n * @returns The args ready to load into a `Transaction`\n */\nfunction getAppArgsForTransaction(args) {\n    if (!args)\n        return undefined;\n    const encoder = new TextEncoder();\n    return {\n        accounts: args?.accounts?.map(_getAccountAddress),\n        appArgs: args?.appArgs?.map((a) => (typeof a === 'string' ? encoder.encode(a) : a)),\n        boxes: args.boxes?.map(getBoxReference),\n        foreignApps: args?.apps,\n        foreignAssets: args?.assets,\n        lease: encodeLease(args?.lease),\n    };\n}\n/**\n * Returns the app args ready to load onto an ABI method call in `AtomicTransactionComposer`\n * @param args The ABI app call args\n * @param from The transaction signer\n * @returns The parameters ready to pass into `addMethodCall` within AtomicTransactionComposer\n */\nasync function getAppArgsForABICall(args, from) {\n    const signer = getSenderTransactionSigner(from);\n    const methodArgs = await Promise.all(('methodArgs' in args ? args.methodArgs : args)?.map(async (a, index) => {\n        if (a === undefined) {\n            throw new Error(`Argument at position ${index} does not have a value`);\n        }\n        if (typeof a !== 'object') {\n            return a;\n        }\n        // Handle the various forms of transactions to wrangle them for ATC\n        return 'txn' in a\n            ? a\n            : a instanceof Promise\n                ? { txn: (await a).transaction, signer }\n                : 'transaction' in a\n                    ? { txn: a.transaction, signer: 'signer' in a ? getSenderTransactionSigner(a.signer) : signer }\n                    : 'txID' in a\n                        ? { txn: a, signer }\n                        : a;\n    }));\n    return {\n        method: 'txnCount' in args.method ? args.method : new ABIMethod(args.method),\n        sender: getSenderAddress(from),\n        signer: signer,\n        boxes: args.boxes?.map(getBoxReference),\n        lease: encodeLease(args.lease),\n        appForeignApps: args.apps,\n        appForeignAssets: args.assets,\n        appAccounts: args.accounts?.map(_getAccountAddress),\n        methodArgs: methodArgs,\n        rekeyTo: args?.rekeyTo ? (typeof args.rekeyTo === 'string' ? args.rekeyTo : getSenderAddress(args.rekeyTo)) : undefined,\n    };\n}\n/**\n * Returns a `algosdk.BoxReference` given a `BoxIdentifier` or `BoxReference`.\n * @param box The box to return a reference for\n * @returns The box reference ready to pass into a `Transaction`\n */\nfunction getBoxReference(box) {\n    const encoder = new TextEncoder();\n    if (typeof box === 'object' && 'appIndex' in box) {\n        return box;\n    }\n    const ref = typeof box === 'object' && 'appId' in box ? box : { appId: 0, name: box };\n    return {\n        appIndex: ref.appId,\n        name: typeof ref.name === 'string'\n            ? encoder.encode(ref.name)\n            : 'length' in ref.name\n                ? ref.name\n                : algosdk.decodeAddress(getSenderAddress(ref.name)).publicKey,\n    };\n}\nfunction _getAccountAddress(account) {\n    return typeof account === 'string' ? account : algosdk.encodeAddress(account.publicKey);\n}\n/**\n * Gets the current data for the given app from algod.\n *\n * @param appId The id of the app\n * @param algod An algod client\n * @returns The data about the app\n */\nasync function getAppById(appId, algod) {\n    return modelsv2.Application.from_obj_for_encoding(await algod.getApplicationByID(toNumber(appId)).do());\n}\n/**\n * Compiles the given TEAL using algod and returns the result, including source map.\n *\n * @param algod An algod client\n * @param tealCode The TEAL code\n * @returns The information about the compiled file\n */\nasync function compileTeal(tealCode, algod) {\n    const compiled = await algod.compile(tealCode).sourcemap(true).do();\n    return {\n        teal: tealCode,\n        compiled: compiled.result,\n        compiledHash: compiled.hash,\n        compiledBase64ToBytes: new Uint8Array(Buffer.from(compiled.result, 'base64')),\n        sourceMap: new SourceMap(compiled['sourcemap']),\n    };\n}\n/**\n * Returns the encoded ABI spec for a given ABI Method\n * @param method The method to return a signature for\n * @returns The encoded ABI method spec e.g. `method_name(uint64,string)string`\n */\nconst getABIMethodSignature = (method) => {\n    return 'getSignature' in method ? method.getSignature() : new ABIMethod(method).getSignature();\n};\n\nexport { callApp, compileTeal, createApp, decodeAppState, getABIMethodSignature, getABIReturn, getAppArgsForABICall, getAppArgsForTransaction, getAppBoxNames, getAppBoxValue, getAppBoxValueFromABIType, getAppBoxValues, getAppBoxValuesFromABIType, getAppById, getAppGlobalState, getAppLocalState, getAppOnCompleteAction, getBoxReference, updateApp };\n//# sourceMappingURL=app.mjs.map\n","const DEFAULT_INDEXER_MAX_API_RESOURCES_PER_ACCOUNT = 1000; //MaxAPIResourcesPerAccount: This is the default maximum, though may be provider specific\n/**\n * Looks up a transaction by ID using Indexer.\n * @param transactionId The ID of the transaction to look up\n * @param indexer An indexer client\n * @returns The result of the look-up\n */\nasync function lookupTransactionById(transactionId, indexer) {\n    return (await indexer.lookupTransactionByID(transactionId).do());\n}\n/**\n * Looks up an account by address using Indexer.\n * @param accountAddress The address of the account to look up\n * @param indexer An indexer client\n * @returns The result of the look-up\n */\nasync function lookupAccountByAddress(accountAddress, indexer) {\n    return (await indexer.lookupAccountByID(accountAddress).do());\n}\n/**\n * Looks up applications that were created by the given address; will automatically paginate through all data.\n * @param indexer An indexer instance\n * @param address The address of the creator to look up\n * @param getAll Whether or not to include deleted applications\n * @param paginationLimit The number of records to return per paginated request, default 1000\n * @returns The list of application results\n */\nasync function lookupAccountCreatedApplicationByAddress(indexer, address, getAll = undefined, paginationLimit) {\n    return await executePaginatedRequest((response) => {\n        if ('message' in response) {\n            throw { status: 404, ...response };\n        }\n        return response.applications;\n    }, (nextToken) => {\n        let s = indexer\n            .lookupAccountCreatedApplications(address)\n            .includeAll(getAll)\n            .limit(paginationLimit ?? DEFAULT_INDEXER_MAX_API_RESOURCES_PER_ACCOUNT);\n        if (nextToken) {\n            s = s.nextToken(nextToken);\n        }\n        return s;\n    });\n}\n/**\n * Looks up asset holdings for the given asset; will automatically paginate through all data.\n * @param indexer An indexer instance\n * @param assetId The ID of the asset to look up holdings for\n * @param options Optional options to control the lookup\n * @param paginationLimit The number of records to return per paginated request, default 1000\n * @returns The list of application results\n */\nasync function lookupAssetHoldings(indexer, assetId, options, paginationLimit) {\n    return await executePaginatedRequest((response) => {\n        if ('message' in response) {\n            throw { status: 404, ...response };\n        }\n        return response.balances;\n    }, (nextToken) => {\n        let s = indexer.lookupAssetBalances(Number(assetId)).limit(paginationLimit ?? DEFAULT_INDEXER_MAX_API_RESOURCES_PER_ACCOUNT);\n        if (options?.currencyGreaterThan !== undefined) {\n            s = s.currencyGreaterThan(options.currencyGreaterThan);\n        }\n        if (options?.currencyLessThan !== undefined) {\n            s = s.currencyLessThan(options.currencyLessThan);\n        }\n        if (options?.includeAll !== undefined) {\n            s = s.includeAll(options.includeAll);\n        }\n        if (nextToken) {\n            s = s.nextToken(nextToken);\n        }\n        return s;\n    });\n}\n/**\n * Allows transactions to be searched for the given criteria.\n * @param indexer An indexer client\n * @param searchCriteria The criteria to search for\n * @param paginationLimit The number of records to return per paginated request, default 1000\n * @returns The search results\n */\nasync function searchTransactions(indexer, searchCriteria, paginationLimit) {\n    let currentRound = 0;\n    const transactions = await executePaginatedRequest((response) => {\n        if ('message' in response) {\n            throw { status: 404, ...response };\n        }\n        if (response['current-round'] > currentRound) {\n            currentRound = response['current-round'];\n        }\n        return response.transactions;\n    }, (nextToken) => {\n        let s = searchCriteria(indexer.searchForTransactions()).limit(paginationLimit ?? DEFAULT_INDEXER_MAX_API_RESOURCES_PER_ACCOUNT);\n        if (nextToken) {\n            s = s.nextToken(nextToken);\n        }\n        return s;\n    });\n    return {\n        'current-round': currentRound,\n        'next-token': '',\n        transactions: transactions,\n    };\n}\n// https://developer.algorand.org/docs/get-details/indexer/#paginated-results\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function executePaginatedRequest(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nextractItems, buildRequest) {\n    const results = [];\n    let nextToken = undefined;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const request = buildRequest(nextToken);\n        const response = await request.do();\n        const items = extractItems(response);\n        if (items == null || items.length === 0) {\n            break;\n        }\n        results.push(...items);\n        nextToken = response['next-token'];\n        if (!nextToken) {\n            break;\n        }\n    }\n    return results;\n}\n\nexport { executePaginatedRequest, lookupAccountByAddress, lookupAccountCreatedApplicationByAddress, lookupAssetHoldings, lookupTransactionById, searchTransactions };\n//# sourceMappingURL=indexer-lookup.mjs.map\n","import algosdk from 'algosdk';\nimport { getAppById, compileTeal, createApp, callApp, updateApp } from './app.mjs';\nimport { Config } from './config.mjs';\nimport { lookupAccountCreatedApplicationByAddress, searchTransactions } from './indexer-lookup.mjs';\nimport { getSenderAddress, sendAtomicTransactionComposer } from './transaction/transaction.mjs';\nimport { OnSchemaBreak, OnUpdate, APP_DEPLOY_NOTE_DAPP, UPDATABLE_TEMPLATE_NAME, DELETABLE_TEMPLATE_NAME } from './types/app.mjs';\n\nvar AtomicTransactionComposer = algosdk.AtomicTransactionComposer;\nvar getApplicationAddress = algosdk.getApplicationAddress;\nvar modelsv2 = algosdk.modelsv2;\nvar TransactionType = algosdk.TransactionType;\n/**\n * Idempotently deploy (create, update/delete if changed) an app against the given name via the given creator account, including deploy-time template placeholder substitutions.\n *\n * To understand the architecture decisions behind this functionality please see https://github.com/algorandfoundation/algokit-cli/blob/main/docs/architecture-decisions/2023-01-12_smart-contract-deployment.md\n *\n * **Note:** When using the return from this function be sure to check `operationPerformed` to get access to various return properties like `transaction`, `confirmation` and `deleteResult`.\n *\n * **Note:** if there is a breaking state schema change to an existing app (and `onSchemaBreak` is set to `'replace'`) the existing app will be deleted and re-created.\n *\n * **Note:** if there is an update (different TEAL code) to an existing app (and `onUpdate` is set to `'replace'`) the existing app will be deleted and re-created.\n * @param deployment The arguments to control the app deployment\n * @param algod An algod client\n * @param indexer An indexer client, needed if `existingDeployments` not passed in\n * @returns The app reference of the new/existing app\n */\nasync function deployApp(deployment, algod, indexer) {\n    const { metadata, deployTimeParams: deployTimeParameters, onSchemaBreak, onUpdate, existingDeployments, createArgs, updateArgs, deleteArgs, createOnCompleteAction, ...appParams } = deployment;\n    if (existingDeployments && existingDeployments.creator !== getSenderAddress(appParams.from)) {\n        throw new Error(`Received invalid existingDeployments value for creator ${existingDeployments.creator} when attempting to deploy for creator ${appParams.from}`);\n    }\n    if (!existingDeployments && !indexer) {\n        throw new Error(`Didn't receive an indexer client, but also didn't receive an existingDeployments cache - one of them must be provided`);\n    }\n    Config.getLogger(appParams.suppressLog).info(`Idempotently deploying app \"${metadata.name}\" from creator ${getSenderAddress(appParams.from)} using ${appParams.approvalProgram.length} bytes of teal code and ${appParams.clearStateProgram.length} bytes of teal code`);\n    const compiledApproval = typeof appParams.approvalProgram === 'string'\n        ? await performTemplateSubstitutionAndCompile(appParams.approvalProgram, algod, deployTimeParameters, metadata)\n        : undefined;\n    appParams.approvalProgram = compiledApproval ? compiledApproval.compiledBase64ToBytes : appParams.approvalProgram;\n    const compiledClear = typeof appParams.clearStateProgram === 'string'\n        ? await performTemplateSubstitutionAndCompile(appParams.clearStateProgram, algod, deployTimeParameters)\n        : undefined;\n    appParams.clearStateProgram = compiledClear ? compiledClear.compiledBase64ToBytes : appParams.clearStateProgram;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const apps = existingDeployments ?? (await getCreatorAppsByName(appParams.from, indexer));\n    const create = async (atc) => {\n        const result = await createApp({\n            ...appParams,\n            onCompleteAction: createOnCompleteAction,\n            args: createArgs,\n            note: getAppDeploymentTransactionNote(metadata),\n            atc,\n            skipWaiting: false,\n        }, algod);\n        return {\n            transaction: result.transaction,\n            transactions: result.transactions,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            confirmation: result.confirmation,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            confirmations: result.confirmations,\n            return: result.return,\n            appId: result.appId,\n            appAddress: result.appAddress,\n            createdMetadata: metadata,\n            createdRound: Number(result.confirmation?.confirmedRound),\n            updatedRound: Number(result.confirmation?.confirmedRound),\n            ...metadata,\n            deleted: false,\n            operationPerformed: 'create',\n            compiledApproval,\n            compiledClear,\n        };\n    };\n    const existingApp = apps.apps[metadata.name];\n    if (!existingApp || existingApp.deleted) {\n        Config.getLogger(appParams.suppressLog).info(`App ${metadata.name} not found in apps created by ${getSenderAddress(appParams.from)}; deploying app with version ${metadata.version}.`);\n        return await create();\n    }\n    Config.getLogger(appParams.suppressLog).info(`Existing app ${metadata.name} found by creator ${getSenderAddress(appParams.from)}, with app id ${existingApp.appId} and version ${existingApp.version}.`);\n    const existingAppRecord = await getAppById(existingApp.appId, algod);\n    const existingApproval = Buffer.from(existingAppRecord.params.approvalProgram).toString('base64');\n    const existingClear = Buffer.from(existingAppRecord.params.clearStateProgram).toString('base64');\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const existingGlobalSchema = existingAppRecord.params.globalStateSchema;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const existingLocalSchema = existingAppRecord.params.localStateSchema;\n    const newGlobalSchema = new modelsv2.ApplicationStateSchema({\n        numByteSlice: appParams.schema.globalByteSlices,\n        numUint: appParams.schema.globalInts,\n    });\n    const newLocalSchema = new modelsv2.ApplicationStateSchema({\n        numByteSlice: appParams.schema.localByteSlices,\n        numUint: appParams.schema.localInts,\n    });\n    const newApproval = Buffer.from(appParams.approvalProgram).toString('base64');\n    const newClear = Buffer.from(appParams.clearStateProgram).toString('base64');\n    const isUpdate = newApproval !== existingApproval || newClear !== existingClear;\n    const isSchemaBreak = isSchemaIsBroken(existingGlobalSchema, newGlobalSchema) || isSchemaIsBroken(existingLocalSchema, newLocalSchema);\n    const replace = async () => {\n        const atc = new AtomicTransactionComposer();\n        // Create\n        Config.getLogger(appParams.suppressLog).info(`Deploying a new ${metadata.name} app for ${getSenderAddress(appParams.from)}; deploying app with version ${metadata.version}.`);\n        const { transaction: createTransaction } = await create(atc);\n        const createTransactions = atc.clone().buildGroup();\n        // Delete\n        Config.getLogger(appParams.suppressLog).warn(`Deleting existing ${metadata.name} app with id ${existingApp.appId} from ${getSenderAddress(appParams.from)} account.`);\n        const { transaction: deleteTransaction } = await callApp({\n            appId: existingApp.appId,\n            callType: 'delete_application',\n            from: appParams.from,\n            args: deleteArgs,\n            transactionParams: appParams.transactionParams,\n            suppressLog: appParams.suppressLog,\n            skipSending: true,\n            atc,\n        }, algod);\n        // Ensure create and delete happen atomically\n        const { transactions, confirmations, returns } = await sendAtomicTransactionComposer({\n            atc,\n            sendParams: {\n                maxRoundsToWaitForConfirmation: appParams.maxRoundsToWaitForConfirmation,\n                skipWaiting: false,\n                suppressLog: true,\n            },\n        }, algod);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const createConfirmation = confirmations[createTransactions.length - 1];\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const deleteConfirmation = confirmations[confirmations.length - 1];\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const newAppIndex = createConfirmation.applicationIndex;\n        Config.getLogger(appParams.suppressLog).warn(`Sent transactions ${createTransaction.txID()} to create app with id ${newAppIndex} and ${deleteTransaction.txID()} to delete app with id ${existingApp.appId} from ${getSenderAddress(appParams.from)} account.`);\n        return {\n            transaction: createTransaction,\n            transactions: transactions,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            confirmation: createConfirmation,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            confirmations: confirmations,\n            return: returns?.[0],\n            deleteReturn: returns?.[1],\n            appId: newAppIndex,\n            appAddress: getApplicationAddress(newAppIndex),\n            createdMetadata: metadata,\n            createdRound: Number(createConfirmation.confirmedRound),\n            updatedRound: Number(createConfirmation.confirmedRound),\n            ...metadata,\n            deleted: false,\n            deleteResult: { transaction: deleteTransaction, confirmation: deleteConfirmation },\n            operationPerformed: 'replace',\n            compiledApproval,\n            compiledClear,\n        };\n    };\n    const update = async () => {\n        Config.getLogger(appParams.suppressLog).info(`Updating existing ${metadata.name} app for ${getSenderAddress(appParams.from)} to version ${metadata.version}.`);\n        const result = await updateApp({\n            appId: existingApp.appId,\n            from: appParams.from,\n            args: updateArgs,\n            note: getAppDeploymentTransactionNote(metadata),\n            approvalProgram: appParams.approvalProgram,\n            clearStateProgram: appParams.clearStateProgram,\n            transactionParams: appParams.transactionParams,\n            suppressLog: appParams.suppressLog,\n            skipSending: false,\n            skipWaiting: false,\n        }, algod);\n        return {\n            transaction: result.transaction,\n            transactions: result.transactions,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            confirmation: result.confirmation,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            confirmations: result.confirmations,\n            return: result.return,\n            appId: existingApp.appId,\n            appAddress: existingApp.appAddress,\n            createdMetadata: existingApp.createdMetadata,\n            createdRound: existingApp.createdRound,\n            updatedRound: Number(result.confirmation?.confirmedRound),\n            ...metadata,\n            deleted: false,\n            operationPerformed: 'update',\n            compiledApproval,\n            compiledClear,\n        };\n    };\n    if (isSchemaBreak) {\n        Config.getLogger(appParams.suppressLog).warn(`Detected a breaking app schema change in app ${existingApp.appId}:`, {\n            from: {\n                global: existingGlobalSchema,\n                local: existingLocalSchema,\n            },\n            to: {\n                global: newGlobalSchema,\n                local: newLocalSchema,\n            },\n        });\n        if (onSchemaBreak === undefined || onSchemaBreak === 'fail' || onSchemaBreak === OnSchemaBreak.Fail) {\n            throw new Error('Schema break detected and onSchemaBreak=OnSchemaBreak.Fail, stopping deployment. ' +\n                'If you want to try deleting and recreating the app then ' +\n                're-run with onSchemaBreak=OnSchemaBreak.ReplaceApp');\n        }\n        if (onSchemaBreak === 'append' || onSchemaBreak === OnSchemaBreak.AppendApp) {\n            Config.getLogger(appParams.suppressLog).info('onSchemaBreak=AppendApp, will attempt to create a new app');\n            return await create();\n        }\n        if (existingApp.deletable) {\n            Config.getLogger(appParams.suppressLog).info('App is deletable and onSchemaBreak=ReplaceApp, will attempt to create new app and delete old app');\n        }\n        else {\n            Config.getLogger(appParams.suppressLog).info('App is not deletable but onSchemaBreak=ReplaceApp, will attempt to delete app, delete will most likely fail');\n        }\n        return await replace();\n    }\n    if (isUpdate) {\n        Config.getLogger(appParams.suppressLog).info(`Detected a TEAL update in app ${existingApp.appId} for creator ${getSenderAddress(appParams.from)}`);\n        if (onUpdate === undefined || onUpdate === 'fail' || onUpdate === OnUpdate.Fail) {\n            throw new Error('Update detected and onUpdate=Fail, stopping deployment. ' +\n                'If you want to try deleting and recreating the app then ' +\n                're-run with onUpdate=UpdateApp');\n        }\n        if (onUpdate === 'append' || onUpdate === OnUpdate.AppendApp) {\n            Config.getLogger(appParams.suppressLog).info('onUpdate=AppendApp, will attempt to create a new app');\n            return await create();\n        }\n        if (onUpdate === 'update' || onUpdate === OnUpdate.UpdateApp) {\n            if (existingApp.updatable) {\n                Config.getLogger(appParams.suppressLog).info(`App is updatable and onUpdate=UpdateApp, updating app...`);\n            }\n            else {\n                Config.getLogger(appParams.suppressLog).warn(`App is not updatable but onUpdate=UpdateApp, will attempt to update app, update will most likely fail`);\n            }\n            return await update();\n        }\n        if (onUpdate === 'replace' || onUpdate === OnUpdate.ReplaceApp) {\n            if (existingApp.deletable) {\n                Config.getLogger(appParams.suppressLog).warn('App is deletable and onUpdate=ReplaceApp, creating new app and deleting old app...');\n            }\n            else {\n                Config.getLogger(appParams.suppressLog).warn('App is not deletable and onUpdate=ReplaceApp, will attempt to create new app and delete old app, delete will most likely fail');\n            }\n            return await replace();\n        }\n    }\n    Config.getLogger(appParams.suppressLog).debug('No detected changes in app, nothing to do.');\n    return { ...existingApp, operationPerformed: 'nothing', compiledApproval, compiledClear };\n}\n/** Returns true is there is a breaking change in the application state schema from before to after.\n *  i.e. if the schema becomes larger, since applications can't ask for more schema after creation.\n *  Otherwise, there is no error, the app just doesn't store data in the extra schema :(\n *\n * @param before The existing schema\n * @param after The new schema\n * @returns Whether or not there is a breaking change\n */\nfunction isSchemaIsBroken(before, after) {\n    return before.numByteSlice < after.numByteSlice || before.numUint < after.numUint;\n}\n/**\n * Returns a lookup of name => app metadata (id, address, ...metadata) for all apps created by the given account that have an `AppDeployNote` in the transaction note of the creation transaction.\n *\n * **Note:** It's recommended this is only called once and then stored since it's a somewhat expensive operation (multiple indexer calls).\n *\n * @param creatorAccount The account (with private key loaded) or string address of an account that is the creator of the apps you want to search for\n * @param indexer An indexer client\n * @returns A name-based lookup of the app information (id, address)\n */\nasync function getCreatorAppsByName(creatorAccount, indexer) {\n    const appLookup = {};\n    const creatorAddress = typeof creatorAccount !== 'string' ? getSenderAddress(creatorAccount) : creatorAccount;\n    // Extract all apps that account created\n    const createdApps = (await lookupAccountCreatedApplicationByAddress(indexer, creatorAddress))\n        .map((a) => {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return { id: a.id, createdAtRound: a['created-at-round'], deleted: a.deleted };\n    })\n        .sort((a, b) => a.createdAtRound - b.createdAtRound);\n    // For each app that account created (in parallel)...\n    const apps = await Promise.all(createdApps.map(async (createdApp) => {\n        // Find any app transactions for that app in the round it was created (should always just be a single creation transaction)\n        const appTransactions = await searchTransactions(indexer, (s) => s\n            .minRound(createdApp.createdAtRound)\n            .txType(TransactionType.appl)\n            .applicationID(createdApp.id)\n            .address(creatorAddress)\n            .addressRole('sender')\n            .notePrefix(Buffer.from(APP_DEPLOY_NOTE_DAPP).toString('base64')));\n        // Triple check the transaction is intact by filtering for the one we want:\n        //  * application-id is 0 when the app is first created\n        //  * also verify the sender to prevent a potential security risk\n        const appCreationTransaction = appTransactions.transactions.filter(\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        (t) => t['application-transaction']['application-id'] === 0 && t.sender === creatorAddress)[0];\n        const latestAppUpdateTransaction = appTransactions.transactions\n            .filter((t) => t.sender === creatorAddress)\n            .sort((a, b) => a['confirmed-round'] === b['confirmed-round']\n            ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                (b['intra-round-offset'] - a['intra-round-offset']) / 10\n            : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                b['confirmed-round'] - a['confirmed-round'])[0];\n        if (!appCreationTransaction?.note)\n            // No note; ignoring\n            return null;\n        return { createdApp, appCreationTransaction, latestAppUpdateTransaction };\n    }));\n    apps\n        .filter((a) => a !== null)\n        .forEach((a) => {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const { createdApp, appCreationTransaction, latestAppUpdateTransaction } = a;\n        const parseNote = (note) => {\n            if (!note) {\n                // No note; ignoring...\n                return;\n            }\n            const decoder = new TextDecoder();\n            const noteAsBase64 = decoder.decode(Buffer.from(note));\n            const noteAsString = Buffer.from(noteAsBase64, 'base64').toString('utf-8');\n            if (!noteAsString.startsWith(`${APP_DEPLOY_NOTE_DAPP}:j{`))\n                // Clearly not APP_DEPLOY JSON; ignoring...\n                return;\n            return JSON.parse(noteAsString.substring(APP_DEPLOY_NOTE_DAPP.length + 2));\n        };\n        try {\n            const creationNote = parseNote(appCreationTransaction.note);\n            const updateNote = parseNote(latestAppUpdateTransaction.note);\n            if (creationNote?.name) {\n                appLookup[creationNote.name] = {\n                    appId: createdApp.id,\n                    appAddress: getApplicationAddress(createdApp.id),\n                    createdMetadata: creationNote,\n                    createdRound: Number(appCreationTransaction['confirmed-round']),\n                    ...(updateNote ?? creationNote),\n                    updatedRound: Number(latestAppUpdateTransaction?.['confirmed-round']),\n                    deleted: createdApp.deleted ?? false,\n                };\n            }\n        }\n        catch (e) {\n            Config.logger.warn(`Received error trying to retrieve app with ${createdApp.id} for creator ${creatorAddress}; failing silently`, e);\n            return;\n        }\n    });\n    return {\n        creator: creatorAddress,\n        apps: appLookup,\n    };\n}\n/**\n * Return the transaction note for an app deployment.\n * @param metadata The metadata of the deployment\n * @returns The transaction note as a utf-8 string\n */\nfunction getAppDeploymentTransactionNote(metadata) {\n    return {\n        dAppName: APP_DEPLOY_NOTE_DAPP,\n        data: metadata,\n        format: 'j',\n    };\n}\n/**\n * Replaces deploy-time deployment control parameters within the given teal code.\n *\n * * `TMPL_UPDATABLE` for updatability / immutability control\n * * `TMPL_DELETABLE` for deletability / permanence control\n *\n * Note: If these values are not undefined, but the corresponding `TMPL_*` value\n *  isn't in the teal code it will throw an exception.\n *\n * @param tealCode The TEAL code to substitute\n * @param params The deploy-time deployment control parameter value to replace\n * @returns The replaced TEAL code\n */\nfunction replaceDeployTimeControlParams(tealCode, params) {\n    if (params.updatable !== undefined) {\n        if (!tealCode.includes(UPDATABLE_TEMPLATE_NAME)) {\n            throw new Error(`Deploy-time updatability control requested for app deployment, but ${UPDATABLE_TEMPLATE_NAME} not present in TEAL code`);\n        }\n        tealCode = tealCode.replace(new RegExp(UPDATABLE_TEMPLATE_NAME, 'g'), (params.updatable ? 1 : 0).toString());\n    }\n    if (params.deletable !== undefined) {\n        if (!tealCode.includes(DELETABLE_TEMPLATE_NAME)) {\n            throw new Error(`Deploy-time deletability control requested for app deployment, but ${DELETABLE_TEMPLATE_NAME} not present in TEAL code`);\n        }\n        tealCode = tealCode.replace(new RegExp(DELETABLE_TEMPLATE_NAME, 'g'), (params.deletable ? 1 : 0).toString());\n    }\n    return tealCode;\n}\n/**\n * Performs template substitution of a teal file.\n *\n * Looks for `TMPL_{parameter}` for template replacements.\n *\n * @param tealCode The TEAL logic to compile\n * @param templateParams Any parameters to replace in the .teal file before compiling\n * @returns The TEAL code with replacements\n */\nfunction performTemplateSubstitution(tealCode, templateParams) {\n    if (templateParams !== undefined) {\n        for (const key in templateParams) {\n            const value = templateParams[key];\n            const token = `TMPL_${key.replace(/^TMPL_/, '')}`;\n            tealCode = tealCode.replace(new RegExp(token, 'g'), typeof value === 'string'\n                ? `0x${Buffer.from(value, 'utf-8').toString('hex')}`\n                : ArrayBuffer.isView(value)\n                    ? `0x${Buffer.from(value).toString('hex')}`\n                    : value.toString());\n        }\n    }\n    return tealCode;\n}\n/**\n * Performs template substitution of a teal file and compiles it, returning the compiled result.\n *\n * Looks for `TMPL_{parameter}` for template replacements.\n *\n * @param tealCode The TEAL logic to compile\n * @param algod An algod client\n * @param templateParams Any parameters to replace in the .teal file before compiling\n * @param deploymentMetadata The deployment metadata the app will be deployed with\n * @returns The information about the compiled code\n */\nasync function performTemplateSubstitutionAndCompile(tealCode, algod, templateParams, deploymentMetadata) {\n    tealCode = stripTealComments(tealCode);\n    tealCode = performTemplateSubstitution(tealCode, templateParams);\n    if (deploymentMetadata) {\n        tealCode = replaceDeployTimeControlParams(tealCode, deploymentMetadata);\n    }\n    return await compileTeal(tealCode, algod);\n}\n/**\n * Remove comments from TEAL Code\n *\n * @param tealCode The TEAL logic to compile\n * @returns The TEAL without comments\n */\nfunction stripTealComments(tealCode) {\n    // find // outside quotes, i.e. won't pick up \"//not a comment\"\n    const regex = /\\/\\/(?=([^\"\\\\]*(\\\\.|\"([^\"\\\\]*\\\\.)*[^\"\\\\]*\"))*[^\"]*$)/;\n    tealCode = tealCode\n        .split('\\n')\n        .map((tealCodeLine) => {\n        return tealCodeLine.split(regex)[0].trim();\n    })\n        .join('\\n');\n    return tealCode;\n}\n\nexport { deployApp, getAppDeploymentTransactionNote, getCreatorAppsByName, isSchemaIsBroken, performTemplateSubstitution, performTemplateSubstitutionAndCompile, replaceDeployTimeControlParams, stripTealComments };\n//# sourceMappingURL=app-deploy.mjs.map\n","/**\n * AVM debugger source map entry class.\n */\nclass AVMDebuggerSourceMapEntry {\n    /**\n     * Create an AVM debugger source map entry.\n     * @param location The location of the file the source map is for.\n     * @param programHash The hash of the TEAL binary.\n     */\n    constructor(location, programHash) {\n        this.location = location;\n        this.programHash = programHash;\n    }\n    equals(other) {\n        return this.location === other.location && this.programHash === other.programHash;\n    }\n    toString() {\n        return JSON.stringify({ 'sourcemap-location': this.location, hash: this.programHash });\n    }\n}\n/**\n * AVM debugger source map class.\n */\nclass AVMDebuggerSourceMap {\n    /**\n     *\n     * @param txnGroupSources\n     */\n    constructor(txnGroupSources) {\n        this.txnGroupSources = txnGroupSources;\n    }\n    /**\n     * Creates a source map from a dictionary of source map data.\n     * @param data The data\n     * @returns The source map\n     */\n    static fromDict(data) {\n        return new AVMDebuggerSourceMap(data['txn-group-sources'].map((item) => new AVMDebuggerSourceMapEntry(item['sourcemap-location'], item['hash'])));\n    }\n    /**\n     * Converts the source map to a dictionary that can be passed around and then parsed back using `AVMDebuggerSourceMap.fromDict`.\n     * @returns The dictionary\n     */\n    toDict() {\n        return { 'txn-group-sources': this.txnGroupSources.map((item) => JSON.parse(item.toString())) };\n    }\n}\n/**\n * Class representing a debugger source maps input for persistence.\n *\n * Note: rawTeal and compiledTeal are mutually exclusive. Only one of them should be provided.\n */\nclass PersistSourceMapInput {\n    constructor(appName, fileName, rawTeal, compiledTeal) {\n        this.compiledTeal = compiledTeal;\n        this.appName = appName;\n        this._rawTeal = rawTeal;\n        this._fileName = this.stripTealExtension(fileName);\n    }\n    /**\n     * Returns debugger source maps input from raw TEAL code.\n     * @param rawTeal The raw TEAL code\n     * @param appName The name of the app\n     * @param fileName The name of the file to persist to\n     * @returns The persist source map input\n     */\n    static fromRawTeal(rawTeal, appName, fileName) {\n        return new PersistSourceMapInput(appName, fileName, rawTeal);\n    }\n    /**\n     * Returns debugger source maps input from compiled TEAL code.\n     * @param compiledTeal The compiled TEAL code\n     * @param appName The name of the app\n     * @param fileName The name of the file to persist to\n     * @returns The persist source map input\n     */\n    static fromCompiledTeal(compiledTeal, appName, fileName) {\n        return new PersistSourceMapInput(appName, fileName, undefined, compiledTeal);\n    }\n    /** Get the underlying raw teal */\n    get rawTeal() {\n        if (this._rawTeal) {\n            return this._rawTeal;\n        }\n        else if (this.compiledTeal) {\n            return this.compiledTeal.teal;\n        }\n        else {\n            throw new Error('No teal content found');\n        }\n    }\n    /** Get the file name */\n    get fileName() {\n        return this._fileName;\n    }\n    /**\n     * Strips the '.teal' extension from a filename, if present.\n     *\n     * @param fileName - The filename to strip the extension from.\n     * @returns The filename without the '.teal' extension.\n     */\n    stripTealExtension(fileName) {\n        if (fileName.endsWith('.teal')) {\n            return fileName.slice(0, -5);\n        }\n        return fileName;\n    }\n}\n\nexport { AVMDebuggerSourceMap, AVMDebuggerSourceMapEntry, PersistSourceMapInput };\n//# sourceMappingURL=debugging.mjs.map\n","import * as crypto from 'crypto';\nimport { compileTeal } from '../app.mjs';\nimport { Config } from '../config.mjs';\nimport { AVMDebuggerSourceMapEntry, AVMDebuggerSourceMap } from '../types/debugging.mjs';\nimport { isNode } from '../util.mjs';\n\nconst ALGOKIT_DIR = '.algokit';\nconst SOURCES_DIR = 'sources';\nconst SOURCES_FILE = 'sources.avm.json';\nconst TEAL_FILE_EXT = '.teal';\nconst TEAL_SOURCEMAP_EXT = '.teal.tok.map';\n// === Internal methods ===\nasync function loadOrCreateSources(sourcesPath) {\n    try {\n        const fs = await import('fs');\n        const data = JSON.parse(await fs.promises.readFile(sourcesPath, 'utf8'));\n        return AVMDebuggerSourceMap.fromDict(data);\n    }\n    catch (error) {\n        const err = error;\n        if (err.code === 'ENOENT') {\n            return new AVMDebuggerSourceMap([]);\n        }\n        else {\n            throw error;\n        }\n    }\n}\nasync function upsertDebugSourcemaps(sourceMaps, projectRoot) {\n    const path = await import('path');\n    const fs = await import('fs');\n    const sourcesPath = path.join(projectRoot, ALGOKIT_DIR, SOURCES_DIR, SOURCES_FILE);\n    const sources = await loadOrCreateSources(sourcesPath);\n    for (const sourcemap of sourceMaps) {\n        const sourceFilePath = path.resolve(sourcemap.location);\n        try {\n            await fs.promises.access(sourceFilePath);\n            const index = sources.txnGroupSources.findIndex((item) => item.equals(sourcemap));\n            if (index === -1) {\n                sources.txnGroupSources.push(sourcemap);\n            }\n            else {\n                sources.txnGroupSources[index] = sourcemap;\n            }\n        }\n        catch (error) {\n            const err = error;\n            if (err.code === 'ENOENT') {\n                const index = sources.txnGroupSources.findIndex((item) => item.equals(sourcemap));\n                if (index !== -1) {\n                    sources.txnGroupSources.splice(index, 1);\n                }\n            }\n            else {\n                throw error;\n            }\n        }\n    }\n    await fs.promises.writeFile(sourcesPath, JSON.stringify(sources.toDict()), 'utf8');\n}\nasync function writeToFile(filePath, content) {\n    const path = await import('path');\n    const fs = await import('fs');\n    await fs.promises.mkdir(path.dirname(filePath), { recursive: true });\n    await fs.promises.writeFile(filePath, content, 'utf8');\n}\nasync function buildAVMSourcemap({ rawTeal, compiledTeal, appName, fileName, outputPath, client, withSources = true, }) {\n    if (!rawTeal && !compiledTeal) {\n        throw new Error('Either rawTeal or compiledTeal must be provided.');\n    }\n    const path = await import('path');\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const result = rawTeal ? await compileTeal(rawTeal, client) : compiledTeal;\n    const programHash = crypto.createHash('SHA-512/256').update(Buffer.from(result.compiled, 'base64')).digest('base64');\n    const sourceMap = result.sourceMap;\n    sourceMap.sources = withSources ? [`${fileName}${TEAL_FILE_EXT}`] : [];\n    const outputDirPath = path.join(outputPath, ALGOKIT_DIR, SOURCES_DIR, appName);\n    const sourceMapOutputPath = path.join(outputDirPath, `${fileName}${TEAL_SOURCEMAP_EXT}`);\n    const tealOutputPath = path.join(outputDirPath, `${fileName}${TEAL_FILE_EXT}`);\n    await writeToFile(sourceMapOutputPath, JSON.stringify(sourceMap));\n    if (withSources && result) {\n        await writeToFile(tealOutputPath, result.teal);\n    }\n    return new AVMDebuggerSourceMapEntry(sourceMapOutputPath, programHash);\n}\n// === Public facing methods ===\n/**\n * This function persists the source maps for the given sources.\n *\n * @param param0 The parameters to define the persistence\n *\n * @returns A promise that resolves when the source maps have been persisted.\n */\nasync function persistSourceMaps({ sources, projectRoot, client, withSources }) {\n    if (!isNode()) {\n        throw new Error('Sourcemaps can only be persisted in Node.js environment.');\n    }\n    try {\n        const sourceMaps = await Promise.all(sources.map((source) => buildAVMSourcemap({\n            rawTeal: source.rawTeal,\n            compiledTeal: source.compiledTeal,\n            appName: source.appName,\n            fileName: source.fileName,\n            outputPath: projectRoot,\n            client: client,\n            withSources: withSources,\n        })));\n        await upsertDebugSourcemaps(sourceMaps, projectRoot);\n    }\n    catch (error) {\n        const err = error instanceof Error ? error : new Error(String(error));\n        Config.getLogger().error(`Failed to persist avm sourceMaps: ${err.stack ?? err.message ?? err}.`);\n        throw err;\n    }\n}\n\nexport { persistSourceMaps };\n//# sourceMappingURL=debugging.mjs.map\n","import algosdk from 'algosdk';\nimport { Config } from '../config.mjs';\nimport { getSenderAddress, encodeTransactionNote, getTransactionParams, encodeLease, sendTransaction } from '../transaction/transaction.mjs';\n\n/**\n * Transfer ALGOs between two accounts.\n * @param transfer The transfer definition\n * @param algod An algod client\n * @returns The transaction object and optionally the confirmation if it was sent to the chain (`skipSending` is `false` or unset)\n *\n * @example Usage example\n * ```typescript\n * await algokit.transferAlgos({ from, to, amount: algokit.algos(1) }, algod)\n * ```\n */\nasync function transferAlgos(transfer, algod) {\n    const { from, to, amount, note, transactionParams, lease, ...sendParams } = transfer;\n    const transaction = algosdk.makePaymentTxnWithSuggestedParamsFromObject({\n        from: getSenderAddress(from),\n        to: getSenderAddress(to),\n        amount: amount.microAlgos,\n        note: encodeTransactionNote(note),\n        suggestedParams: await getTransactionParams(transactionParams, algod),\n        closeRemainderTo: undefined,\n        rekeyTo: undefined,\n    });\n    const encodedLease = encodeLease(lease);\n    if (encodedLease) {\n        transaction.addLease(encodedLease);\n    }\n    if (!sendParams.skipSending) {\n        Config.getLogger(sendParams.suppressLog).debug(`Transferring ${amount.microAlgos}ALGOs from ${getSenderAddress(from)} to ${getSenderAddress(to)}`);\n    }\n    return sendTransaction({ transaction, from, sendParams }, algod);\n}\n\nexport { transferAlgos };\n//# sourceMappingURL=transfer-algos.mjs.map\n","const LOGIC_ERROR = /transaction ([A-Z0-9]+): logic eval error: (.*). Details: .*pc=([0-9]+).*/;\n/** Wraps key functionality around processing logic errors */\nclass LogicError extends Error {\n    /** Takes an error message and parses out the details of any logic errors in there.\n     * @param error The error message to parse\n     * @returns The logic error details if any, or undefined\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static parseLogicError(error) {\n        const errorMessage = error.message;\n        const res = LOGIC_ERROR.exec(errorMessage);\n        if (res === null || res.length <= 3)\n            return undefined;\n        return {\n            txId: res[1],\n            msg: res[2],\n            desc: errorMessage,\n            pc: parseInt(res[3] ? res[3] : '0'),\n            traces: error.traces,\n        };\n    }\n    /**\n     * Create a new logic error object.\n     * @param errorDetails The details of the logic error\n     * @param program The TEAL source code, split by line\n     * @param map The source map of the TEAL source code\n     */\n    constructor(errorDetails, program, map) {\n        super();\n        this.lines = 5;\n        this.teal_line = 0;\n        this.led = errorDetails;\n        this.program = program;\n        const line = map.getLineForPc(errorDetails.pc);\n        this.teal_line = line === undefined ? 0 : line;\n        this.message = `${this.led.msg}. at:${line}. ${this.led.desc}`;\n        if (this.teal_line > 0) {\n            const start = this.teal_line > this.lines ? this.teal_line - this.lines : 0;\n            const stop = program.length > this.teal_line + this.lines ? this.teal_line + this.lines : program.length;\n            const stack_lines = program.slice(start, stop);\n            stack_lines[stack_lines.length / 2] += ' <--- Error';\n            this.stack = stack_lines.join('\\n');\n        }\n    }\n}\n\nexport { LogicError };\n//# sourceMappingURL=logic-error.mjs.map\n","import algosdk from 'algosdk';\nimport { Buffer } from 'buffer';\nimport { compileTeal, createApp, updateApp, getABIMethodSignature, callApp, getAppGlobalState, getAppLocalState, getAppBoxNames, getAppBoxValue, getAppBoxValueFromABIType } from '../app.mjs';\nimport { replaceDeployTimeControlParams, performTemplateSubstitution, deployApp, getCreatorAppsByName } from '../app-deploy.mjs';\nimport { Config } from '../config.mjs';\nimport { persistSourceMaps } from '../debugging/debugging.mjs';\nimport { getSenderAddress } from '../transaction/transaction.mjs';\nimport { transferAlgos } from '../transfer/transfer-algos.mjs';\nimport { UPDATABLE_TEMPLATE_NAME, DELETABLE_TEMPLATE_NAME } from './app.mjs';\nimport { PersistSourceMapInput } from './debugging.mjs';\nimport { LogicError } from './logic-error.mjs';\n\nvar ABIMethod = algosdk.ABIMethod;\nvar AtomicTransactionComposer = algosdk.AtomicTransactionComposer;\nvar getApplicationAddress = algosdk.getApplicationAddress;\nvar Indexer = algosdk.Indexer;\nvar SourceMap = algosdk.SourceMap;\n/**\n * Determines deploy time control (UPDATABLE, DELETABLE) value by inspecting application specification\n * @param approval TEAL Approval program, not the base64 version found on the appSpec\n * @param appSpec Application Specification\n * @param templateVariableName Template variable\n * @param callConfigKey Call config type\n * @returns true if applicable call config is found, false if not found or undefined if variable not present\n */\nfunction getDeployTimeControl(approval, appSpec, templateVariableName, callConfigKey) {\n    // variable not present, so unknown control value\n    if (!approval.includes(templateVariableName))\n        return undefined;\n    // a bare call for specified CallConfig is present and configured\n    const bareCallConfig = appSpec.bare_call_config[callConfigKey];\n    if (!!bareCallConfig && bareCallConfig !== 'NEVER')\n        return true;\n    // an ABI call for specified CallConfig is present and configured\n    return Object.values(appSpec.hints).some((h) => {\n        const abiCallConfig = h.call_config[callConfigKey];\n        return !!abiCallConfig && abiCallConfig !== 'NEVER';\n    });\n}\n/** Application client - a class that wraps an ARC-0032 app spec and provides high productivity methods to deploy and call the app */\nclass ApplicationClient {\n    // todo: process ABI args as needed to make them nicer to deal with like beaker-ts\n    // todo: support readonly, noop method calls\n    // todo: find create, update, delete, etc. methods from app spec and call them by default\n    // todo: intelligent version management when deploying\n    /**\n     * Create a new ApplicationClient instance\n     * @param appDetails The details of the app\n     * @param algod An algod instance\n     */\n    constructor(appDetails, algod) {\n        const { app, sender, params, deployTimeParams, ...appIdentifier } = appDetails;\n        this.algod = algod;\n        this.appSpec = typeof app == 'string' ? JSON.parse(app) : app;\n        this._appName = appIdentifier.name ?? this.appSpec.contract.name;\n        this.deployTimeParams = deployTimeParams;\n        if (appIdentifier.resolveBy === 'id') {\n            if (appIdentifier.id < 0) {\n                throw new Error(`Attempt to create application client with invalid app id of ${appIdentifier.id}`);\n            }\n            this._appId = appIdentifier.id;\n        }\n        else {\n            this._appId = 0;\n            this._creator = appIdentifier.creatorAddress;\n            if (appIdentifier.findExistingUsing instanceof Indexer) {\n                this.indexer = appIdentifier.findExistingUsing;\n            }\n            else {\n                if (appIdentifier.findExistingUsing.creator !== this._creator) {\n                    throw new Error(`Attempt to create application client with invalid existingDeployments against a different creator (${appIdentifier.findExistingUsing.creator}) instead of expected creator ${this._creator}`);\n                }\n                this.existingDeployments = appIdentifier.findExistingUsing;\n            }\n        }\n        this._appAddress = algosdk.getApplicationAddress(this._appId);\n        this.sender = sender;\n        this.params = params;\n    }\n    /**\n     * Compiles the approval and clear programs and sets up the source map.\n     * @param compilation The deploy-time parameters for the compilation\n     * @returns The compiled approval and clear programs\n     */\n    async compile(compilation) {\n        const { deployTimeParams, updatable, deletable } = compilation ?? {};\n        const approvalTemplate = Buffer.from(this.appSpec.source.approval, 'base64').toString('utf-8');\n        const approval = replaceDeployTimeControlParams(performTemplateSubstitution(approvalTemplate, deployTimeParams ?? this.deployTimeParams), {\n            updatable,\n            deletable,\n        });\n        const approvalCompiled = await compileTeal(approval, this.algod);\n        this._approvalSourceMap = approvalCompiled?.sourceMap;\n        const clearTemplate = Buffer.from(this.appSpec.source.clear, 'base64').toString('utf-8');\n        const clear = performTemplateSubstitution(clearTemplate, deployTimeParams ?? this.deployTimeParams);\n        const clearCompiled = await compileTeal(clear, this.algod);\n        this._clearSourceMap = clearCompiled?.sourceMap;\n        if (Config.debug && Config.projectRoot) {\n            persistSourceMaps({\n                sources: [\n                    PersistSourceMapInput.fromCompiledTeal(approvalCompiled, this._appName, 'approval.teal'),\n                    PersistSourceMapInput.fromCompiledTeal(clearCompiled, this._appName, 'clear.teal'),\n                ],\n                projectRoot: Config.projectRoot,\n                client: this.algod,\n                withSources: true,\n            });\n        }\n        return { approvalCompiled, clearCompiled };\n    }\n    /**\n     * Export the current source maps for the app.\n     * @returns The source maps\n     */\n    exportSourceMaps() {\n        if (!this._approvalSourceMap || !this._clearSourceMap) {\n            throw new Error(\"Unable to export source maps; they haven't been loaded into this client - you need to call create, update, or deploy first\");\n        }\n        return {\n            approvalSourceMap: this._approvalSourceMap,\n            clearSourceMap: this._clearSourceMap,\n        };\n    }\n    /**\n     * Import source maps for the app.\n     * @param sourceMaps The source maps to import\n     */\n    importSourceMaps(sourceMaps) {\n        this._approvalSourceMap = new SourceMap(sourceMaps.approvalSourceMap);\n        this._clearSourceMap = new SourceMap(sourceMaps.clearSourceMap);\n    }\n    /**\n     * Idempotently deploy (create, update/delete if changed) an app against the given name via the given creator account, including deploy-time template placeholder substitutions.\n     *\n     * To understand the architecture decisions behind this functionality please see https://github.com/algorandfoundation/algokit-cli/blob/main/docs/architecture-decisions/2023-01-12_smart-contract-deployment.md\n     *\n     * **Note:** if there is a breaking state schema change to an existing app (and `onSchemaBreak` is set to `'replace'`) the existing app will be deleted and re-created.\n     *\n     * **Note:** if there is an update (different TEAL code) to an existing app (and `onUpdate` is set to `'replace'`) the existing app will be deleted and re-created.\n     * @param deploy Deployment details\n     * @returns The metadata and transaction result(s) of the deployment, or just the metadata if it didn't need to issue transactions\n     */\n    async deploy(deploy) {\n        const { schema, sender: deploySender, version, allowUpdate, allowDelete, sendParams, createArgs, createOnCompleteAction, updateArgs, deleteArgs, ...deployArgs } = deploy ?? {};\n        if (this._appId !== 0) {\n            throw new Error(`Attempt to deploy app which already has an app id of ${this._appId}`);\n        }\n        const sender = deploySender ?? this.sender;\n        if (!sender) {\n            throw new Error('No sender provided, unable to deploy app');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const from = sender ?? this.sender;\n        if (!this._creator) {\n            throw new Error(\"Attempt to `deploy` a contract without specifying `resolveBy: 'creatorAndName'` in the constructor\");\n        }\n        if (this._creator !== getSenderAddress(from)) {\n            throw new Error(`Attempt to deploy contract with a sender address (${getSenderAddress(from)}) that differs from the given creator address for this application client: ${this._creator}`);\n        }\n        const approval = Buffer.from(this.appSpec.source.approval, 'base64').toString('utf-8');\n        const compilation = {\n            deployTimeParams: deployArgs.deployTimeParams,\n            updatable: allowUpdate !== undefined\n                ? allowUpdate\n                : getDeployTimeControl(approval, this.appSpec, UPDATABLE_TEMPLATE_NAME, 'update_application'),\n            deletable: allowDelete !== undefined\n                ? allowDelete\n                : getDeployTimeControl(approval, this.appSpec, DELETABLE_TEMPLATE_NAME, 'delete_application'),\n        };\n        const { approvalCompiled, clearCompiled } = await this.compile(compilation);\n        try {\n            await this.getAppReference();\n            const result = await deployApp({\n                from: sender,\n                approvalProgram: approvalCompiled.compiledBase64ToBytes,\n                clearStateProgram: clearCompiled.compiledBase64ToBytes,\n                metadata: {\n                    name: this._appName,\n                    version: version ?? '1.0',\n                    updatable: compilation.updatable,\n                    deletable: compilation.deletable,\n                },\n                schema: {\n                    globalByteSlices: this.appSpec.state.global.num_byte_slices,\n                    globalInts: this.appSpec.state.global.num_uints,\n                    localByteSlices: this.appSpec.state.local.num_byte_slices,\n                    localInts: this.appSpec.state.local.num_uints,\n                    ...schema,\n                },\n                transactionParams: this.params,\n                ...(sendParams ?? {}),\n                existingDeployments: this.existingDeployments,\n                createArgs: await this.getCallArgs(createArgs, sender),\n                createOnCompleteAction: createOnCompleteAction,\n                updateArgs: await this.getCallArgs(updateArgs, sender),\n                deleteArgs: await this.getCallArgs(deleteArgs, sender),\n                ...deployArgs,\n            }, this.algod, this.indexer);\n            // Nothing needed to happen\n            if (result.operationPerformed === 'nothing') {\n                return result;\n            }\n            if (!this.existingDeployments) {\n                throw new Error('Expected existingDeployments to be present');\n            }\n            const { transaction, confirmation, operationPerformed, ...appMetadata } = result;\n            this.existingDeployments = {\n                creator: this.existingDeployments.creator,\n                apps: { ...this.existingDeployments.apps, [this._appName]: appMetadata },\n            };\n            return { ...result, ...{ compiledApproval: approvalCompiled, compiledClear: clearCompiled } };\n        }\n        catch (e) {\n            throw this.exposeLogicError(e);\n        }\n    }\n    /**\n     * Creates a smart contract app, returns the details of the created app.\n     * @param create The parameters to create the app with\n     * @returns The details of the created app, or the transaction to create it if `skipSending` and the compilation result\n     */\n    async create(create) {\n        const { sender: createSender, note, sendParams, deployTimeParams, updatable, deletable, onCompleteAction, schema, ...args } = create ?? {};\n        if (this._appId !== 0) {\n            throw new Error(`Attempt to create app which already has an app id of ${this._appId}`);\n        }\n        const sender = createSender ?? this.sender;\n        if (!sender) {\n            throw new Error('No sender provided, unable to create app');\n        }\n        const { approvalCompiled, clearCompiled } = await this.compile(create);\n        try {\n            const result = await createApp({\n                from: sender,\n                approvalProgram: approvalCompiled.compiledBase64ToBytes,\n                clearStateProgram: clearCompiled.compiledBase64ToBytes,\n                schema: {\n                    globalByteSlices: this.appSpec.state.global.num_byte_slices,\n                    globalInts: this.appSpec.state.global.num_uints,\n                    localByteSlices: this.appSpec.state.local.num_byte_slices,\n                    localInts: this.appSpec.state.local.num_uints,\n                    ...schema,\n                },\n                onCompleteAction,\n                args: await this.getCallArgs(args, sender),\n                note: note,\n                transactionParams: this.params,\n                ...(sendParams ?? {}),\n            }, this.algod);\n            if (result.confirmation) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                this._appId = result.confirmation.applicationIndex;\n                this._appAddress = getApplicationAddress(this._appId);\n            }\n            return { ...result, ...{ compiledApproval: approvalCompiled, compiledClear: clearCompiled } };\n        }\n        catch (e) {\n            throw this.exposeLogicError(e);\n        }\n    }\n    /**\n     * Updates the smart contract app.\n     * @param update The parameters to update the app with\n     * @returns The transaction send result and the compilation result\n     */\n    async update(update) {\n        const { sender: updateSender, note, sendParams, deployTimeParams, updatable, deletable, ...args } = update ?? {};\n        if (this._appId === 0) {\n            throw new Error(`Attempt to update app which doesn't have an app id defined`);\n        }\n        const sender = updateSender ?? this.sender;\n        if (!sender) {\n            throw new Error('No sender provided, unable to create app');\n        }\n        const { approvalCompiled, clearCompiled } = await this.compile(update);\n        try {\n            const result = await updateApp({\n                appId: this._appId,\n                from: sender,\n                approvalProgram: approvalCompiled.compiledBase64ToBytes,\n                clearStateProgram: clearCompiled.compiledBase64ToBytes,\n                args: await this.getCallArgs(args, sender),\n                note: note,\n                transactionParams: this.params,\n                ...(sendParams ?? {}),\n            }, this.algod);\n            return { ...result, ...{ compiledApproval: approvalCompiled, compiledClear: clearCompiled } };\n        }\n        catch (e) {\n            throw this.exposeLogicError(e);\n        }\n    }\n    /**\n     * Issues a no_op (normal) call to the app.\n     * @param call The call details.\n     * @returns The result of the call\n     */\n    async call(call) {\n        if (\n        // ABI call\n        call?.method &&\n            // We aren't skipping the send\n            !call.sendParams?.skipSending &&\n            // There isn't an ATC passed in\n            !call.sendParams?.atc &&\n            // The method is readonly\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.appSpec.hints[getABIMethodSignature(this.getABIMethod(call.method))].read_only) {\n            const atc = new AtomicTransactionComposer();\n            await this.callOfType({ ...call, sendParams: { ...call.sendParams, atc } }, 'no_op');\n            const result = await atc.simulate(this.algod);\n            if (result.simulateResponse.txnGroups.some((group) => group.failureMessage)) {\n                throw new Error(result.simulateResponse.txnGroups.find((x) => x.failureMessage)?.failureMessage);\n            }\n            const txns = atc.buildGroup();\n            return {\n                transaction: txns[txns.length - 1].txn,\n                confirmation: result.simulateResponse.txnGroups[0].txnResults.at(-1)?.txnResult,\n                confirmations: result.simulateResponse.txnGroups[0].txnResults.map((t) => t.txnResult),\n                transactions: txns.map((t) => t.txn),\n                return: (result.methodResults?.length ?? 0 > 0) ? result.methodResults[result.methodResults.length - 1] : undefined,\n            };\n        }\n        return await this.callOfType(call, 'no_op');\n    }\n    /**\n     * Issues a opt_in call to the app.\n     * @param call The call details.\n     * @returns The result of the call\n     */\n    async optIn(call) {\n        return await this.callOfType(call, 'opt_in');\n    }\n    /**\n     * Issues a close_out call to the app.\n     * @param call The call details.\n     * @returns The result of the call\n     */\n    async closeOut(call) {\n        return await this.callOfType(call, 'close_out');\n    }\n    /**\n     * Issues a clear_state call to the app.\n     * @param call The call details.\n     * @returns The result of the call\n     */\n    async clearState(call) {\n        return await this.callOfType(call, 'clear_state');\n    }\n    /**\n     * Issues a delete_application call to the app.\n     * @param call The call details.\n     * @returns The result of the call\n     */\n    async delete(call) {\n        return await this.callOfType(call, 'delete_application');\n    }\n    /**\n     * Issues a call to the app with the given call type.\n     * @param call The call details.\n     * @param callType The call type\n     * @returns The result of the call\n     */\n    async callOfType(call = {}, callType) {\n        const { sender: callSender, note, sendParams, ...args } = call;\n        const sender = callSender ?? this.sender;\n        if (!sender) {\n            throw new Error('No sender provided, unable to call app');\n        }\n        const appMetadata = await this.getAppReference();\n        if (appMetadata.appId === 0) {\n            throw new Error(`Attempt to call an app that can't be found '${this._appName}' for creator '${this._creator}'.`);\n        }\n        try {\n            return await callApp({\n                appId: appMetadata.appId,\n                callType: callType,\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                from: sender,\n                args: await this.getCallArgs(args, sender),\n                note: note,\n                transactionParams: this.params,\n                ...(sendParams ?? {}),\n            }, this.algod);\n        }\n        catch (e) {\n            throw this.exposeLogicError(e);\n        }\n    }\n    /**\n     * Funds ALGOs into the app account for this app.\n     * @param fund The parameters for the funding or the funding amount\n     * @returns The result of the funding\n     */\n    async fundAppAccount(fund) {\n        const { amount, sender, note, sendParams } = 'microAlgos' in fund ? { amount: fund } : fund;\n        if (!sender && !this.sender) {\n            throw new Error('No sender provided, unable to call app');\n        }\n        const ref = await this.getAppReference();\n        return await transferAlgos({\n            to: ref.appAddress,\n            amount: amount,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            from: sender ?? this.sender,\n            note: note,\n            transactionParams: this.params,\n            ...(sendParams ?? {}),\n        }, this.algod);\n    }\n    /**\n     * Returns global state for the current app.\n     * @returns The global state\n     */\n    async getGlobalState() {\n        const appRef = await this.getAppReference();\n        if (appRef.appId === 0) {\n            throw new Error('No app has been created yet, unable to get global state');\n        }\n        return getAppGlobalState(appRef.appId, this.algod);\n    }\n    /**\n     * Returns local state for the given account / account address.\n     * @returns The global state\n     */\n    async getLocalState(account) {\n        const appRef = await this.getAppReference();\n        if (appRef.appId === 0) {\n            throw new Error('No app has been created yet, unable to get global state');\n        }\n        return getAppLocalState(appRef.appId, account, this.algod);\n    }\n    /**\n     * Returns the names of all current boxes for the current app.\n     * @returns The names of the boxes\n     */\n    async getBoxNames() {\n        const appRef = await this.getAppReference();\n        if (appRef.appId === 0) {\n            throw new Error('No app has been created yet, unable to get global state');\n        }\n        return await getAppBoxNames(appRef.appId, this.algod);\n    }\n    /**\n     * Returns the value of the given box for the current app.\n     * @param name The name of the box to return either as a string, binary array or `BoxName`\n     * @returns The current box value as a byte array\n     */\n    async getBoxValue(name) {\n        const appRef = await this.getAppReference();\n        if (appRef.appId === 0) {\n            throw new Error('No app has been created yet, unable to get global state');\n        }\n        return await getAppBoxValue(appRef.appId, name, this.algod);\n    }\n    /**\n     * Returns the value of the given box for the current app.\n     * @param name The name of the box to return either as a string, binary array or `BoxName`\n     * @param type\n     * @returns The current box value as a byte array\n     */\n    async getBoxValueFromABIType(name, type) {\n        const appRef = await this.getAppReference();\n        if (appRef.appId === 0) {\n            throw new Error('No app has been created yet, unable to get global state');\n        }\n        return await getAppBoxValueFromABIType({ appId: appRef.appId, boxName: name, type }, this.algod);\n    }\n    /**\n     * Returns the values of all current boxes for the current app.\n     * Note: This will issue multiple HTTP requests (one per box) and it's not an atomic operation so values may be out of sync.\n     * @param filter Optional filter to filter which boxes' values are returned\n     * @returns The (name, value) pair of the boxes with values as raw byte arrays\n     */\n    async getBoxValues(filter) {\n        const appRef = await this.getAppReference();\n        if (appRef.appId === 0) {\n            throw new Error('No app has been created yet, unable to get global state');\n        }\n        const names = await this.getBoxNames();\n        return await Promise.all(names\n            .filter(filter ?? ((_) => true))\n            .map(async (boxName) => ({ name: boxName, value: await getAppBoxValue(appRef.appId, boxName, this.algod) })));\n    }\n    /**\n     * Returns the values of all current boxes for the current app decoded using an ABI Type.\n     * Note: This will issue multiple HTTP requests (one per box) and it's not an atomic operation so values may be out of sync.\n     * @param type The ABI type to decode the values with\n     * @param filter Optional filter to filter which boxes' values are returned\n     * @returns The (name, value) pair of the boxes with values as the ABI Value\n     */\n    async getBoxValuesFromABIType(type, filter) {\n        const appRef = await this.getAppReference();\n        if (appRef.appId === 0) {\n            throw new Error('No app has been created yet, unable to get global state');\n        }\n        const names = await this.getBoxNames();\n        return await Promise.all(names.filter(filter ?? ((_) => true)).map(async (boxName) => ({\n            name: boxName,\n            value: await getAppBoxValueFromABIType({ appId: appRef.appId, boxName, type }, this.algod),\n        })));\n    }\n    /**\n     * Returns the arguments for an app call for the given ABI method or raw method specification.\n     * @param args The call args specific to this application client\n     * @param sender The sender of this call. Will be used to fetch any default argument values if applicable\n     * @returns The call args ready to pass into an app call\n     */\n    async getCallArgs(args, sender) {\n        if (!args) {\n            return undefined;\n        }\n        if (args.method) {\n            const abiMethod = this.getABIMethodParams(args.method);\n            if (!abiMethod) {\n                throw new Error(`Attempt to call ABI method ${args.method}, but it wasn't found`);\n            }\n            const methodSignature = getABIMethodSignature(abiMethod);\n            return {\n                ...args,\n                method: abiMethod,\n                methodArgs: await Promise.all(args.methodArgs.map(async (arg, index) => {\n                    if (arg !== undefined)\n                        return arg;\n                    const argName = abiMethod.args[index].name;\n                    const defaultValueStrategy = argName && this.appSpec.hints?.[methodSignature]?.default_arguments?.[argName];\n                    if (!defaultValueStrategy)\n                        throw new Error(`Argument at position ${index} with the name ${argName} is undefined and does not have a default value strategy`);\n                    switch (defaultValueStrategy.source) {\n                        case 'constant':\n                            return defaultValueStrategy.data;\n                        case 'abi-method': {\n                            const method = defaultValueStrategy.data;\n                            const result = await this.callOfType({\n                                method: getABIMethodSignature(method),\n                                methodArgs: method.args.map(() => undefined),\n                                sender,\n                            }, 'no_op');\n                            return result.return?.returnValue;\n                        }\n                        case 'local-state':\n                        case 'global-state': {\n                            const state = defaultValueStrategy.source === 'global-state' ? await this.getGlobalState() : await this.getLocalState(sender);\n                            const key = defaultValueStrategy.data;\n                            if (key in state) {\n                                return state[key].value;\n                            }\n                            else {\n                                throw new Error(`Preparing default value for argument at position ${index} with the name ${argName} resulted in the failure: The key '${key}' could not be found in ${defaultValueStrategy.source}`);\n                            }\n                        }\n                    }\n                })),\n            };\n        }\n        else {\n            return args;\n        }\n    }\n    /**\n     * Returns the ABI Method parameters for the given method name string for the app represented by this application client instance\n     * @param method Either the name of the method or the ABI method spec definition string\n     * @returns The ABI method params for the given method\n     */\n    getABIMethodParams(method) {\n        if (!method.includes('(')) {\n            const methods = this.appSpec.contract.methods.filter((m) => m.name === method);\n            if (methods.length > 1) {\n                throw new Error(`Received a call to method ${method} in contract ${this._appName}, but this resolved to multiple methods; please pass in an ABI signature instead: ${methods\n                    .map(getABIMethodSignature)\n                    .join(', ')}`);\n            }\n            return methods[0];\n        }\n        return this.appSpec.contract.methods.find((m) => getABIMethodSignature(m) === method);\n    }\n    /**\n     * Returns the ABI Method for the given method name string for the app represented by this application client instance\n     * @param method Either the name of the method or the ABI method spec definition string\n     * @returns The ABI method for the given method\n     */\n    getABIMethod(method) {\n        const methodParams = this.getABIMethodParams(method);\n        return methodParams ? new ABIMethod(methodParams) : undefined;\n    }\n    /**\n     * Gets the reference information for the current application instance.\n     * `appId` will be 0 if it can't find an app.\n     * @returns The app reference, or if deployed using the `deploy` method, the app metadata too\n     */\n    async getAppReference() {\n        if (!this.existingDeployments && this._creator) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.existingDeployments = await getCreatorAppsByName(this._creator, this.indexer);\n        }\n        if (this.existingDeployments && this._appId === 0) {\n            const app = this.existingDeployments.apps[this._appName];\n            if (!app) {\n                return {\n                    appId: 0,\n                    appAddress: getApplicationAddress(0),\n                };\n            }\n            return app;\n        }\n        return {\n            appId: this._appId,\n            appAddress: this._appAddress,\n        };\n    }\n    /**\n     * Takes an error that may include a logic error from a smart contract call and re-exposes the error to include source code information via the source map.\n     * This is automatically used within `ApplicationClient` but if you pass `skipSending: true` e.g. if doing a group transaction\n     *  then you can use this in a try/catch block to get better debugging information.\n     * @param e The error to parse\n     * @param isClear Whether or not the code was running the clear state program\n     * @returns The new error, or if there was no logic error or source map then the wrapped error with source details\n     */\n    exposeLogicError(e, isClear) {\n        if ((!isClear && this._approvalSourceMap == undefined) || (isClear && this._clearSourceMap == undefined))\n            return e;\n        const errorDetails = LogicError.parseLogicError(e);\n        if (errorDetails !== undefined)\n            return new LogicError(errorDetails, Buffer.from(isClear ? this.appSpec.source.clear : this.appSpec.source.approval, 'base64')\n                .toString()\n                .split('\\n'), \n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            isClear ? this._clearSourceMap : this._approvalSourceMap);\n        else\n            return e;\n    }\n}\n\nexport { ApplicationClient };\n//# sourceMappingURL=app-client.mjs.map\n","import algosdk from 'algosdk';\nimport { Config } from './config.mjs';\nimport { getSenderAddress, getTransactionParams, encodeTransactionNote, encodeLease, sendTransaction, sendGroupOfTransactions, MAX_TRANSACTION_GROUP_SIZE } from './transaction/transaction.mjs';\n\nvar ValidationType;\n(function (ValidationType) {\n    ValidationType[ValidationType[\"OptIn\"] = 0] = \"OptIn\";\n    ValidationType[ValidationType[\"OptOut\"] = 1] = \"OptOut\";\n})(ValidationType || (ValidationType = {}));\nfunction* chunks(arr, n) {\n    for (let i = 0; i < arr.length; i += n)\n        yield arr.slice(i, i + n);\n}\nasync function ensureAssetBalanceConditions(account, assetIds, validationType, algod) {\n    const accountAddress = getSenderAddress(account);\n    const accountInfo = await algod.accountInformation(accountAddress).do();\n    const assetPromises = assetIds.map(async (assetId) => {\n        if (validationType === ValidationType.OptIn) {\n            if (accountInfo.assets.find((a) => a['asset-id'] === assetId)) {\n                Config.logger.debug(`Account ${accountAddress} has already opted-in to asset ${assetId}`);\n                return assetId;\n            }\n        }\n        else if (validationType === ValidationType.OptOut) {\n            try {\n                const accountAssetInfo = await algod.accountAssetInformation(accountAddress, assetId).do();\n                if (accountAssetInfo['asset-holding']['amount'] !== 0) {\n                    Config.logger.debug(`Asset ${assetId} is not with zero balance`);\n                    return assetId;\n                }\n            }\n            catch (e) {\n                Config.logger.debug(`Account ${accountAddress} does not have asset ${assetId}`);\n                return assetId;\n            }\n        }\n        return null;\n    });\n    const invalidAssets = (await Promise.all(assetPromises)).filter((assetId) => assetId !== null);\n    if (invalidAssets.length > 0) {\n        let errorMessage = '';\n        if (validationType === ValidationType.OptIn) {\n            errorMessage = `Asset${invalidAssets.length === 1 ? '' : 's'} ${invalidAssets.join(', ')} cannot be opted in. Ensure that they are valid and that the account has not previously opted into them.`;\n        }\n        else if (validationType === ValidationType.OptOut) {\n            errorMessage = `Asset${invalidAssets.length === 1 ? '' : 's'} ${invalidAssets.join(', ')} cannot be opted out. Ensure that they are valid and that the account has previously opted into them and holds zero balance.`;\n        }\n        throw new Error(errorMessage);\n    }\n}\n/**\n * Create an Algorand Standard Asset (ASA).\n * @param create The asset creation definition\n * @param algod An algod client\n * @returns The transaction object and optionally the confirmation if it was sent to the chain (`skipSending` is `false` or unset)\n *\n * @example Usage example\n * ```typescript\n * await algokit.createAsset({ creator: account, total: 1, decimals: 0, name: 'My asset' }, algod)\n * ```\n */\nasync function createAsset(create, algod) {\n    const { creator, total, decimals, name, unit, url, metadataHash, manager, reserveAccount, freezeAccount, clawbackAccount, frozenByDefault, note, transactionParams, lease, ...sendParams } = create;\n    const transaction = algosdk.makeAssetCreateTxnWithSuggestedParamsFromObject({\n        from: getSenderAddress(creator),\n        total,\n        decimals,\n        assetName: name,\n        unitName: unit,\n        assetURL: url,\n        defaultFrozen: frozenByDefault ?? false,\n        assetMetadataHash: metadataHash,\n        manager: manager ? getSenderAddress(manager) : undefined,\n        reserve: reserveAccount ? getSenderAddress(reserveAccount) : undefined,\n        freeze: freezeAccount ? getSenderAddress(freezeAccount) : undefined,\n        clawback: clawbackAccount ? getSenderAddress(clawbackAccount) : undefined,\n        rekeyTo: undefined,\n        suggestedParams: await getTransactionParams(transactionParams, algod),\n        note: encodeTransactionNote(note),\n    });\n    const encodedLease = encodeLease(lease);\n    if (encodedLease) {\n        transaction.addLease(encodedLease);\n    }\n    const result = await sendTransaction({ transaction, from: creator, sendParams }, algod);\n    if (!sendParams.skipSending) {\n        Config.getLogger(sendParams.suppressLog).info(`Successfully created asset ${name ? `${name} ` : ''}${unit ? `(${unit}) ` : ''} with ${total} units and ${decimals} decimals via transaction ${transaction.txID()} with asset index ${result.confirmation?.assetIndex} and creator ${getSenderAddress(creator)}.`);\n        return result;\n    }\n    return { transaction: result.transaction };\n}\n/**\n * Opt-in an account to an asset.\n * @param optIn The opt-in definition\n * @param algod An algod client\n * @returns The transaction object and optionally the confirmation if it was sent to the chain (`skipSending` is `false` or unset)\n *\n * @example Usage example\n * ```typescript\n * await algokit.assetOptIn({ account, assetId }, algod)\n * ```\n */\nasync function assetOptIn(optIn, algod) {\n    const { account, assetId, note, transactionParams, lease, ...sendParams } = optIn;\n    const transaction = algosdk.makeAssetTransferTxnWithSuggestedParamsFromObject({\n        from: getSenderAddress(account),\n        to: getSenderAddress(account),\n        assetIndex: assetId,\n        amount: 0,\n        rekeyTo: undefined,\n        revocationTarget: undefined,\n        closeRemainderTo: undefined,\n        suggestedParams: await getTransactionParams(transactionParams, algod),\n        note: encodeTransactionNote(note),\n    });\n    const encodedLease = encodeLease(lease);\n    if (encodedLease) {\n        transaction.addLease(encodedLease);\n    }\n    if (!sendParams.skipSending) {\n        Config.getLogger(sendParams.suppressLog).debug(`Opted-in ${getSenderAddress(account)} to asset ${assetId}`);\n    }\n    return sendTransaction({ transaction, from: account, sendParams }, algod);\n}\n/**\n * Opt-out an account from an asset.\n * @param optOut The opt-in definition\n * @param algod An algod client\n * @returns The transaction object and optionally the confirmation if it was sent to the chain (`skipSending` is `false` or unset)\n *\n * @example Usage example\n * ```typescript\n * await algokit.assetOptOut({ account, assetId, assetCreatorAddress }, algod)\n * ```\n */\nasync function assetOptOut(optOut, algod) {\n    const { account, assetId, note, transactionParams, lease, assetCreatorAddress: _assetCreatorAddress, ensureZeroBalance, ...sendParams } = optOut;\n    if (ensureZeroBalance === undefined || ensureZeroBalance) {\n        await ensureAssetBalanceConditions(account, [assetId], ValidationType.OptOut, algod);\n    }\n    const assetCreatorAddress = _assetCreatorAddress ?? (await algod.getAssetByID(assetId).do()).params.creator;\n    const transaction = algosdk.makeAssetTransferTxnWithSuggestedParamsFromObject({\n        from: getSenderAddress(account),\n        to: getSenderAddress(account),\n        assetIndex: assetId,\n        amount: 0,\n        rekeyTo: undefined,\n        revocationTarget: undefined,\n        closeRemainderTo: assetCreatorAddress,\n        suggestedParams: await getTransactionParams(transactionParams, algod),\n        note: encodeTransactionNote(note),\n    });\n    const encodedLease = encodeLease(lease);\n    if (encodedLease) {\n        transaction.addLease(encodedLease);\n    }\n    if (!sendParams.skipSending) {\n        Config.getLogger(sendParams.suppressLog).debug(`Opted-out ${getSenderAddress(account)} from asset ${assetId}`);\n    }\n    return sendTransaction({ transaction, from: account, sendParams }, algod);\n}\n/**\n * Opt in to a list of assets on the Algorand blockchain.\n *\n * @param optIn - The bulk opt-in request.\n * @param algod - An instance of the Algodv2 class from the `algosdk` library.\n * @returns A record object where the keys are the asset IDs and the values are the corresponding transaction IDs for successful opt-ins.\n * @throws If there is an error during the opt-in process.\n * @example algokit.bulkOptIn({ account: account, assetIds: [12345, 67890] }, algod)\n */\nasync function assetBulkOptIn(optIn, algod) {\n    const { account, assetIds, validateBalances, transactionParams, note, maxFee, suppressLog } = optIn;\n    const result = {};\n    if (validateBalances === undefined || validateBalances) {\n        await ensureAssetBalanceConditions(account, assetIds, ValidationType.OptIn, algod);\n    }\n    const suggestedParams = await getTransactionParams(transactionParams, algod);\n    for (const assetGroup of chunks(assetIds, MAX_TRANSACTION_GROUP_SIZE)) {\n        try {\n            const transactionsToSign = await Promise.all(assetGroup.map(async (assetId) => ({\n                transaction: (await assetOptIn({\n                    account,\n                    assetId,\n                    transactionParams: suggestedParams,\n                    note,\n                    maxFee,\n                    skipSending: true,\n                    suppressLog: true,\n                }, algod)).transaction,\n                signer: account,\n            })));\n            const txnGrp = {\n                transactions: transactionsToSign,\n                signer: account,\n                sendParams: {\n                    suppressLog: true,\n                },\n            };\n            const sendGroupOfTransactionsResult = await sendGroupOfTransactions(txnGrp, algod);\n            assetGroup.map((assetId, index) => {\n                result[assetId] = sendGroupOfTransactionsResult.txIds[index];\n                Config.getLogger(suppressLog).info(`Successfully opted in ${getSenderAddress(account)} for asset ${assetId} with transaction ID ${sendGroupOfTransactionsResult.txIds[index]},\n          grouped under ${sendGroupOfTransactionsResult.groupId} round ${sendGroupOfTransactionsResult.confirmations?.[0]?.confirmedRound}.`);\n            });\n        }\n        catch (e) {\n            throw new Error(`Received error trying to opt in ${e}`);\n        }\n    }\n    return result;\n}\n/**\n * Opt out of multiple assets in Algorand blockchain.\n *\n * @param optOut The bulk opt-out request.\n * @param algod - An instance of the Algodv2 client used to interact with the Algorand blockchain.\n * @returns A record object containing asset IDs as keys and their corresponding transaction IDs as values.\n * @throws If there is an error during the opt-out process.\n * @example algokit.bulkOptOut({ account: account, assetIds: [12345, 67890] }, algod)\n */\nasync function assetBulkOptOut(optOut, algod) {\n    const { account, validateBalances, transactionParams, note, assetIds, maxFee, suppressLog } = optOut;\n    const result = {};\n    if (validateBalances === undefined || validateBalances) {\n        await ensureAssetBalanceConditions(account, assetIds, ValidationType.OptOut, algod);\n    }\n    const suggestedParams = await getTransactionParams(transactionParams, algod);\n    const assetDetails = await Promise.all(assetIds.map((assetId) => algod.getAssetByID(assetId).do()));\n    for (const assetGroup of chunks(assetDetails, MAX_TRANSACTION_GROUP_SIZE)) {\n        try {\n            const transactionToSign = await Promise.all(assetGroup.map(async (asset) => ({\n                transaction: (await assetOptOut({\n                    account,\n                    assetId: asset.index,\n                    assetCreatorAddress: asset.params.creator,\n                    transactionParams: suggestedParams,\n                    note,\n                    maxFee,\n                    skipSending: true,\n                    suppressLog: true,\n                }, algod)).transaction,\n                signer: account,\n            })));\n            const txnGrp = {\n                transactions: transactionToSign,\n                signer: account,\n                sendParams: {\n                    suppressLog: true,\n                },\n            };\n            const sendGroupOfTransactionsResult = await sendGroupOfTransactions(txnGrp, algod);\n            assetGroup.map((asset, index) => {\n                result[asset.index] = sendGroupOfTransactionsResult.txIds[index];\n                Config.getLogger(suppressLog).info(`Successfully opted out ${getSenderAddress(account)} from asset ${asset.index} with transaction ID ${sendGroupOfTransactionsResult.txIds[index]},\n          grouped under ${sendGroupOfTransactionsResult.groupId} round ${sendGroupOfTransactionsResult.confirmations?.[0]?.confirmedRound}.`);\n            });\n        }\n        catch (e) {\n            throw new Error(`Received error trying to opt out ${e}`);\n        }\n    }\n    return result;\n}\n\nexport { assetBulkOptIn, assetBulkOptOut, assetOptIn, assetOptOut, createAsset };\n//# sourceMappingURL=asset.mjs.map\n","import { ApplicationClient } from './types/app-client.mjs';\n\n/**\n * Create a new ApplicationClient instance\n * @param appDetails The details of the app\n * @param algod An algod instance\n *\n * @example Resolve by creator and name\n * const client = algokit.getAppClient(\n *     {\n *       resolveBy: 'creatorAndName',\n *       app: {appSpec},\n *       sender: {account},\n *       creatorAddress: {creator},\n *       findExistingUsing: indexerClient,\n *     },\n *     algodClient,\n *   )\n *\n * @example Resolve by id:\n * const client = algokit.getAppClient(\n *     {\n *       resolveBy: 'id',\n *       app: {appSpec},\n *       sender: {account},\n *       id: {id},\n *     },\n *    algodClient,\n * )\n *\n * @returns The application client\n */\nfunction getAppClient(appDetails, algod) {\n    return new ApplicationClient(appDetails, algod);\n}\n/**\n * Create a new ApplicationClient instance by id\n * @param appDetails The details of the app\n * @param algod An algod instance\n *\n * @example\n * const client = algokit.getAppClientById(\n *     {\n *       app: {appSpec},\n *       sender: {account},\n *       id: {id},\n *     },\n *     algodClient,\n *   )\n *\n * @returns The application client\n */\nfunction getAppClientById(appDetails, algod) {\n    return new ApplicationClient({ ...appDetails, resolveBy: 'id' }, algod);\n}\n/**\n * Create a new ApplicationClient instance by creator and name\n * @param appDetails The details of the app by creator and name\n * @param algod An algod instance\n *\n * @example\n * const client = algokit.getAppClientByCreatorAndName(\n *     {\n *       app: {appSpec},\n *       sender: {account},\n *       creatorAddress: {account.addr},\n *       findExistingUsing: {indexerClient},\n *     },\n *     algodClient,\n *   )\n *\n * @returns The application client\n */\nfunction getAppClientByCreatorAndName(appDetails, algod) {\n    return new ApplicationClient({ ...appDetails, resolveBy: 'creatorAndName' }, algod);\n}\n\nexport { getAppClient, getAppClientByCreatorAndName, getAppClientById };\n//# sourceMappingURL=app-client.mjs.map\n","const baseUrl = 'https://api.dispenser.algorandfoundation.tools';\nconst dispenserRequestTimeout = 15;\nconst dispenserAccessTokenKey = 'ALGOKIT_DISPENSER_ACCESS_TOKEN';\nvar DispenserAssetName;\n(function (DispenserAssetName) {\n    DispenserAssetName[DispenserAssetName[\"Algo\"] = 0] = \"Algo\";\n})(DispenserAssetName || (DispenserAssetName = {}));\nconst dispenserAssets = {\n    [DispenserAssetName.Algo]: {\n        assetId: 0,\n        decimals: 6,\n        description: 'Algo',\n    },\n};\n/**\n * `TestNetDispenserApiClient` is a class that provides methods to interact with the [Algorand TestNet Dispenser API](https://github.com/algorandfoundation/algokit/blob/main/docs/testnet_api.md).\n * It allows you to fund an address with Algos, refund a transaction, and get the funding limit for the Algo asset.\n *\n * The class requires an authentication token and a request timeout to be initialized. The authentication token can be provided\n * either directly as a parameter or through an `ALGOKIT_DISPENSER_ACCESS_TOKEN` environment variable. If neither is provided, an error is thrown.\n *\n * The request timeout can be provided as a parameter. If not provided, a default value is used.\n *\n * @property {string} authToken - The authentication token used for API requests.\n * @property {number} requestTimeout - The timeout for API requests, in seconds.\n *\n * @method fund - Sends a funding request to the dispenser API to fund the specified address with the given amount of Algo.\n * @method refund - Sends a refund request to the dispenser API for the specified refundTxnId.\n * @method limit - Sends a request to the dispenser API to get the funding limit for the Algo asset.\n *\n * @example\n * ```typescript\n * const client = new TestNetDispenserApiClient({ authToken: 'your_auth_token', requestTimeout: 30 });\n * const fundResponse = await client.fund('your_address', 100);\n * const limitResponse = await client.getLimit();\n * await client.refund('your_transaction_id');\n * ```\n *\n * @throws {Error} If neither the environment variable 'ALGOKIT_DISPENSER_ACCESS_TOKEN' nor the authToken parameter were provided.\n */\nclass TestNetDispenserApiClient {\n    constructor(params) {\n        const authTokenFromEnv = process.env[dispenserAccessTokenKey];\n        if (params?.authToken) {\n            this._authToken = params.authToken;\n        }\n        else if (authTokenFromEnv) {\n            this._authToken = authTokenFromEnv;\n        }\n        else {\n            throw new Error(`Can't init AlgoKit TestNet Dispenser API client because neither environment variable ${dispenserAccessTokenKey} or the authToken were provided.`);\n        }\n        this._requestTimeout = params?.requestTimeout || dispenserRequestTimeout;\n    }\n    get authToken() {\n        return this._authToken;\n    }\n    get requestTimeout() {\n        return this._requestTimeout;\n    }\n    /**\n     * Processes a dispenser API request.\n     *\n     * @param authToken - The authentication token.\n     * @param urlSuffix - The URL suffix for the API request.\n     * @param body - The request body.\n     * @param method - The HTTP method.\n     *\n     * @returns The API response.\n     */\n    async processDispenserRequest(authToken, urlSuffix, body = null, method = 'POST') {\n        const headers = { Authorization: `Bearer ${authToken}` };\n        const requestArgs = {\n            method: method,\n            headers: headers,\n            signal: AbortSignal.timeout(this.requestTimeout * 1000),\n        };\n        if (body) {\n            requestArgs.body = JSON.stringify(body);\n        }\n        const response = await fetch(`${baseUrl}/${urlSuffix}`, requestArgs);\n        if (!response.ok) {\n            let error_message = `Error processing dispenser API request: ${response.status}`;\n            let error_response = null;\n            try {\n                error_response = await response.json();\n            }\n            catch (err) {\n                // suppress exception\n            }\n            if (error_response && error_response.code) {\n                error_message = error_response.code;\n            }\n            else if (response.status === 400) {\n                error_message = (await response.json()).message;\n            }\n            throw new Error(error_message);\n        }\n        return response;\n    }\n    /**\n     * Sends a funding request to the dispenser API to fund the specified address with the given amount of Algo.\n     *\n     * @param address - The address to fund.\n     * @param amount - The amount of Algo to fund.\n     *\n     * @returns DispenserFundResponse: An object containing the transaction ID and funded amount.\n     */\n    async fund(address, amount) {\n        const response = await this.processDispenserRequest(this.authToken, `fund/${dispenserAssets[DispenserAssetName.Algo].assetId}`, { receiver: address, amount: amount, assetID: dispenserAssets[DispenserAssetName.Algo].assetId }, 'POST');\n        const content = await response.json();\n        return { txId: content.txID, amount: content.amount };\n    }\n    /**\n     * Sends a refund request to the dispenser API for the specified refundTxnId.\n     *\n     * @param refundTxnId - The transaction ID to refund.\n     */\n    async refund(refundTxnId) {\n        await this.processDispenserRequest(this.authToken, 'refund', { refundTransactionID: refundTxnId }, 'POST');\n    }\n    /**\n     * Sends a request to the dispenser API to get the funding limit for the Algo asset.\n     *\n     * @returns DispenserLimitResponse: An object containing the funding limit amount.\n     */\n    async getLimit() {\n        const response = await this.processDispenserRequest(this.authToken, `fund/${dispenserAssets[DispenserAssetName.Algo].assetId}/limit`, null, 'GET');\n        const content = await response.json();\n        return { amount: content.amount };\n    }\n}\n\nexport { TestNetDispenserApiClient };\n//# sourceMappingURL=dispenser-client.mjs.map\n","import { Buffer } from 'buffer';\n\nclass URLTokenBaseHTTPError extends Error {\n    constructor(message, response) {\n        super(message);\n        this.response = response;\n        this.name = 'URLTokenBaseHTTPError';\n        this.response = response;\n    }\n}\n/**\n * Implementation of BaseHTTPClient that uses a URL and a token\n * and make the REST queries using fetch.\n * This is the default implementation of BaseHTTPClient.\n */\nclass URLTokenBaseHTTPClient {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(tokenHeader, baseServer, port, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    defaultHeaders = {}) {\n        this.defaultHeaders = defaultHeaders;\n        // Append a trailing slash so we can use relative paths. Without the trailing\n        // slash, the last path segment will be replaced by the relative path. See\n        // usage in `addressWithPath`.\n        const fixedBaseServer = baseServer.endsWith('/') ? baseServer : `${baseServer}/`;\n        const baseServerURL = new URL(fixedBaseServer);\n        if (typeof port !== 'undefined') {\n            baseServerURL.port = port.toString();\n        }\n        if (baseServerURL.protocol.length === 0) {\n            throw new Error('Invalid base server URL, protocol must be defined.');\n        }\n        this.baseURL = baseServerURL;\n        this.tokenHeader = tokenHeader;\n    }\n    /**\n     * Compute the URL for a path relative to the instance's address\n     * @param relativePath - A path string\n     * @param query - An optional key-value object of query parameters to add to the URL. If the\n     *   relativePath already has query parameters on it, the additional parameters defined here will\n     *   be added to the URL without modifying those (unless a key collision occurs).\n     * @returns A URL string\n     */\n    getURL(relativePath, query) {\n        let fixedRelativePath;\n        if (relativePath.startsWith('./')) {\n            fixedRelativePath = relativePath;\n        }\n        else if (relativePath.startsWith('/')) {\n            fixedRelativePath = `.${relativePath}`;\n        }\n        else {\n            fixedRelativePath = `./${relativePath}`;\n        }\n        const address = new URL(fixedRelativePath, this.baseURL);\n        if (query) {\n            for (const [key, value] of Object.entries(query)) {\n                address.searchParams.set(key, value);\n            }\n        }\n        return address.toString();\n    }\n    static formatFetchResponseHeaders(headers) {\n        const headersObj = {};\n        headers.forEach((key, value) => {\n            headersObj[key] = value;\n        });\n        return headersObj;\n    }\n    static async checkHttpError(res) {\n        if (res.ok) {\n            return;\n        }\n        let body = null;\n        let bodyErrorMessage = null;\n        try {\n            body = new Uint8Array(await res.arrayBuffer());\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const decoded = JSON.parse(Buffer.from(body).toString());\n            if (decoded.message) {\n                bodyErrorMessage = decoded.message;\n            }\n        }\n        catch (_) {\n            // ignore any error that happened while we are parsing the error response\n        }\n        let message = `Network request error. Received status ${res.status} (${res.statusText})`;\n        if (bodyErrorMessage) {\n            message += `: ${bodyErrorMessage}`;\n        }\n        throw new URLTokenBaseHTTPError(message, {\n            body: body !== null ? body : new Uint8Array(),\n            status: res.status,\n            headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers),\n        });\n    }\n    static async formatFetchResponse(res) {\n        await this.checkHttpError(res);\n        return {\n            body: new Uint8Array(await res.arrayBuffer()),\n            status: res.status,\n            headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers),\n        };\n    }\n    async get(relativePath, query, requestHeaders = {}) {\n        // Expand headers for use in fetch\n        const headers = {\n            ...this.tokenHeader,\n            ...this.defaultHeaders,\n            ...requestHeaders,\n        };\n        const res = await fetch(this.getURL(relativePath, query), {\n            mode: 'cors',\n            headers,\n        });\n        return URLTokenBaseHTTPClient.formatFetchResponse(res);\n    }\n    async post(relativePath, data, query, requestHeaders = {}) {\n        // Expand headers for use in fetch\n        const headers = {\n            ...this.tokenHeader,\n            ...this.defaultHeaders,\n            ...requestHeaders,\n        };\n        const res = await fetch(this.getURL(relativePath, query), {\n            method: 'POST',\n            mode: 'cors',\n            body: data,\n            headers,\n        });\n        return URLTokenBaseHTTPClient.formatFetchResponse(res);\n    }\n    async delete(relativePath, data, query, requestHeaders = {}) {\n        // Expand headers for use in fetch\n        const headers = {\n            ...this.tokenHeader,\n            ...this.defaultHeaders,\n            ...requestHeaders,\n        };\n        const res = await fetch(this.getURL(relativePath, query), {\n            method: 'DELETE',\n            mode: 'cors',\n            body: data,\n            headers,\n        });\n        return URLTokenBaseHTTPClient.formatFetchResponse(res);\n    }\n}\n\nexport { URLTokenBaseHTTPClient };\n//# sourceMappingURL=urlTokenBaseHTTPClient.mjs.map\n","import { Config } from '../config.mjs';\nimport { URLTokenBaseHTTPClient } from './urlTokenBaseHTTPClient.mjs';\n\n/** A HTTP Client that wraps the Algorand SDK HTTP Client with retries */\nclass AlgoHttpClientWithRetry extends URLTokenBaseHTTPClient {\n    async callWithRetry(func) {\n        let response;\n        let numTries = 1;\n        do {\n            try {\n                response = await func();\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            }\n            catch (err) {\n                if (numTries >= AlgoHttpClientWithRetry.MAX_TRIES) {\n                    throw err;\n                }\n                // Only retry for one of the hardcoded conditions\n                if (!(AlgoHttpClientWithRetry.RETRY_ERROR_CODES.includes(err.code) ||\n                    AlgoHttpClientWithRetry.RETRY_STATUS_CODES.includes(Number(err.status)) ||\n                    ('response' in err && AlgoHttpClientWithRetry.RETRY_STATUS_CODES.includes(Number(err.response.status))))) {\n                    throw err;\n                }\n                // Retry immediately the first time, then exponentially backoff.\n                const delayTimeMs = numTries == 1 ? 0 : Math.min(1000 * Math.pow(2, numTries - 1), AlgoHttpClientWithRetry.MAX_BACKOFF_MS);\n                if (delayTimeMs > 0) {\n                    await new Promise((r) => setTimeout(r, delayTimeMs));\n                }\n                Config.logger.warn(`algosdk request failed ${numTries} times. Retrying in ${delayTimeMs}ms: ${err}`);\n            }\n        } while (!response && ++numTries <= AlgoHttpClientWithRetry.MAX_TRIES);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return response;\n    }\n    async get(relativePath, query, requestHeaders = {}) {\n        return await this.callWithRetry(() => super.get(relativePath, query, requestHeaders));\n    }\n    async post(relativePath, data, query, requestHeaders = {}) {\n        return await this.callWithRetry(() => super.post(relativePath, data, query, requestHeaders));\n    }\n    async delete(relativePath, data, query, requestHeaders = {}) {\n        return await this.callWithRetry(() => super.delete(relativePath, data, query, requestHeaders));\n    }\n}\nAlgoHttpClientWithRetry.MAX_TRIES = 5;\nAlgoHttpClientWithRetry.MAX_BACKOFF_MS = 10000;\n// These lists come from https://visionmedia.github.io/superagent/#retrying-requests\n// which is the underlying library used by algosdk - but the CloudFlare specific 52X status codes have been removed\nAlgoHttpClientWithRetry.RETRY_STATUS_CODES = [408, 413, 429, 500, 502, 503, 504];\nAlgoHttpClientWithRetry.RETRY_ERROR_CODES = [\n    'ETIMEDOUT',\n    'ECONNRESET',\n    'EADDRINUSE',\n    'ECONNREFUSED',\n    'EPIPE',\n    'ENOTFOUND',\n    'ENETUNREACH',\n    'EAI_AGAIN',\n    'EPROTO', // We get this intermittently with AlgoNode API\n];\n\nexport { AlgoHttpClientWithRetry };\n//# sourceMappingURL=algo-http-client-with-retry.mjs.map\n","import algosdk from 'algosdk';\nimport { AlgoHttpClientWithRetry } from './algo-http-client-with-retry.mjs';\nimport { ApplicationClient } from './app-client.mjs';\nimport { TestNetDispenserApiClient } from './dispenser-client.mjs';\n\nvar Kmd = algosdk.Kmd;\nvar Indexer = algosdk.Indexer;\nvar IntDecoding = algosdk.IntDecoding;\n/** Exposes access to various API clients. */\nclass ClientManager {\n    /**\n     * algosdk clients or config for interacting with the official Algorand APIs.\n     * @param clientsOrConfig The clients or config to use\n     * @example Algod client only\n     * ```typescript\n     * const clientManager = new ClientManager({ algod: algodClient })\n     * ```\n     * @example All clients\n     * ```typescript\n     * const clientManager = new ClientManager({ algod: algodClient, indexer: indexerClient, kmd: kmdClient })\n     * ```\n     * @example Algod config only\n     * ```typescript\n     * const clientManager = new ClientManager({ algodConfig })\n     * ```\n     * @example All client configs\n     * ```typescript\n     * const clientManager = new ClientManager({ algodConfig, indexerConfig, kmdConfig })\n     * ```\n     */\n    constructor(clientsOrConfig) {\n        const _clients = 'algod' in clientsOrConfig\n            ? clientsOrConfig\n            : {\n                algod: ClientManager.getAlgodClient(clientsOrConfig.algodConfig),\n                indexer: clientsOrConfig.indexerConfig ? ClientManager.getIndexerClient(clientsOrConfig.indexerConfig) : undefined,\n                kmd: clientsOrConfig.kmdConfig ? ClientManager.getKmdClient(clientsOrConfig.kmdConfig) : undefined,\n            };\n        this._algod = _clients.algod;\n        this._indexer = _clients.indexer;\n        this._kmd = _clients.kmd;\n    }\n    /** Returns an algosdk Algod API client. */\n    get algod() {\n        return this._algod;\n    }\n    /** Returns an algosdk Indexer API client or throws an error if it's not been provided. */\n    get indexer() {\n        if (!this._indexer)\n            throw new Error('Attempt to use Indexer client in AlgoKit instance with no Indexer configured');\n        return this._indexer;\n    }\n    /** Returns an algosdk KMD API client or throws an error if it's not been provided. */\n    get kmd() {\n        if (!this._kmd)\n            throw new Error('Attempt to use Kmd client in AlgoKit instance with no Kmd configured');\n        return this._kmd;\n    }\n    /**\n     * Get details about the current network.\n     * @example Getting genesis ID\n     * ```typescript\n     * const network = await networkClient.network()\n     * const genesisId = network.genesisId\n     * ```\n     * @returns The current network details\n     */\n    async network() {\n        if (!this._getNetworkPromise) {\n            this._getNetworkPromise = this._algod.getTransactionParams().do();\n        }\n        const params = await this._getNetworkPromise;\n        return {\n            isTestNet: ['testnet-v1.0', 'testnet-v1', 'testnet'].includes(params.genesisID),\n            isMainNet: ['mainnet-v1.0', 'mainnet-v1', 'mainnet'].includes(params.genesisID),\n            isLocalNet: params.genesisID === 'devnet-v1' || params.genesisID === 'sandnet-v1' || params.genesisID === 'dockernet-v1',\n            genesisId: params.genesisID,\n            genesisHash: params.genesisHash,\n        };\n    }\n    /**\n     * Returns true if the current network is LocalNet.\n     * @returns True if the current network is LocalNet.\n     */\n    async isLocalNet() {\n        return (await this.network()).isLocalNet;\n    }\n    /**\n     * Returns true if the current network is TestNet.\n     * @returns True if the current network is TestNet.\n     */\n    async isTestNet() {\n        return (await this.network()).isTestNet;\n    }\n    /**\n     * Returns true if the current network is MainNet.\n     * @returns True if the current network is MainNet.\n     */\n    async isMainNet() {\n        return (await this.network()).isMainNet;\n    }\n    /**\n     * Returns a TestNet Dispenser API client.\n     * Refer to [docs](https://github.com/algorandfoundation/algokit/blob/main/docs/testnet_api.md) on guidance to obtain an access token.\n     *\n     * @param params An object containing parameters for the TestNetDispenserApiClient class.\n     *  Or null if you want the client to load the access token from the environment variable `ALGOKIT_DISPENSER_ACCESS_TOKEN`.\n     * @example\n     * const client = clientManager.getTestNetDispenser(\n     *     {\n     *       authToken: 'your_auth_token',\n     *       requestTimeout: 15,\n     *     }\n     * )\n     *\n     * @returns An instance of the TestNetDispenserApiClient class.\n     */\n    getTestNetDispenser(params = null) {\n        return new TestNetDispenserApiClient(params);\n    }\n    /**\n     * Returns a new `ApplicationClient` client, resolving the app by creator address and name.\n     * @param details The details to resolve the app by creator address and name\n     * @param cachedAppLookup A cached app lookup that matches a name to on-chain details; either this is needed or indexer is required to be passed in to this manager on construction.\n     * @returns The `ApplicationClient`\n     */\n    getAppClientByCreatorAndName(details, cachedAppLookup) {\n        return new ApplicationClient({ ...details, resolveBy: 'creatorAndName', findExistingUsing: cachedAppLookup ?? this.indexer }, this._algod);\n    }\n    /**\n     * Returns a new `ApplicationClient` client, resolving the app by app ID.\n     * @param details The details to resolve the app by ID\n     * @returns The `ApplicationClient`\n     */\n    getAppClientById(details) {\n        return new ApplicationClient({ ...details, resolveBy: 'id' }, this._algod);\n    }\n    /**\n     * Returns a new typed client, resolving the app by creator address and name.\n     * @param typedClient The typed client type to use\n     * @param details The details to resolve the app by creator address and name\n     * @param cachedAppLookup A cached app lookup that matches a name to on-chain details; either this is needed or indexer is required to be passed in to this manager on construction.\n     * @returns The typed client instance\n     */\n    getTypedAppClientByCreatorAndName(typedClient, details, cachedAppLookup) {\n        return new typedClient({ ...details, resolveBy: 'creatorAndName', findExistingUsing: cachedAppLookup ?? this.indexer }, this._algod);\n    }\n    /**\n     * Returns a new typed client, resolving the app by app ID.\n     * @param typedClient The typed client type to use\n     * @param details The details to resolve the app by ID\n     * @returns The typed client instance\n     */\n    getTypedAppClientById(typedClient, details) {\n        return new typedClient({ ...details, resolveBy: 'id' }, this._algod);\n    }\n    /**\n     * Retrieve client configurations from environment variables when defined or get defaults (expects to be called from a Node.js environment)\n     *\n     * If both `process.env.INDEXER_SERVER` and `process.env.ALGOD_SERVER` is defined it will use both along with optional `process.env.ALGOD_PORT`, `process.env.ALGOD_TOKEN`, `process.env.INDEXER_PORT` and `process.env.INDEXER_TOKEN`.\n     *\n     * If only `process.env.ALGOD_SERVER` is defined it will use this along with optional `process.env.ALGOD_PORT` and `process.env.ALGOD_TOKEN` and leave indexer as `undefined`.\n     *\n     * If only `process.env.INDEXER_SERVER` is defined it will use the default (LocalNet) configuration for both algod and indexer.\n     *\n     * It will return a KMD configuration that uses `process.env.KMD_PORT` (or port 4002) if `process.env.ALGOD_SERVER` is defined,\n     * otherwise it will use the default LocalNet config unless it detects testnet or mainnet.\n     * @example\n     * ```typescript\n     * const config = ClientManager.getConfigFromEnvironmentOrLocalNet()\n     * ```\n     * @returns The config for algod, indexer and kmd\n     */\n    static getConfigFromEnvironmentOrLocalNet() {\n        if (!process || !process.env) {\n            throw new Error('Attempt to get default client configuration from a non Node.js context; supply the config instead');\n        }\n        const [algodConfig, indexerConfig, kmdConfig] = process.env.ALGOD_SERVER\n            ? [\n                ClientManager.getAlgodConfigFromEnvironment(),\n                process.env.INDEXER_SERVER ? ClientManager.getIndexerConfigFromEnvironment() : undefined,\n                !process.env.ALGOD_SERVER.includes('mainnet') && !process.env.ALGOD_SERVER.includes('testnet')\n                    ? { ...ClientManager.getAlgodConfigFromEnvironment(), port: process?.env?.KMD_PORT ?? '4002' }\n                    : undefined,\n            ]\n            : [\n                ClientManager.getDefaultLocalNetConfig('algod'),\n                ClientManager.getDefaultLocalNetConfig('indexer'),\n                ClientManager.getDefaultLocalNetConfig('kmd'),\n            ];\n        return {\n            algodConfig,\n            indexerConfig,\n            kmdConfig,\n        };\n    }\n    /** Retrieve the algod configuration from environment variables (expects to be called from a Node.js environment)\n     *\n     * Expects `process.env.ALGOD_SERVER` to be defined, and you can also specify `process.env.ALGOD_PORT` and `process.env.ALGOD_TOKEN`.\n     */\n    static getAlgodConfigFromEnvironment() {\n        if (!process || !process.env) {\n            throw new Error('Attempt to get default algod configuration from a non Node.js context; supply the config instead');\n        }\n        if (!process.env.ALGOD_SERVER) {\n            throw new Error('Attempt to get default algod configuration without specifying ALGOD_SERVER in the environment variables');\n        }\n        return {\n            server: process.env.ALGOD_SERVER,\n            port: process.env.ALGOD_PORT,\n            token: process.env.ALGOD_TOKEN,\n        };\n    }\n    /**\n     * Retrieve the indexer configuration from environment variables (expects to be called from a Node.js environment).\n     *\n     * Expects `process.env.INDEXER_SERVER` to be defined, and you can also specify `process.env.INDEXER_PORT` and `process.env.INDEXER_TOKEN`.\n     */\n    static getIndexerConfigFromEnvironment() {\n        if (!process || !process.env) {\n            throw new Error('Attempt to get default indexer configuration from a non Node.js context; supply the config instead');\n        }\n        if (!process.env.INDEXER_SERVER) {\n            throw new Error('Attempt to get default indexer configuration without specifying INDEXER_SERVER in the environment variables');\n        }\n        return {\n            server: process.env.INDEXER_SERVER,\n            port: process.env.INDEXER_PORT,\n            token: process.env.INDEXER_TOKEN,\n        };\n    }\n    /** Returns the Algorand configuration to point to the free tier of the AlgoNode service.\n     *\n     * @param network Which network to connect to - TestNet or MainNet\n     * @param config Which algod config to return - Algod or Indexer\n     */\n    static getAlgoNodeConfig(network, config) {\n        return {\n            server: `https://${network}-${config === 'algod' ? 'api' : 'idx'}.algonode.cloud/`,\n            port: 443,\n        };\n    }\n    /** Returns the Algorand configuration to point to the default LocalNet.\n     *\n     * @param configOrPort Which algod config to return - algod, kmd, or indexer OR a port number\n     */\n    static getDefaultLocalNetConfig(configOrPort) {\n        return {\n            server: `http://localhost`,\n            port: configOrPort === 'algod' ? 4001 : configOrPort === 'indexer' ? 8980 : configOrPort === 'kmd' ? 4002 : configOrPort,\n            token: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n        };\n    }\n    /**\n     * Returns an algod SDK client that automatically retries on idempotent calls.\n     *\n     * @param config The config of the client\n     * @example AlgoNode (testnet)\n     * ```typescript\n     *  const algod = ClientManager.getAlgodClient(ClientManager.getAlgoNodeConfig('testnet', 'algod'))\n     *  await algod.healthCheck().do()\n     * ```\n     * @example AlgoNode (mainnet)\n     * ```typescript\n     *  const algod = ClientManager.getAlgodClient(ClientManager.getAlgoNodeConfig('mainnet', 'algod'))\n     *  await algod.healthCheck().do()\n     * ```\n     * @example Custom (e.g. default LocalNet)\n     * ```typescript\n     *  const algod = ClientManager.getAlgodClient({server: 'http://localhost', port: '4001', token: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'})\n     *  await algod.healthCheck().do()\n     * ```\n     */\n    static getAlgodClient(config) {\n        const { token, server, port } = config;\n        const tokenHeader = typeof token === 'string' ? { 'X-Algo-API-Token': token } : token ?? {};\n        const httpClientWithRetry = new AlgoHttpClientWithRetry(tokenHeader, server, port);\n        return new algosdk.Algodv2(httpClientWithRetry, server);\n    }\n    /**\n     * Returns an algod SDK client that automatically retries on idempotent calls loaded from environment variables (expects to be called from a Node.js environment).\n     *\n     * @example\n     *  ```typescript\n     *  // Uses process.env.ALGOD_SERVER, process.env.ALGOD_PORT and process.env.ALGOD_TOKEN\n     *  const algod = ClientManager.getAlgodClientFromEnvironment()\n     *  await algod.healthCheck().do()\n     *  ```\n     */\n    static getAlgodClientFromEnvironment() {\n        return ClientManager.getAlgodClient(ClientManager.getAlgodConfigFromEnvironment());\n    }\n    /**\n     * Returns an indexer SDK client that automatically retries on idempotent calls\n     *\n     * @param config The config of the client\n     * @param overrideIntDecoding Override the default int decoding for responses, uses MIXED by default to avoid lost precision for big integers\n     * @example AlgoNode (testnet)\n     * ```typescript\n     *  const indexer = ClientManager.getIndexerClient(ClientManager.getAlgoNodeConfig('testnet', 'indexer'))\n     *  await indexer.makeHealthCheck().do()\n     * ```\n     * @example AlgoNode (mainnet)\n     * ```typescript\n     *  const indexer = ClientManager.getIndexerClient(ClientManager.getAlgoNodeConfig('mainnet', 'indexer'))\n     *  await indexer.makeHealthCheck().do()\n     * ```\n     * @example Custom (e.g. default LocalNet, although we recommend loading this into a .env and using the Default option instead)\n     * ```typescript\n     *  const indexer = ClientManager.getIndexerClient({server: 'http://localhost', port: '8980', token: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'})\n     *  await indexer.makeHealthCheck().do()\n     * ```\n     * @example Override int decoding for responses\n     * ```typescript\n     *  const indexer = ClientManager.getIndexerClient(config, IntDecoding.BIGINT)\n     * ```\n     */\n    static getIndexerClient(config, overrideIntDecoding) {\n        const { token, server, port } = config;\n        const tokenHeader = typeof token === 'string' ? { 'X-Indexer-API-Token': token } : token ?? {};\n        const httpClientWithRetry = new AlgoHttpClientWithRetry(tokenHeader, server, port);\n        const indexer = new Indexer(httpClientWithRetry);\n        // Use mixed int decoding by default so bigints don't have lost precision\n        indexer.setIntEncoding(overrideIntDecoding ?? IntDecoding.MIXED);\n        return indexer;\n    }\n    /**\n     * Returns an indexer SDK client that automatically retries on idempotent calls loaded from environment variables (expects to be called from a Node.js environment).\n     *\n     * @param overrideIntDecoding Override the default int decoding for responses, uses MIXED by default to avoid lost precision for big integers\n     * @example\n     *\n     *  ```typescript\n     *  // Uses process.env.INDEXER_SERVER, process.env.INDEXER_PORT and process.env.INDEXER_TOKEN\n     *  const indexer = ClientManager.getIndexerClientFromEnvironment()\n     *  await indexer.makeHealthCheck().do()\n     *  ```\n     */\n    static getIndexerClientFromEnvironment(overrideIntDecoding) {\n        return ClientManager.getIndexerClient(ClientManager.getIndexerConfigFromEnvironment(), overrideIntDecoding);\n    }\n    /**\n     * Returns a KMD SDK client.\n     *\n     * KMD client allows you to export private keys, which is useful to (for instance) get the default account in a LocalNet network.\n     *\n     * @param config The config for the client\n     * @example Custom (e.g. default LocalNet, although we recommend loading this into a .env and using the Default option instead)\n     * ```typescript\n     *  const kmd = ClientManager.getKmdClient({server: 'http://localhost', port: '4002', token: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'})\n     * ```\n     */\n    static getKmdClient(config) {\n        const { token, server, port } = config;\n        return new Kmd(token, server, port);\n    }\n    /**\n     * Returns a KMD SDK client that automatically retries on idempotent calls loaded from environment variables (expects to be called from a Node.js environment).\n     *\n     * @example\n     *  ```typescript\n     *  // Uses process.env.ALGOD_SERVER, process.env.KMD_PORT (or if not specified: port 4002) and process.env.ALGOD_TOKEN\n     *  const kmd = ClientManager.getKmdClientFromEnvironment()\n     *  ```\n     */\n    static getKmdClientFromEnvironment() {\n        // We can only use Kmd on the LocalNet otherwise it's not exposed so this makes some assumptions\n        // (e.g. same token and server as algod and port 4002 by default)\n        return ClientManager.getKmdClient({ ...ClientManager.getAlgodConfigFromEnvironment(), port: process?.env?.KMD_PORT ?? '4002' });\n    }\n}\n\nexport { ClientManager };\n//# sourceMappingURL=client-manager.mjs.map\n","import algosdk from 'algosdk';\n\n/** Wrapper class to ensure safe, explicit conversion between Algos, Algos and numbers */\nclass AlgoAmount {\n    /** Return the amount as a number in Algos */\n    get microAlgos() {\n        return this.amountInMicroAlgos;\n    }\n    /** Return the amount as a number in Algos */\n    get algos() {\n        return algosdk.microalgosToAlgos(this.amountInMicroAlgos);\n    }\n    constructor(amount) {\n        this.amountInMicroAlgos = 'microAlgos' in amount ? amount.microAlgos : algosdk.algosToMicroalgos(amount.algos);\n    }\n    toString() {\n        return `${this.microAlgos.toLocaleString('en-US')} ALGO${this.microAlgos === 1 ? '' : 's'}`;\n    }\n    /** valueOf allows you to use `AlgoAmount` in comparison operations such as `<` and `>=` etc.,\n     * but it's not recommended to use this to convert to a number, it's much safer to explicitly call\n     * the algos or microAlgos properties\n     */\n    valueOf() {\n        return this.microAlgos;\n    }\n    /** Create a `AlgoAmount` object representing the given number of Algos */\n    static Algos(amount) {\n        return new AlgoAmount({ algos: amount });\n    }\n    /** Create a `AlgoAmount` object representing the given number of Algos */\n    static MicroAlgos(amount) {\n        return new AlgoAmount({ microAlgos: amount });\n    }\n}\n\nexport { AlgoAmount };\n//# sourceMappingURL=amount.mjs.map\n","import algosdk from 'algosdk';\nimport { AlgoAmount } from './types/amount.mjs';\n\nNumber.prototype.microAlgos = function () {\n    return AlgoAmount.MicroAlgos(this);\n};\nNumber.prototype.algos = function () {\n    return AlgoAmount.Algos(this);\n};\n/** Returns an amount of Algos using AlgoAmount\n * @param algos The amount in Algos\n */\nconst algos = (algos) => {\n    return AlgoAmount.Algos(algos);\n};\n/** Returns an amount of Algos using AlgoAmount\n * @param microAlgos The amount in Algos\n */\nconst microAlgos = (microAlgos) => {\n    return AlgoAmount.MicroAlgos(microAlgos);\n};\n/** Returns an amount of Algos to cover standard fees for the given number of transactions using AlgoAmount\n * @param numberOfTransactions The of standard transaction fees to return the amount of ALGOs\n */\nconst transactionFees = (numberOfTransactions) => {\n    return AlgoAmount.MicroAlgos(numberOfTransactions * algosdk.ALGORAND_MIN_TX_FEE);\n};\n\nexport { algos, microAlgos, transactionFees };\n//# sourceMappingURL=amount.mjs.map\n","import algosdk from 'algosdk';\nimport { encodeLease, encodeTransactionNote, sendAtomicTransactionComposer } from '../transaction/transaction.mjs';\n\nvar isTransactionWithSigner = algosdk.isTransactionWithSigner;\nvar encodeAddress = algosdk.encodeAddress;\n/** AlgoKit Composer helps you compose and execute transactions as a transaction group.\n *\n * Note: this class is a new Beta feature and may be subject to change.\n *\n * @beta\n */\nclass AlgokitComposer {\n    /**\n     * Create an `AlgoKitComposer`.\n     * @param params The configuration for this composer\n     */\n    constructor(params) {\n        /** The ATC used to compose the group */\n        this.atc = new algosdk.AtomicTransactionComposer();\n        /** Map of txid to ABI method */\n        this.txnMethodMap = new Map();\n        /** Transactions that have not yet been composed */\n        this.txns = [];\n        /** The default transaction validity window */\n        this.defaultValidityWindow = 10;\n        this.algod = params.algod;\n        const defaultGetSuggestedParams = () => params.algod.getTransactionParams().do();\n        this.getSuggestedParams = params.getSuggestedParams ?? defaultGetSuggestedParams;\n        this.getSigner = params.getSigner;\n        this.defaultValidityWindow = params.defaultValidityWindow ?? this.defaultValidityWindow;\n    }\n    /**\n     * Add a payment transaction to the transaction group.\n     * @param params The payment transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addPayment(params) {\n        this.txns.push({ ...params, type: 'pay' });\n        return this;\n    }\n    /**\n     * Add an asset create transaction to the transaction group.\n     * @param params The asset create transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addAssetCreate(params) {\n        this.txns.push({ ...params, type: 'assetCreate' });\n        return this;\n    }\n    /**\n     * Add an asset config transaction to the transaction group.\n     * @param params The asset config transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addAssetConfig(params) {\n        this.txns.push({ ...params, type: 'assetConfig' });\n        return this;\n    }\n    /**\n     * Add an asset freeze transaction to the transaction group.\n     * @param params The asset freeze transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addAssetFreeze(params) {\n        this.txns.push({ ...params, type: 'assetFreeze' });\n        return this;\n    }\n    /**\n     * Add an asset destroy transaction to the transaction group.\n     * @param params The asset destroy transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addAssetDestroy(params) {\n        this.txns.push({ ...params, type: 'assetDestroy' });\n        return this;\n    }\n    /**\n     * Add an asset transfer transaction to the transaction group.\n     * @param params The asset transfer transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addAssetTransfer(params) {\n        this.txns.push({ ...params, type: 'assetTransfer' });\n        return this;\n    }\n    /**\n     * Add an asset opt-in transaction to the transaction group.\n     * @param params The asset opt-in transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addAssetOptIn(params) {\n        this.txns.push({ ...params, type: 'assetOptIn' });\n        return this;\n    }\n    /**\n     * Add an application call transaction to the transaction group.\n     *\n     * Note: we recommend using app clients to make it easier to make app calls.\n     * @param params The application call transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addAppCall(params) {\n        this.txns.push({ ...params, type: 'appCall' });\n        return this;\n    }\n    /**\n     * Add an ABI method application call transaction to the transaction group.\n     *\n     * Note: we recommend using app clients to make it easier to make app calls.\n     * @param params The ABI method application call transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addMethodCall(params) {\n        this.txns.push({ ...params, type: 'methodCall' });\n        return this;\n    }\n    /**\n     * Add an online key registration transaction to the transaction group.\n     * @param params The online key registration transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addOnlineKeyRegistration(params) {\n        this.txns.push({ ...params, type: 'keyReg' });\n        return this;\n    }\n    /**\n     * Add the transactions within an `AtomicTransactionComposer` to the transaction group.\n     * @param atc The `AtomicTransactionComposer` to build transactions from and add to the group\n     * @returns The composer so you can chain method calls\n     */\n    addAtc(atc) {\n        this.txns.push({ atc, type: 'atc' });\n        return this;\n    }\n    buildAtc(atc) {\n        const group = atc.buildGroup();\n        const txnWithSigners = group.map((ts) => {\n            ts.txn.group = undefined;\n            return ts;\n        });\n        const method = atc['methodCalls'].get(group.length - 1);\n        if (method)\n            this.txnMethodMap.set(txnWithSigners.at(-1).txn.txID(), method);\n        return txnWithSigners;\n    }\n    commonTxnBuildStep(params, txn, suggestedParams) {\n        if (params.lease)\n            txn.addLease(encodeLease(params.lease));\n        if (params.rekeyTo)\n            txn.addRekey(params.rekeyTo);\n        if (params.note)\n            txn.note = encodeTransactionNote(params.note);\n        if (params.firstValidRound) {\n            txn.firstRound = Number(params.firstValidRound);\n        }\n        if (params.lastValidRound) {\n            txn.lastRound = Number(params.lastValidRound);\n        }\n        else {\n            txn.lastRound = txn.firstRound + (params.validityWindow ?? this.defaultValidityWindow);\n        }\n        if (params.staticFee !== undefined && params.extraFee !== undefined) {\n            throw Error('Cannot set both staticFee and extraFee');\n        }\n        if (params.staticFee !== undefined) {\n            txn.fee = params.staticFee.microAlgos;\n        }\n        else {\n            txn.fee = txn.estimateSize() * suggestedParams.fee || algosdk.ALGORAND_MIN_TX_FEE;\n            if (params.extraFee)\n                txn.fee += params.extraFee.microAlgos;\n        }\n        txn.flatFee = true;\n        if (params.maxFee !== undefined && txn.fee > params.maxFee.microAlgos) {\n            throw Error(`Transaction fee ${txn.fee} is greater than maxFee ${params.maxFee}`);\n        }\n        return txn;\n    }\n    async buildMethodCall(params, suggestedParams) {\n        const methodArgs = [];\n        const isAbiValue = (x) => {\n            if (Array.isArray(x))\n                return x.length == 0 || x.every(isAbiValue);\n            return ['boolean', 'number', 'bigint', 'string', 'Uint8Array'].includes(typeof x);\n        };\n        for (const arg of params.args ?? []) {\n            if (isAbiValue(arg)) {\n                methodArgs.push(arg);\n                continue;\n            }\n            if (isTransactionWithSigner(arg)) {\n                methodArgs.push(arg);\n                continue;\n            }\n            if ('method' in arg) {\n                const tempTxnWithSigners = await this.buildMethodCall(arg, suggestedParams);\n                methodArgs.push(...tempTxnWithSigners);\n                continue;\n            }\n            const txn = await arg;\n            methodArgs.push({\n                txn,\n                signer: params.signer\n                    ? 'signer' in params.signer\n                        ? params.signer.signer\n                        : params.signer\n                    : this.getSigner(encodeAddress(txn.from.publicKey)),\n            });\n        }\n        const methodAtc = new algosdk.AtomicTransactionComposer();\n        const appID = Number(params.appId || 0);\n        methodAtc.addMethodCall({\n            appID,\n            sender: params.sender,\n            suggestedParams,\n            onComplete: params.onComplete,\n            appAccounts: params.accountReferences,\n            appForeignApps: params.appReferences?.map((x) => Number(x)),\n            appForeignAssets: params.assetReferences?.map((x) => Number(x)),\n            approvalProgram: params.approvalProgram,\n            clearProgram: params.clearProgram,\n            extraPages: params.extraPages,\n            numLocalInts: params.schema?.localUints || (appID === 0 ? 0 : undefined),\n            numLocalByteSlices: params.schema?.localByteSlices || (appID === 0 ? 0 : undefined),\n            numGlobalInts: params.schema?.globalUints || (appID === 0 ? 0 : undefined),\n            numGlobalByteSlices: params.schema?.globalByteSlices || (appID === 0 ? 0 : undefined),\n            method: params.method,\n            signer: params.signer ? ('signer' in params.signer ? params.signer.signer : params.signer) : this.getSigner(params.sender),\n            methodArgs: methodArgs,\n            // note, lease, and rekeyTo are set in the common build step\n            note: undefined,\n            lease: undefined,\n            rekeyTo: undefined,\n        });\n        // Run the actual method call txn through the common build step to set fees and validity rounds\n        const group = methodAtc.buildGroup();\n        const methodIdx = group.length - 1;\n        group[methodIdx].txn = this.commonTxnBuildStep(params, group[methodIdx].txn, suggestedParams);\n        return this.buildAtc(methodAtc);\n    }\n    buildPayment(params, suggestedParams) {\n        const txn = algosdk.makePaymentTxnWithSuggestedParamsFromObject({\n            from: params.sender,\n            to: params.receiver,\n            amount: params.amount.microAlgos,\n            closeRemainderTo: params.closeRemainderTo,\n            suggestedParams,\n        });\n        return this.commonTxnBuildStep(params, txn, suggestedParams);\n    }\n    buildAssetCreate(params, suggestedParams) {\n        const txn = algosdk.makeAssetCreateTxnWithSuggestedParamsFromObject({\n            from: params.sender,\n            total: params.total,\n            decimals: params.decimals ?? 0,\n            assetName: params.assetName,\n            unitName: params.unitName,\n            assetURL: params.url,\n            defaultFrozen: params.defaultFrozen ?? false,\n            assetMetadataHash: params.metadataHash,\n            manager: params.manager,\n            reserve: params.reserve,\n            freeze: params.freeze,\n            clawback: params.clawback,\n            suggestedParams,\n        });\n        return this.commonTxnBuildStep(params, txn, suggestedParams);\n    }\n    buildAssetConfig(params, suggestedParams) {\n        const txn = algosdk.makeAssetConfigTxnWithSuggestedParamsFromObject({\n            from: params.sender,\n            assetIndex: Number(params.assetId),\n            suggestedParams,\n            manager: params.manager,\n            reserve: params.reserve,\n            freeze: params.freeze,\n            clawback: params.clawback,\n            strictEmptyAddressChecking: false,\n        });\n        return this.commonTxnBuildStep(params, txn, suggestedParams);\n    }\n    buildAssetDestroy(params, suggestedParams) {\n        const txn = algosdk.makeAssetDestroyTxnWithSuggestedParamsFromObject({\n            from: params.sender,\n            assetIndex: Number(params.assetId),\n            suggestedParams,\n        });\n        return this.commonTxnBuildStep(params, txn, suggestedParams);\n    }\n    buildAssetFreeze(params, suggestedParams) {\n        const txn = algosdk.makeAssetFreezeTxnWithSuggestedParamsFromObject({\n            from: params.sender,\n            assetIndex: Number(params.assetId),\n            freezeTarget: params.account,\n            freezeState: params.frozen,\n            suggestedParams,\n        });\n        return this.commonTxnBuildStep(params, txn, suggestedParams);\n    }\n    buildAssetTransfer(params, suggestedParams) {\n        const txn = algosdk.makeAssetTransferTxnWithSuggestedParamsFromObject({\n            from: params.sender,\n            to: params.receiver,\n            assetIndex: Number(params.assetId),\n            amount: params.amount,\n            suggestedParams,\n            closeRemainderTo: params.closeAssetTo,\n            revocationTarget: params.clawbackTarget,\n        });\n        return this.commonTxnBuildStep(params, txn, suggestedParams);\n    }\n    buildAppCall(params, suggestedParams) {\n        const sdkParams = {\n            from: params.sender,\n            suggestedParams,\n            onComplete: params.onComplete,\n            approvalProgram: params.approvalProgram,\n            clearProgram: params.clearProgram,\n            appArgs: params.args,\n            accounts: params.accountReferences,\n            foreignApps: params.appReferences?.map((x) => Number(x)),\n            foreignAssets: params.assetReferences?.map((x) => Number(x)),\n            extraPages: params.extraPages,\n            numLocalInts: params.schema?.localUints || 0,\n            numLocalByteSlices: params.schema?.localByteSlices || 0,\n            numGlobalInts: params.schema?.globalUints || 0,\n            numGlobalByteSlices: params.schema?.globalByteSlices || 0,\n        };\n        let txn;\n        const onComplete = params.onComplete || algosdk.OnApplicationComplete.NoOpOC;\n        if (!params.appId) {\n            if (params.approvalProgram === undefined || params.clearProgram === undefined) {\n                throw new Error('approvalProgram and clearProgram are required for application creation');\n            }\n            txn = algosdk.makeApplicationCreateTxnFromObject({\n                ...sdkParams,\n                onComplete,\n                approvalProgram: params.approvalProgram,\n                clearProgram: params.clearProgram,\n            });\n        }\n        txn = algosdk.makeApplicationCallTxnFromObject({ ...sdkParams, onComplete, appIndex: Number(params.appId || 0) });\n        return this.commonTxnBuildStep(params, txn, suggestedParams);\n    }\n    buildKeyReg(params, suggestedParams) {\n        const txn = algosdk.makeKeyRegistrationTxnWithSuggestedParams(params.sender, undefined, params.voteKey, params.selectionKey, Number(params.voteFirst), Number(params.voteLast), Number(params.voteKeyDilution), suggestedParams, undefined, false, params.stateProofKey);\n        return this.commonTxnBuildStep(params, txn, suggestedParams);\n    }\n    async buildTxn(txn, suggestedParams) {\n        if (txn.type === 'txnWithSigner') {\n            return [txn];\n        }\n        if (txn.type === 'atc') {\n            return this.buildAtc(txn.atc);\n        }\n        if (txn.type === 'methodCall') {\n            return await this.buildMethodCall(txn, suggestedParams);\n        }\n        const signer = txn.signer ? ('signer' in txn.signer ? txn.signer.signer : txn.signer) : this.getSigner(txn.sender);\n        switch (txn.type) {\n            case 'pay': {\n                const payment = this.buildPayment(txn, suggestedParams);\n                return [{ txn: payment, signer }];\n            }\n            case 'assetCreate': {\n                const assetCreate = this.buildAssetCreate(txn, suggestedParams);\n                return [{ txn: assetCreate, signer }];\n            }\n            case 'appCall': {\n                const appCall = this.buildAppCall(txn, suggestedParams);\n                return [{ txn: appCall, signer }];\n            }\n            case 'assetConfig': {\n                const assetConfig = this.buildAssetConfig(txn, suggestedParams);\n                return [{ txn: assetConfig, signer }];\n            }\n            case 'assetDestroy': {\n                const assetDestroy = this.buildAssetDestroy(txn, suggestedParams);\n                return [{ txn: assetDestroy, signer }];\n            }\n            case 'assetFreeze': {\n                const assetFreeze = this.buildAssetFreeze(txn, suggestedParams);\n                return [{ txn: assetFreeze, signer }];\n            }\n            case 'assetTransfer': {\n                const assetTransfer = this.buildAssetTransfer(txn, suggestedParams);\n                return [{ txn: assetTransfer, signer }];\n            }\n            case 'assetOptIn': {\n                const assetTransfer = this.buildAssetTransfer({ ...txn, receiver: txn.sender, amount: 0n }, suggestedParams);\n                return [{ txn: assetTransfer, signer }];\n            }\n            case 'keyReg': {\n                const keyReg = this.buildKeyReg(txn, suggestedParams);\n                return [{ txn: keyReg, signer }];\n            }\n            default:\n                throw Error(`Unsupported txn type`);\n        }\n    }\n    /**\n     * Compose all of the transactions in a single atomic transaction group and an atomic transaction composer.\n     *\n     * You can then use the transactions standalone, or use the composer to execute or simulate the transactions.\n     * @returns The built atomic transaction composer and the transactions\n     */\n    async build() {\n        if (this.atc.getStatus() === algosdk.AtomicTransactionComposerStatus.BUILDING) {\n            const suggestedParams = await this.getSuggestedParams();\n            const txnWithSigners = [];\n            for (const txn of this.txns) {\n                txnWithSigners.push(...(await this.buildTxn(txn, suggestedParams)));\n            }\n            txnWithSigners.forEach((ts) => {\n                this.atc.addTransaction(ts);\n            });\n            const methodCalls = new Map();\n            txnWithSigners.forEach((ts, idx) => {\n                const method = this.txnMethodMap.get(ts.txn.txID());\n                if (method)\n                    methodCalls.set(idx, method);\n            });\n            this.atc['methodCalls'] = methodCalls;\n        }\n        return { atc: this.atc, transactions: this.atc.buildGroup() };\n    }\n    /**\n     * Rebuild the group, discarding any previously built transactions.\n     * This will potentially cause new signers and suggested params to be used if the callbacks return a new value compared to the first build.\n     * @returns The newly built atomic transaction composer and the transactions\n     */\n    async rebuild() {\n        this.atc = new algosdk.AtomicTransactionComposer();\n        return await this.build();\n    }\n    /**\n     * Compose the atomic transaction group and send it to the network\n     * @param params The parameters to control execution with\n     * @returns The execution result\n     */\n    async execute(params) {\n        const group = (await this.build()).transactions;\n        let waitRounds = params?.maxRoundsToWaitForConfirmation;\n        if (waitRounds === undefined) {\n            const lastRound = group.reduce((max, txn) => Math.max(txn.txn.lastRound, max), 0);\n            const { firstRound } = await this.getSuggestedParams();\n            waitRounds = lastRound - firstRound + 1;\n        }\n        return await sendAtomicTransactionComposer({\n            atc: this.atc,\n            sendParams: { suppressLog: params?.suppressLog, maxRoundsToWaitForConfirmation: waitRounds },\n        }, this.algod);\n    }\n}\n\nexport { AlgokitComposer as default };\n//# sourceMappingURL=composer.mjs.map\n","import algosdk from 'algosdk';\nimport { SigningAccount, MultisigAccount, DISPENSER_ACCOUNT } from './account.mjs';\nimport { KmdAccountManager } from './kmd-account-manager.mjs';\n\nvar LogicSigAccount = algosdk.LogicSigAccount;\nvar AccountInformationModel = algosdk.modelsv2.Account;\nconst memoize = (fn) => {\n    const cache = new Map();\n    const cached = function (val) {\n        return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);\n    };\n    cached.cache = cache;\n    return cached;\n};\n/**\n * Returns a `TransactionSigner` for the given account that can sign a transaction.\n * This function has memoization, so will return the same transaction signer for a given account.\n * @param account An account that can sign a transaction\n * @returns A transaction signer\n */\nconst getAccountTransactionSigner = memoize(function (account) {\n    return 'signer' in account\n        ? account.signer\n        : 'lsig' in account\n            ? algosdk.makeLogicSigAccountTransactionSigner(account)\n            : algosdk.makeBasicAccountTransactionSigner(account);\n});\n/** Creates and keeps track of signing accounts that can sign transactions for a sending address. */\nclass AccountManager {\n    /**\n     * Create a new account manager.\n     * @param clientManager The ClientManager client to use for algod and kmd clients\n     * @example Create a new account manager\n     * ```typescript\n     * const accountManager = new AccountManager(clientManager)\n     * ```\n     */\n    constructor(clientManager) {\n        this._accounts = {};\n        this._clientManager = clientManager;\n        this._kmdAccountManager = new KmdAccountManager(clientManager);\n    }\n    /** KMD account manager that allows you to easily get and create accounts using KMD. */\n    get kmd() {\n        return this._kmdAccountManager;\n    }\n    /**\n     * Sets the default signer to use if no other signer is specified.\n     *\n     * If this isn't set an a transaction needs signing for a given sender\n     * then an error will be thrown from `getSigner` / `getAccount`.\n     * @param signer The signer to use, either a `TransactionSigner` or a `TransactionSignerAccount`\n     * @example\n     * ```typescript\n     * const signer = accountManager.random() // Can be anything that returns a `algosdk.TransactionSigner` or `TransactionSignerAccount`\n     * accountManager.setDefaultSigner(signer)\n     *\n     * // When signing a transaction, if there is no signer registered for the sender then the default signer will be used\n     * const signer = accountManager.getSigner(\"{SENDERADDRESS}\")\n     * ```\n     * @returns The `AccountManager` so method calls can be chained\n     */\n    setDefaultSigner(signer) {\n        this._defaultSigner = 'signer' in signer ? signer.signer : signer;\n        return this;\n    }\n    /**\n     * Records the given account (that can sign) against the address of the provided account for later\n     * retrieval and returns a `TransactionSignerAccount` along with the original account in an `account` property.\n     */\n    signerAccount(account) {\n        const acc = {\n            addr: 'addr' in account ? account.addr : account.address(),\n            signer: getAccountTransactionSigner(account),\n        };\n        this._accounts[acc.addr] = acc;\n        return { ...acc, account };\n    }\n    /**\n     * Tracks the given account for later signing.\n     *\n     * Note: If you are generating accounts via the various methods on `AccountManager`\n     * (like `random`, `fromMnemonic`, `logicsig`, etc.) then they automatically get tracked.\n     * @param account The account to register, which can be a `TransactionSignerAccount` or\n     *  a `algosdk.Account`, `algosdk.LogicSigAccount`, `SigningAccount` or `MultisigAccount`\n     * @example\n     * ```typescript\n     * const accountManager = new AccountManager(clientManager)\n     *  .setSignerFromAccount(algosdk.generateAccount())\n     *  .setSignerFromAccount(new algosdk.LogicSigAccount(program, args))\n     *  .setSignerFromAccount(new SigningAccount(mnemonic, sender))\n     *  .setSignerFromAccount(new MultisigAccount({version: 1, threshold: 1, addrs: [\"ADDRESS1...\", \"ADDRESS2...\"]}, [account1, account2]))\n     *  .setSignerFromAccount({addr: \"SENDERADDRESS\", signer: transactionSigner})\n     * ```\n     * @returns The `AccountManager` instance for method chaining\n     */\n    setSignerFromAccount(account) {\n        this.signerAccount(account);\n        return this;\n    }\n    /**\n     * Tracks the given `algosdk.TransactionSigner` against the given sender address for later signing.\n     * @param sender The sender address to use this signer for\n     * @param signer The `algosdk.TransactionSigner` to sign transactions with for the given sender\n     * @example\n     * ```typescript\n     * const accountManager = new AccountManager(clientManager)\n     *  .setSigner(\"SENDERADDRESS\", transactionSigner)\n     * ```\n     * @returns The `AccountManager` instance for method chaining\n     */\n    setSigner(sender, signer) {\n        this._accounts[sender] = { addr: sender, signer };\n        return this;\n    }\n    /**\n     * Returns the `TransactionSigner` for the given sender address, ready to sign a transaction for that sender.\n     *\n     * If no signer has been registered for that address then the default signer is used if registered and\n     * if not then an error is thrown.\n     *\n     * @param sender The sender address\n     * @example\n     * ```typescript\n     * const signer = accountManager.getSigner(\"SENDERADDRESS\")\n     * ```\n     * @returns The `TransactionSigner` or throws an error if not found and no default signer is set\n     */\n    getSigner(sender) {\n        const signer = this._accounts[sender]?.signer ?? this._defaultSigner;\n        if (!signer)\n            throw new Error(`No signer found for address ${sender}`);\n        return signer;\n    }\n    /**\n     * Returns the `TransactionSignerAccount` for the given sender address.\n     *\n     * If no signer has been registered for that address then an error is thrown.\n     * @param sender The sender address\n     * @example\n     * ```typescript\n     * const account = accountManager.random()\n     * const sender = account.addr\n     * // ...\n     * // Returns the `TransactionSignerAccount` for `sender` that has previously been registered\n     * const account = accountManager.getAccount(sender)\n     * ```\n     * @returns The `TransactionSignerAccount` or throws an error if not found\n     */\n    getAccount(sender) {\n        const account = this._accounts[sender];\n        if (!account)\n            throw new Error(`No signer found for address ${sender}`);\n        return account;\n    }\n    /**\n     * Returns the given sender account's current status, balance and spendable amounts.\n     *\n     * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddress)\n     * @example\n     * ```typescript\n     * const address = \"XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA\";\n     * const accountInfo = await accountManager.getInformation(address);\n     * ```\n     *\n     * @param sender The account / address to look up\n     * @returns The account information\n     */\n    async getInformation(sender) {\n        const account = AccountInformationModel.from_obj_for_encoding(await this._clientManager.algod.accountInformation(typeof sender === 'string' ? sender : sender.addr).do());\n        return {\n            ...account,\n            // None of these can practically overflow 2^53\n            amount: Number(account.amount),\n            amountWithoutPendingRewards: Number(account.amountWithoutPendingRewards),\n            minBalance: Number(account.minBalance),\n            pendingRewards: Number(account.pendingRewards),\n            rewards: Number(account.rewards),\n            round: Number(account.round),\n            totalAppsOptedIn: Number(account.totalAppsOptedIn),\n            totalAssetsOptedIn: Number(account.totalAssetsOptedIn),\n            totalCreatedApps: Number(account.totalCreatedApps),\n            totalCreatedAssets: Number(account.totalCreatedAssets),\n            appsTotalExtraPages: account.appsTotalExtraPages ? Number(account.appsTotalExtraPages) : undefined,\n            rewardBase: account.rewardBase ? Number(account.rewardBase) : undefined,\n            totalBoxBytes: account.totalBoxBytes ? Number(account.totalBoxBytes) : undefined,\n            totalBoxes: account.totalBoxes ? Number(account.totalBoxes) : undefined,\n        };\n    }\n    /**\n     * Returns the given sender account's asset holding for a given asset.\n     *\n     * @example\n     * ```typescript\n     * const address = \"XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA\";\n     * const assetId = 123345;\n     * const accountInfo = await accountManager.getAccountAssetInformation(address, assetId);\n     * ```\n     *\n     * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddressassetsasset-id)\n     * @param sender The address of the sender/account to look up\n     * @param assetId The ID of the asset to return a holding for\n     * @returns The account asset holding information\n     */\n    async getAssetInformation(sender, assetId) {\n        const info = await this._clientManager.algod\n            .accountAssetInformation(typeof sender === 'string' ? sender : sender.addr, Number(assetId))\n            .do();\n        return {\n            assetId: BigInt(assetId),\n            balance: BigInt(info['asset-holding']['amount']),\n            frozen: info['asset-holding']['is-frozen'] === 'true',\n            round: BigInt(info['round']),\n        };\n    }\n    /**\n     * Tracks and returns an Algorand account with secret key loaded (i.e. that can sign transactions) by taking the mnemonic secret.\n     *\n     * @example\n     * ```typescript\n     * const account = await account.fromMnemonic(\"mnemonic secret ...\")\n     * const rekeyedAccount = await account.fromMnemonic(\"mnemonic secret ...\", \"SENDERADDRESS...\")\n     * ```\n     * @param mnemonicSecret The mnemonic secret representing the private key of an account; **Note: Be careful how the mnemonic is handled**,\n     *  never commit it into source control and ideally load it from the environment (ideally via a secret storage service) rather than the file system.\n     * @param sender The optional sender address to use this signer for (aka a rekeyed account)\n     * @returns The account\n     */\n    fromMnemonic(mnemonicSecret, sender) {\n        const account = algosdk.mnemonicToSecretKey(mnemonicSecret);\n        return this.signerAccount(new SigningAccount(account, sender));\n    }\n    /**\n     * Tracks and returns an Algorand account that is a rekeyed version of the given account to a new sender.\n     *\n     * @example\n     * ```typescript\n     * const account = await account.fromMnemonic(\"mnemonic secret ...\")\n     * const rekeyedAccount = await account.rekeyed(account, \"SENDERADDRESS...\")\n     * ```\n     * @param account The account to use as the signer for this new rekeyed account\n     * @param sender The sender address to use as the new sender\n     * @returns The account\n     */\n    rekeyed(account, sender) {\n        return this.signerAccount({ addr: sender, signer: account.signer });\n    }\n    /**\n     * Tracks and returns an Algorand account with private key loaded by convention from environment variables based on the given name identifier.\n     *\n     * Note: This function expects to run in a Node.js environment.\n     *\n     * ## Convention:\n     * * **Non-LocalNet:** will load process.env['\\{NAME\\}_MNEMONIC'] as a mnemonic secret; **Note: Be careful how the mnemonic is handled**,\n     *  never commit it into source control and ideally load it via a secret storage service rather than the file system.\n     *   If process.env['\\{NAME\\}_SENDER'] is defined then it will use that for the sender address (i.e. to support rekeyed accounts)\n     * * **LocalNet:** will load the account from a KMD wallet called \\{NAME\\} and if that wallet doesn't exist it will create it and fund the account for you\n     *\n     * This allows you to write code that will work seamlessly in production and local development (LocalNet) without manual config locally (including when you reset the LocalNet).\n     *\n     * @example Default\n     *\n     * If you have a mnemonic secret loaded into `process.env.MY_ACCOUNT_MNEMONIC` then you can call the following to get that private key loaded into an account object:\n     * ```typescript\n     * const account = await account.fromEnvironment('MY_ACCOUNT', algod)\n     * ```\n     *\n     * If that code runs against LocalNet then a wallet called `MY_ACCOUNT` will automatically be created with an account that is automatically funded with 1000 (default) ALGOs from the default LocalNet dispenser.\n     * If not running against LocalNet then it will use proces.env.MY_ACCOUNT_MNEMONIC as the private key and (if present) process.env.MY_ACCOUNT_SENDER as the sender address.\n     *\n     * @param name The name identifier of the account\n     * @param fundWith The optional amount to fund the account with when it gets created (when targeting LocalNet), if not specified then 1000 Algos will be funded from the dispenser account\n     * @returns The account\n     */\n    async fromEnvironment(name, fundWith) {\n        if (!process || !process.env) {\n            throw new Error('Attempt to get account with private key from a non Node.js context; this is not supported!');\n        }\n        const accountMnemonic = process.env[`${name.toUpperCase()}_MNEMONIC`];\n        const sender = process.env[`${name.toUpperCase()}_SENDER`];\n        if (accountMnemonic) {\n            const signer = algosdk.mnemonicToSecretKey(accountMnemonic);\n            return this.signerAccount(new SigningAccount(signer, sender));\n        }\n        if (await this._clientManager.isLocalNet()) {\n            const account = await this._kmdAccountManager.getOrCreateWalletAccount(name, fundWith);\n            return this.signerAccount(account.account);\n        }\n        throw new Error(`Missing environment variable ${name.toUpperCase()}_MNEMONIC when looking for account ${name}`);\n    }\n    /**\n     * Tracks and returns an Algorand account with private key loaded from the given KMD wallet (identified by name).\n     *\n     * @param name The name of the wallet to retrieve an account from\n     * @param predicate An optional filter to use to find the account (otherwise it will return a random account from the wallet)\n     * @param sender The optional sender address to use this signer for (aka a rekeyed account)\n     * @example Get default funded account in a LocalNet\n     *\n     * ```typescript\n     * const defaultDispenserAccount = await account.fromKmd('unencrypted-default-wallet',\n     *   a => a.status !== 'Offline' && a.amount > 1_000_000_000\n     * )\n     * ```\n     * @returns The account\n     */\n    async fromKmd(name, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    predicate, sender) {\n        const account = await this.kmd.getWalletAccount(name, predicate, sender);\n        if (!account)\n            throw new Error(`Unable to find KMD account ${name}${predicate ? ' with predicate' : ''}`);\n        return this.signerAccount(account.account);\n    }\n    /**\n     * Tracks and returns an account that supports partial or full multisig signing.\n     *\n     * @example\n     * ```typescript\n     * const account = await account.multisig({version: 1, threshold: 1, addrs: [\"ADDRESS1...\", \"ADDRESS2...\"]},\n     *  await account.fromEnvironment('ACCOUNT1'))\n     * ```\n     * @param multisigParams The parameters that define the multisig account\n     * @param signingAccounts The signers that are currently present\n     * @returns A multisig account wrapper\n     */\n    multisig(multisigParams, signingAccounts) {\n        return this.signerAccount(new MultisigAccount(multisigParams, signingAccounts));\n    }\n    /**\n     * Tracks and returns an account that represents a logic signature.\n     *\n     * @example\n     * ```typescript\n     * const account = await account.logicsig(program, [new Uint8Array(3, ...)])\n     * ```\n     * @param program The bytes that make up the compiled logic signature\n     * @param args The (binary) arguments to pass into the logic signature\n     * @returns A logic signature account wrapper\n     */\n    logicsig(program, args) {\n        return this.signerAccount(new LogicSigAccount(program, args));\n    }\n    /**\n     * Tracks and returns a new, random Algorand account with secret key loaded.\n     *\n     * @example\n     * ```typescript\n     * const account = await account.random()\n     * ```\n     * @returns The account\n     */\n    random() {\n        return this.signerAccount(algosdk.generateAccount());\n    }\n    /**\n     * Returns an account (with private key loaded) that can act as a dispenser from\n     * environment variables, or against default LocalNet if no environment variables present.\n     *\n     * Note: requires a Node.js environment to execute.\n     *\n     * If present, it will load the account mnemonic stored in process.env.DISPENSER_MNEMONIC and optionally\n     * process.env.DISPENSER_SENDER if it's a rekeyed account.\n     *\n     * @example\n     * ```typescript\n     * const account = await account.dispenserFromEnvironment()\n     * ```\n     *\n     * @returns The account\n     */\n    async dispenserFromEnvironment() {\n        if (!process || !process.env) {\n            throw new Error('Attempt to get dispenser from environment from a non Node.js context; this is not supported!');\n        }\n        return process.env[`${DISPENSER_ACCOUNT.toUpperCase()}_MNEMONIC`]\n            ? await this.fromEnvironment(DISPENSER_ACCOUNT)\n            : await this.localNetDispenser();\n    }\n    /**\n     * Returns an Algorand account with private key loaded for the default LocalNet dispenser account (that can be used to fund other accounts).\n     *\n     * @example\n     * ```typescript\n     * const account = await account.localNetDispenser()\n     * ```\n     * @returns The account\n     */\n    async localNetDispenser() {\n        const dispenser = await this._kmdAccountManager.getLocalNetDispenserAccount();\n        return this.signerAccount(dispenser.account);\n    }\n}\n\nexport { AccountManager, getAccountTransactionSigner };\n//# sourceMappingURL=account-manager.mjs.map\n","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/scripts/scheduler/getBoxReferenceApp.ts\nimport algosdk from \"algosdk\";\nvar getBoxReferenceApp = (appPoolId, taskAppId) => {\n  return {\n    appIndex: appPoolId,\n    name: new Uint8Array(Buffer.concat([Buffer.from(\"t\", \"ascii\"), algosdk.bigIntToBytes(taskAppId, 8)]))\n  };\n};\nvar getBoxReferenceApp_default = getBoxReferenceApp;\n\n// src/scripts/scheduler/getBoxReferenceUser.ts\nvar getBoxReferenceUser = (appPoolId, userAddress) => {\n  return {\n    appIndex: appPoolId,\n    name: new Uint8Array(Buffer.concat([Buffer.from(\"u\", \"ascii\"), Buffer.from(userAddress.publicKey)]))\n  };\n};\nvar getBoxReferenceUser_default = getBoxReferenceUser;\n\n// src/scripts/scheduler/getPoolManagerApp.ts\nvar getPoolManagerApp = (env) => {\n  switch (env) {\n    case \"mainnet-v1.0\":\n      return 1765620242;\n    case \"testnet-v1.0\":\n      return 643872805;\n    case \"voitest-v1\":\n      return 40433700;\n    case \"sandnet-v1\":\n    default:\n      return 1114;\n  }\n};\nvar getPoolManagerApp_default = getPoolManagerApp;\n\n// src/scripts/scheduler/parseBoxData.ts\nimport algosdk2 from \"algosdk\";\nvar parseBoxData = (input) => {\n  if (input.length !== 24) {\n    throw new Error(`Box has wrong length: ${input.length} ${Buffer.from(input).toString(\"hex\")}`);\n  }\n  const ret = {\n    funds: Number(algosdk2.decodeUint64(input.subarray(0, 8), \"safe\")),\n    app: Number(algosdk2.decodeUint64(input.subarray(8, 16), \"safe\")),\n    fee: Number(algosdk2.decodeUint64(input.subarray(16, 24), \"safe\"))\n  };\n  return ret;\n};\nvar parseBoxData_default = parseBoxData;\n\n// contracts/clients/BiatecTaskManagerClient.ts\nimport * as algokit from \"@algorandfoundation/algokit-utils\";\nimport { AtomicTransactionComposer, modelsv2 } from \"algosdk\";\nvar APP_SPEC = {\n  \"hints\": {\n    \"createApplication()void\": {\n      \"call_config\": {\n        \"no_op\": \"CREATE\"\n      }\n    },\n    \"updateApplication(string)void\": {\n      \"call_config\": {\n        \"update_application\": \"CALL\"\n      }\n    },\n    \"bootstrap(pay,uint64)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"registerTask(pay,(uint64,uint64,uint64))void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"unregisterTask(uint64,uint64)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"executeTask(appl)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"fundTask(uint64,txn)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"changeTaskFee(uint64,uint64)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"unfundTask(uint64,uint64)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"payment(address,uint64,address,string)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"assetTransfer(address,uint64,uint64,address,string)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"sendOfflineKeyRegistration()void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    }\n  },\n  \"bare_call_config\": {\n    \"no_op\": \"NEVER\",\n    \"opt_in\": \"NEVER\",\n    \"close_out\": \"NEVER\",\n    \"update_application\": \"NEVER\",\n    \"delete_application\": \"NEVER\"\n  },\n  \"schema\": {\n    \"local\": {\n      \"declared\": {},\n      \"reserved\": {}\n    },\n    \"global\": {\n      \"declared\": {\n        \"feeAssetId\": {\n          \"type\": \"uint64\",\n          \"key\": \"fa\"\n        },\n        \"depositedFunds\": {\n          \"type\": \"uint64\",\n          \"key\": \"d\"\n        },\n        \"version\": {\n          \"type\": \"bytes\",\n          \"key\": \"scver\"\n        }\n      },\n      \"reserved\": {}\n    }\n  },\n  \"state\": {\n    \"global\": {\n      \"num_byte_slices\": 1,\n      \"num_uints\": 2\n    },\n    \"local\": {\n      \"num_byte_slices\": 0,\n      \"num_uints\": 0\n    }\n  },\n  \"source\": {\n    \"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCgovLyBUaGlzIFRFQUwgd2FzIGdlbmVyYXRlZCBieSBURUFMU2NyaXB0IHYwLjkwLjMKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbnRyYWN0LCBpdHMgcmVzcGVjdGl2ZSBicmFuY2ggd2lsbCBiZSAiKk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCmludCA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCAqY2FsbF9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpjYWxsX1VwZGF0ZUFwcGxpY2F0aW9uICpOT1RfSU1QTEVNRU5URUQgKmNyZWF0ZV9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRAoKKk5PVF9JTVBMRU1FTlRFRDoKCWVycgoKLy8gY3JlYXRlQXBwbGljYXRpb24oKXZvaWQKKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbjoKCS8vIGV4ZWN1dGUgY3JlYXRlQXBwbGljYXRpb24oKXZvaWQKCWNhbGxzdWIgY3JlYXRlQXBwbGljYXRpb24KCWludCAxCglyZXR1cm4KCi8vIGNyZWF0ZUFwcGxpY2F0aW9uKCk6IHZvaWQKLy8KLy8gSW5pdGlhbCBzZXR1cApjcmVhdGVBcHBsaWNhdGlvbjoKCXByb3RvIDAgMAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjM4CgkvLyB0aGlzLnZlcnNpb24udmFsdWUgPSAnQklBVEVDLUNST04tUE9PTC0wMS0wMS0wMScKCWJ5dGUgMHg3MzYzNzY2NTcyIC8vICJzY3ZlciIKCWJ5dGUgMHgwMDE5NDI0OTQxNTQ0NTQzMmQ0MzUyNGY0ZTJkNTA0ZjRmNGMyZDMwMzEyZDMwMzEyZDMwMzEKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIHVwZGF0ZUFwcGxpY2F0aW9uKHN0cmluZyl2b2lkCiphYmlfcm91dGVfdXBkYXRlQXBwbGljYXRpb246CgkvLyB2ZXJzaW9uOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSB1cGRhdGVBcHBsaWNhdGlvbihzdHJpbmcpdm9pZAoJY2FsbHN1YiB1cGRhdGVBcHBsaWNhdGlvbgoJaW50IDEKCXJldHVybgoKLy8gdXBkYXRlQXBwbGljYXRpb24odmVyc2lvbjogc3RyaW5nKTogdm9pZAovLwovLyBDcmVhdG9yIGNhbiB1cGRhdGUgYXBwbGljYXRpb24KLy8gQHBhcmFtIHZlcnNpb24gQXBwIHZlcnNpb24KdXBkYXRlQXBwbGljYXRpb246Cglwcm90byAxIDAKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czo0NgoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjQ3CgkvLyB0aGlzLnZlcnNpb24udmFsdWUgPSB2ZXJzaW9uCglieXRlIDB4NzM2Mzc2NjU3MiAvLyAic2N2ZXIiCglmcmFtZV9kaWcgLTEgLy8gdmVyc2lvbjogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gYm9vdHN0cmFwKHBheSx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX2Jvb3RzdHJhcDoKCS8vIGZlZUFzc2V0SWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIHR4QmFzZURlcG9zaXQ6IHBheQoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnQgcGF5Cgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBib290c3RyYXAocGF5LHVpbnQ2NCl2b2lkCgljYWxsc3ViIGJvb3RzdHJhcAoJaW50IDEKCXJldHVybgoKLy8gYm9vdHN0cmFwKHR4QmFzZURlcG9zaXQ6IFBheVR4biwgZmVlQXNzZXRJZDogQXNzZXRJRCk6IHZvaWQKLy8KLy8gQm9vdHN0cmFwIHRoZSBjb250cmFjdCB0byBvcHRpbiB0byB0aGUgZmVlIGFzc2V0IGFuZCBzZXR1cCBiYXNpYyB2YXJpYWJsZXMKLy8KLy8gQHBhcmFtIHR4QmFzZURlcG9zaXQgRGVwb3NpdCBNQlIKLy8gQHBhcmFtIGZlZUFzc2V0SWQgIEZlZSBhc3NldCBpZApib290c3RyYXA6Cglwcm90byAyIDAKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czo1NwoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjU5CgkvLyB2ZXJpZnlQYXlUeG4odHhCYXNlRGVwb3NpdCwgewoJLy8gICAgICAgcmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICBhbW91bnQ6IHsgZ3JlYXRlclRoYW5FcXVhbFRvOiAwIH0sCgkvLyAgICAgfSkKCS8vIHZlcmlmeSByZWNlaXZlcgoJZnJhbWVfZGlnIC0xIC8vIHR4QmFzZURlcG9zaXQ6IFBheVR4bgoJZ3R4bnMgUmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFtb3VudAoJZnJhbWVfZGlnIC0xIC8vIHR4QmFzZURlcG9zaXQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50CglpbnQgMAoJPj0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjY0CgkvLyB0aGlzLmZlZUFzc2V0SWQudmFsdWUgPSBmZWVBc3NldElkLmlkCglieXRlIDB4NjY2MSAvLyAiZmEiCglmcmFtZV9kaWcgLTIgLy8gZmVlQXNzZXRJZDogQXNzZXRJRAoJYXBwX2dsb2JhbF9wdXQKCgkvLyAqaWYwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6NzcKCS8vIHRoaXMuZmVlQXNzZXRJZC52YWx1ZSA+IDAKCWJ5dGUgMHg2NjYxIC8vICJmYSIKCWFwcF9nbG9iYWxfZ2V0CglpbnQgMAoJPgoJYnogKmlmMF9lbmQKCgkvLyAqaWYwX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjc4CgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICAgIGFzc2V0UmVjZWl2ZXI6IGdsb2JhbHMuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKCS8vICAgICAgICAgYXNzZXRBbW91bnQ6IDAsCgkvLyAgICAgICAgIHhmZXJBc3NldDogQXNzZXRJRC5mcm9tVWludDY0KHRoaXMuZmVlQXNzZXRJZC52YWx1ZSksCgkvLyAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IGF4ZmVyCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6NzkKCS8vIGFzc2V0UmVjZWl2ZXI6IGdsb2JhbHMuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjgwCgkvLyBhc3NldEFtb3VudDogMAoJaW50IDAKCWl0eG5fZmllbGQgQXNzZXRBbW91bnQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czo4MQoJLy8geGZlckFzc2V0OiBBc3NldElELmZyb21VaW50NjQodGhpcy5mZWVBc3NldElkLnZhbHVlKQoJYnl0ZSAweDY2NjEgLy8gImZhIgoJYXBwX2dsb2JhbF9nZXQKCWl0eG5fZmllbGQgWGZlckFzc2V0CgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKKmlmMF9lbmQ6CglyZXRzdWIKCi8vIHJlZ2lzdGVyVGFzayhwYXksKHVpbnQ2NCx1aW50NjQsdWludDY0KSl2b2lkCiphYmlfcm91dGVfcmVnaXN0ZXJUYXNrOgoJLy8gdGFzazogKHVpbnQ2NCx1aW50NjQsdWludDY0KQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAyNAoJPT0KCWFzc2VydAoKCS8vIHJlZ2lzdHJhdGlvbkZlZURlcG9zaXQ6IHBheQoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnQgcGF5Cgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSByZWdpc3RlclRhc2socGF5LCh1aW50NjQsdWludDY0LHVpbnQ2NCkpdm9pZAoJY2FsbHN1YiByZWdpc3RlclRhc2sKCWludCAxCglyZXR1cm4KCi8vIHJlZ2lzdGVyVGFzayhyZWdpc3RyYXRpb25GZWVEZXBvc2l0OiBQYXlUeG4sIHRhc2s6IFRhc2spOiB2b2lkCi8vCi8vIFJlZ2lzdGVyIGEgdGFzayB0byBiZSBleGVjdXRlZAovLyBPbmx5IGFwcCBpdCBzZWxmIGNhbiBjYWxsIHJlZ2lzdGVyIHRhc2sKLy8KLy8gQHBhcmFtIHJlZ2lzdHJhdGlvbkZlZURlcG9zaXQgVGhlIGF4ZmVyIG9yIHBheSB0aGF0IGRlcG9zaXRzIHRoZSBpbml0aWFsIGZ1bmRzCi8vIEBwYXJhbSB0YXNrIFRoZSB0YXNrIG9iamVjdApyZWdpc3RlclRhc2s6Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjk0CgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSB0YXNrLmFwcC5hZGRyZXNzKQoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0yIC8vIHRhc2s6IFRhc2sKCWV4dHJhY3QgOCA4CglidG9pCglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czo5NQoJLy8gYXNzZXJ0KHRhc2suZnVuZHMgPT09IDApCglmcmFtZV9kaWcgLTIgLy8gdGFzazogVGFzawoJZXh0cmFjdCAwIDgKCWJ0b2kKCWludCAwCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6OTcKCS8vIHZlcmlmeVBheVR4bihyZWdpc3RyYXRpb25GZWVEZXBvc2l0LCB7CgkvLyAgICAgICByZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICB9KQoJLy8gdmVyaWZ5IHJlY2VpdmVyCglmcmFtZV9kaWcgLTEgLy8gcmVnaXN0cmF0aW9uRmVlRGVwb3NpdDogUGF5VHhuCglndHhucyBSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxMDAKCS8vIGFzc2VydChyZWdpc3RyYXRpb25GZWVEZXBvc2l0LmFtb3VudCA+IDUwMF8wMDApCglmcmFtZV9kaWcgLTEgLy8gcmVnaXN0cmF0aW9uRmVlRGVwb3NpdDogUGF5VHhuCglndHhucyBBbW91bnQKCWludCA1MDBfMDAwCgk+Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxMDIKCS8vIHRoaXMudGFza3ModGFzay5hcHApLnZhbHVlID0gdGFzawoJYnl0ZSAweDc0IC8vICJ0IgoJZnJhbWVfZGlnIC0yIC8vIHRhc2s6IFRhc2sKCWV4dHJhY3QgOCA4CglidG9pCglpdG9iCgljb25jYXQKCWZyYW1lX2RpZyAtMiAvLyB0YXNrOiBUYXNrCglib3hfcHV0CgoJLy8gKmlmMV9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjEwMwoJLy8gdGhpcy51c2VyMnRhc2tzKHRhc2suYXBwLmNyZWF0b3IpLmV4aXN0cwoJYnl0ZSAweDc1IC8vICJ1IgoJZnJhbWVfZGlnIC0yIC8vIHRhc2s6IFRhc2sKCWV4dHJhY3QgOCA4CglidG9pCglhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCglwb3AKCWNvbmNhdAoJYm94X2xlbgoJc3dhcAoJcG9wCglieiAqaWYxX2Vsc2UKCgkvLyAqaWYxX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjEwNAoJLy8gdGhpcy51c2VyMnRhc2tzKHRhc2suYXBwLmNyZWF0b3IpLnZhbHVlLnB1c2godGFzay5hcHApCglieXRlIDB4NzUgLy8gInUiCglmcmFtZV9kaWcgLTIgLy8gdGFzazogVGFzawoJZXh0cmFjdCA4IDgKCWJ0b2kKCWFwcF9wYXJhbXNfZ2V0IEFwcENyZWF0b3IKCXBvcAoJY29uY2F0CglpbnQgMgoJaW50IDAKCWJveF9leHRyYWN0CglmcmFtZV9kaWcgLTIgLy8gdGFzazogVGFzawoJZXh0cmFjdCA4IDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJYnl0ZSAweDc1IC8vICJ1IgoJZnJhbWVfZGlnIC0yIC8vIHRhc2s6IFRhc2sKCWV4dHJhY3QgOCA4CglidG9pCglhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCglwb3AKCWNvbmNhdAoJZHVwCglib3hfZGVsCglwb3AKCXN3YXAKCWR1cAoJbGVuCglpbnQgOAoJLwoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJYm94X3B1dAoJYiAqaWYxX2VuZAoKKmlmMV9lbHNlOgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTA2CgkvLyBuZXdXaGl0ZWxpc3Q6IEFwcElEW10gPSBbdGFzay5hcHBdCglmcmFtZV9kaWcgLTIgLy8gdGFzazogVGFzawoJZXh0cmFjdCA4IDgKCWJ0b2kKCWl0b2IKCWZyYW1lX2J1cnkgMCAvLyBuZXdXaGl0ZWxpc3Q6IEFwcElEW10KCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxMDcKCS8vIHRoaXMudXNlcjJ0YXNrcyh0YXNrLmFwcC5jcmVhdG9yKS52YWx1ZSA9IG5ld1doaXRlbGlzdAoJYnl0ZSAweDc1IC8vICJ1IgoJZnJhbWVfZGlnIC0yIC8vIHRhc2s6IFRhc2sKCWV4dHJhY3QgOCA4CglidG9pCglhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCglwb3AKCWNvbmNhdAoJZHVwCglib3hfZGVsCglwb3AKCWZyYW1lX2RpZyAwIC8vIG5ld1doaXRlbGlzdDogQXBwSURbXQoJZHVwCglsZW4KCWludCA4CgkvCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0Cglib3hfcHV0CgoqaWYxX2VuZDoKCXJldHN1YgoKLy8gdW5yZWdpc3RlclRhc2sodWludDY0LHVpbnQ2NCl2b2lkCiphYmlfcm91dGVfdW5yZWdpc3RlclRhc2s6CgkvLyBpbmRleFRvRGVsZXRlOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBhcHA6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgdW5yZWdpc3RlclRhc2sodWludDY0LHVpbnQ2NCl2b2lkCgljYWxsc3ViIHVucmVnaXN0ZXJUYXNrCglpbnQgMQoJcmV0dXJuCgovLyB1bnJlZ2lzdGVyVGFzayhhcHA6IEFwcElELCBpbmRleFRvRGVsZXRlOiB1aW50NjQpOiB2b2lkCi8vCi8vIFVucmVnaXN0ZXIgYSB0YXNrIHdoZW4gdGFzayBpcyBkZWxldGVkCi8vCi8vIEBwYXJhbSBhcHAgQXBwIHRvIHVucmVnaXN0ZXIKLy8gQHBhcmFtIGluZGV4VG9EZWxldGUgQXBwIGluZGV4IHRvIGRlbGV0ZSBmcm9tIHVzZXIncyBhcHBzCnVucmVnaXN0ZXJUYXNrOgoJcHJvdG8gMiAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxMTgKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IGFwcC5hZGRyZXNzKQoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0xIC8vIGFwcDogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjExOQoJLy8gdGFzayA9IHRoaXMudGFza3MoYXBwKS52YWx1ZQoJYnl0ZSAweDc0IC8vICJ0IgoJZnJhbWVfZGlnIC0xIC8vIGFwcDogQXBwSUQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfYnVyeSAwIC8vIHN0b3JhZ2Uga2V5Ly90YXNrCgoJLy8gKmlmMl9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjEyMAoJLy8gdGFzay5mdW5kcyA+IDAKCWludCAwCglpbnQgOAoJYnl0ZSAweDc0IC8vICJ0IgoJZnJhbWVfZGlnIC0xIC8vIGFwcDogQXBwSUQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWludCAwCgk+CglieiAqaWYyX2VuZAoKCS8vICppZjJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTIxCgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICAgIGFzc2V0QW1vdW50OiB0YXNrLmZ1bmRzLAoJLy8gICAgICAgICBhc3NldFJlY2VpdmVyOiBhcHAuY3JlYXRvciwKCS8vICAgICAgICAgeGZlckFzc2V0OiBBc3NldElELmZyb21VaW50NjQodGhpcy5mZWVBc3NldElkLnZhbHVlKSwKCS8vICAgICAgICAgZmVlOiAwLAoJLy8gICAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBheGZlcgoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjEyMgoJLy8gYXNzZXRBbW91bnQ6IHRhc2suZnVuZHMKCWludCAwCglpbnQgOAoJYnl0ZSAweDc0IC8vICJ0IgoJZnJhbWVfZGlnIC0xIC8vIGFwcDogQXBwSUQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWl0eG5fZmllbGQgQXNzZXRBbW91bnQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxMjMKCS8vIGFzc2V0UmVjZWl2ZXI6IGFwcC5jcmVhdG9yCglmcmFtZV9kaWcgLTEgLy8gYXBwOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgoJcG9wCglpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxMjQKCS8vIHhmZXJBc3NldDogQXNzZXRJRC5mcm9tVWludDY0KHRoaXMuZmVlQXNzZXRJZC52YWx1ZSkKCWJ5dGUgMHg2NjYxIC8vICJmYSIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIFhmZXJBc3NldAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjEyNQoJLy8gZmVlOiAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoqaWYyX2VuZDoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjEyOAoJLy8gdGFzay5mdW5kcyA9IDAKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly90YXNrCglpbnQgMAoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTI5CgkvLyB0aGlzLnRhc2tzKGFwcCkuZGVsZXRlKCkKCWJ5dGUgMHg3NCAvLyAidCIKCWZyYW1lX2RpZyAtMSAvLyBhcHA6IEFwcElECglpdG9iCgljb25jYXQKCWJveF9kZWwKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxMzQKCS8vIHRoaXMudXNlcjJ0YXNrcyhhcHAuY3JlYXRvcikudmFsdWUuc3BsaWNlKGluZGV4VG9EZWxldGUsIDEpCglieXRlIDB4NzUgLy8gInUiCglmcmFtZV9kaWcgLTEgLy8gYXBwOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgoJcG9wCgljb25jYXQKCWludCAyCglpbnQgMAoJYm94X2V4dHJhY3QKCWludCAxCglmcmFtZV9kaWcgLTIgLy8gaW5kZXhUb0RlbGV0ZTogdWludDY0CglpbnQgOAoJKgoJc3RvcmUgMjQ3IC8vIHNwbGljZSBzdGFydAoJaW50IDE2CglzdG9yZSAyNDYgLy8gc3BsaWNlIGJ5dGUgbGVuZ3RoCglieXRlIDB4NzUgLy8gInUiCglmcmFtZV9kaWcgLTEgLy8gYXBwOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgoJcG9wCgljb25jYXQKCWludCAyCglpbnQgMAoJYm94X2V4dHJhY3QKCWludCAwCglsb2FkIDI0NyAvLyBzcGxpY2Ugc3RhcnQKCXN1YnN0cmluZzMKCWJ5dGUgMHg3NSAvLyAidSIKCWZyYW1lX2RpZyAtMSAvLyBhcHA6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCglwb3AKCWNvbmNhdAoJaW50IDIKCWludCAwCglib3hfZXh0cmFjdAoJZHVwCglsZW4KCWxvYWQgMjQ3IC8vIHNwbGljZSBzdGFydAoJbG9hZCAyNDYgLy8gc3BsaWNlIGJ5dGUgbGVuZ3RoCgkrCglpbnQgOAoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJY29uY2F0CglieXRlIDB4NzUgLy8gInUiCglmcmFtZV9kaWcgLTEgLy8gYXBwOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgoJcG9wCgljb25jYXQKCWR1cAoJYm94X2RlbAoJcG9wCglzd2FwCglkdXAKCWxlbgoJaW50IDgKCS8KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWJveF9wdXQKCXJldHN1YgoKLy8gZXhlY3V0ZVRhc2soYXBwbCl2b2lkCiphYmlfcm91dGVfZXhlY3V0ZVRhc2s6CgkvLyB0YXNrQXBwQ2FsbDogYXBwbAoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnQgYXBwbAoJPT0KCWFzc2VydAoKCS8vIGV4ZWN1dGUgZXhlY3V0ZVRhc2soYXBwbCl2b2lkCgljYWxsc3ViIGV4ZWN1dGVUYXNrCglpbnQgMQoJcmV0dXJuCgovLyBleGVjdXRlVGFzayh0YXNrQXBwQ2FsbDogQXBwQ2FsbFR4bik6IHZvaWQKLy8KLy8gRXhlY3V0ZSBhIHRhc2sgYW5kIGdldCB0aGUgcmV3YXJkCi8vCi8vIEBwYXJhbSB0YXNrQXBwQ2FsbCBUaGUgY2FsbCB0byB0aGUgdGFzayBhcHAKZXhlY3V0ZVRhc2s6Cglwcm90byAxIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjE0NAoJLy8gdGFzayA9IHRoaXMudGFza3ModGFza0FwcENhbGwuYXBwbGljYXRpb25JRCkudmFsdWUKCWJ5dGUgMHg3NCAvLyAidCIKCWZyYW1lX2RpZyAtMSAvLyB0YXNrQXBwQ2FsbDogQXBwQ2FsbFR4bgoJZ3R4bnMgQXBwbGljYXRpb25JRAoJaXRvYgoJY29uY2F0CglmcmFtZV9idXJ5IDAgLy8gc3RvcmFnZSBrZXkvL3Rhc2sKCgkvLyAqaWYzX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTQ3CgkvLyB0aGlzLmZlZUFzc2V0SWQudmFsdWUgPT09IDAKCWJ5dGUgMHg2NjYxIC8vICJmYSIKCWFwcF9nbG9iYWxfZ2V0CglpbnQgMAoJPT0KCWJ6ICppZjNfZWxzZQoKCS8vICppZjNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTQ4CgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgIHJlY2VpdmVyOiB0aGlzLnR4bi5zZW5kZXIsCgkvLyAgICAgICAgIGFtb3VudDogdGFzay5mZWUsCgkvLyAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjE0OQoJLy8gcmVjZWl2ZXI6IHRoaXMudHhuLnNlbmRlcgoJdHhuIFNlbmRlcgoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjE1MAoJLy8gYW1vdW50OiB0YXNrLmZlZQoJaW50IDE2IC8vIGhlYWRPZmZzZXQKCWludCA4CglieXRlIDB4NzQgLy8gInQiCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTQ0CgkvLyB0YXNrQXBwQ2FsbC5hcHBsaWNhdGlvbklECglmcmFtZV9kaWcgLTEgLy8gdGFza0FwcENhbGw6IEFwcENhbGxUeG4KCWd0eG5zIEFwcGxpY2F0aW9uSUQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJYiAqaWYzX2VuZAoKKmlmM19lbHNlOgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTUzCgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMudHhuLnNlbmRlciwKCS8vICAgICAgICAgYXNzZXRBbW91bnQ6IHRhc2suZmVlLAoJLy8gICAgICAgICB4ZmVyQXNzZXQ6IEFzc2V0SUQuZnJvbVVpbnQ2NCh0aGlzLmZlZUFzc2V0SWQudmFsdWUpLAoJLy8gICAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBheGZlcgoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjE1NAoJLy8gYXNzZXRSZWNlaXZlcjogdGhpcy50eG4uc2VuZGVyCgl0eG4gU2VuZGVyCglpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxNTUKCS8vIGFzc2V0QW1vdW50OiB0YXNrLmZlZQoJaW50IDE2IC8vIGhlYWRPZmZzZXQKCWludCA4CglieXRlIDB4NzQgLy8gInQiCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTQ0CgkvLyB0YXNrQXBwQ2FsbC5hcHBsaWNhdGlvbklECglmcmFtZV9kaWcgLTEgLy8gdGFza0FwcENhbGw6IEFwcENhbGxUeG4KCWd0eG5zIEFwcGxpY2F0aW9uSUQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWl0eG5fZmllbGQgQXNzZXRBbW91bnQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxNTYKCS8vIHhmZXJBc3NldDogQXNzZXRJRC5mcm9tVWludDY0KHRoaXMuZmVlQXNzZXRJZC52YWx1ZSkKCWJ5dGUgMHg2NjYxIC8vICJmYSIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIFhmZXJBc3NldAoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCippZjNfZW5kOgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTYyCgkvLyB0YXNrLmZ1bmRzIC09IHRhc2suZmVlCglpbnQgMAoJZHVwCglpbnQgOAoJYnl0ZSAweDc0IC8vICJ0IgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjE0NAoJLy8gdGFza0FwcENhbGwuYXBwbGljYXRpb25JRAoJZnJhbWVfZGlnIC0xIC8vIHRhc2tBcHBDYWxsOiBBcHBDYWxsVHhuCglndHhucyBBcHBsaWNhdGlvbklECglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTYyCgkvLyB0YXNrLmZlZQoJaW50IDE2IC8vIGhlYWRPZmZzZXQKCWludCA4CglieXRlIDB4NzQgLy8gInQiCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTQ0CgkvLyB0YXNrQXBwQ2FsbC5hcHBsaWNhdGlvbklECglmcmFtZV9kaWcgLTEgLy8gdGFza0FwcENhbGw6IEFwcENhbGxUeG4KCWd0eG5zIEFwcGxpY2F0aW9uSUQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCS0KCWl0b2IKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly90YXNrCgljb3ZlciAyCglib3hfcmVwbGFjZQoJcmV0c3ViCgovLyBmdW5kVGFzayh1aW50NjQsdHhuKXZvaWQKKmFiaV9yb3V0ZV9mdW5kVGFzazoKCS8vIGRlcG9zaXQ6IHR4bgoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCgoJLy8gdGFza0FwcElkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGZ1bmRUYXNrKHVpbnQ2NCx0eG4pdm9pZAoJY2FsbHN1YiBmdW5kVGFzawoJaW50IDEKCXJldHVybgoKLy8gZnVuZFRhc2sodGFza0FwcElkOiBBcHBJRCwgZGVwb3NpdDogVHhuKTogdm9pZAovLwovLyBEZXBvc2l0IGZ1bmRzIGZvciBhIHRhc2sKLy8KLy8gQHBhcmFtIHRhc2tBcHBJZCBUaGUgSUQgb2YgdGhlIHRhc2sgdG8gZnVuZAovLyBAcGFyYW0gZGVwb3NpdCBUaGUgcGF5IG9yIGF4ZmVyIHRvIGZ1bmQgdGhlIHRhc2sKZnVuZFRhc2s6Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiAyCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTcyCgkvLyB0YXNrID0gdGhpcy50YXNrcyh0YXNrQXBwSWQpLnZhbHVlCglieXRlIDB4NzQgLy8gInQiCglmcmFtZV9kaWcgLTEgLy8gdGFza0FwcElkOiBBcHBJRAoJaXRvYgoJY29uY2F0CglmcmFtZV9idXJ5IDAgLy8gc3RvcmFnZSBrZXkvL3Rhc2sKCgkvLyAqaWY0X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTc0CgkvLyB0aGlzLmZlZUFzc2V0SWQudmFsdWUgPT09IDAKCWJ5dGUgMHg2NjYxIC8vICJmYSIKCWFwcF9nbG9iYWxfZ2V0CglpbnQgMAoJPT0KCWJ6ICppZjRfZWxzZQoKCS8vICppZjRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTc1CgkvLyB2ZXJpZnlQYXlUeG4oZGVwb3NpdCwgewoJLy8gICAgICAgICByZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgIH0pCgkvLyB2ZXJpZnkgcGF5CglmcmFtZV9kaWcgLTIgLy8gZGVwb3NpdDogVHhuCglndHhucyBUeXBlRW51bQoJaW50IHBheQoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSByZWNlaXZlcgoJZnJhbWVfZGlnIC0yIC8vIGRlcG9zaXQ6IFR4bgoJZ3R4bnMgUmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTc4CgkvLyBmZWUgPSBkZXBvc2l0LmFtb3VudCAvIDEwMAoJZnJhbWVfZGlnIC0yIC8vIGRlcG9zaXQ6IFR4bgoJZ3R4bnMgQW1vdW50CglpbnQgMTAwCgkvCglmcmFtZV9idXJ5IDEgLy8gZmVlOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxNzkKCS8vIHRhc2suZnVuZHMgKz0gZGVwb3NpdC5hbW91bnQgLSBmZWUKCWludCAwCglkdXAKCWludCA4CglieXRlIDB4NzQgLy8gInQiCglmcmFtZV9kaWcgLTEgLy8gdGFza0FwcElkOiBBcHBJRAoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfZGlnIC0yIC8vIGRlcG9zaXQ6IFR4bgoJZ3R4bnMgQW1vdW50CglmcmFtZV9kaWcgMSAvLyBmZWU6IHVpbnQ2NAoJLQoJKwoJaXRvYgoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3Rhc2sKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTgwCgkvLyB0aGlzLmRlcG9zaXRlZEZ1bmRzLnZhbHVlICs9IGRlcG9zaXQuYW1vdW50IC0gZmVlCglieXRlIDB4NjQgLy8gImQiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIC0yIC8vIGRlcG9zaXQ6IFR4bgoJZ3R4bnMgQW1vdW50CglmcmFtZV9kaWcgMSAvLyBmZWU6IHVpbnQ2NAoJLQoJKwoJYnl0ZSAweDY0IC8vICJkIgoJc3dhcAoJYXBwX2dsb2JhbF9wdXQKCWIgKmlmNF9lbmQKCippZjRfZWxzZToKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjE4MgoJLy8gdmVyaWZ5QXNzZXRUcmFuc2ZlclR4bihkZXBvc2l0LCB7CgkvLyAgICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICAgIHhmZXJBc3NldDogQXNzZXRJRC5mcm9tVWludDY0KHRoaXMuZmVlQXNzZXRJZC52YWx1ZSksCgkvLyAgICAgICB9KQoJLy8gdmVyaWZ5IGF4ZmVyCglmcmFtZV9kaWcgLTIgLy8gZGVwb3NpdDogVHhuCglndHhucyBUeXBlRW51bQoJaW50IGF4ZmVyCgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFzc2V0UmVjZWl2ZXIKCWZyYW1lX2RpZyAtMiAvLyBkZXBvc2l0OiBUeG4KCWd0eG5zIEFzc2V0UmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IHhmZXJBc3NldAoJZnJhbWVfZGlnIC0yIC8vIGRlcG9zaXQ6IFR4bgoJZ3R4bnMgWGZlckFzc2V0CglieXRlIDB4NjY2MSAvLyAiZmEiCglhcHBfZ2xvYmFsX2dldAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjE4NgoJLy8gZmVlID0gZGVwb3NpdC5hbW91bnQgLyAxMDAKCWZyYW1lX2RpZyAtMiAvLyBkZXBvc2l0OiBUeG4KCWd0eG5zIEFtb3VudAoJaW50IDEwMAoJLwoJZnJhbWVfYnVyeSAyIC8vIGZlZTogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTg3CgkvLyB0YXNrLmZ1bmRzICs9IGRlcG9zaXQuYXNzZXRBbW91bnQgLSBmZWUKCWludCAwCglkdXAKCWludCA4CglieXRlIDB4NzQgLy8gInQiCglmcmFtZV9kaWcgLTEgLy8gdGFza0FwcElkOiBBcHBJRAoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfZGlnIC0yIC8vIGRlcG9zaXQ6IFR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWZyYW1lX2RpZyAyIC8vIGZlZTogdWludDY0CgktCgkrCglpdG9iCglmcmFtZV9kaWcgMCAvLyBzdG9yYWdlIGtleS8vdGFzawoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxODgKCS8vIHRoaXMuZGVwb3NpdGVkRnVuZHMudmFsdWUgKz0gZGVwb3NpdC5hc3NldEFtb3VudCAtIGZlZQoJYnl0ZSAweDY0IC8vICJkIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAtMiAvLyBkZXBvc2l0OiBUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglmcmFtZV9kaWcgMiAvLyBmZWU6IHVpbnQ2NAoJLQoJKwoJYnl0ZSAweDY0IC8vICJkIgoJc3dhcAoJYXBwX2dsb2JhbF9wdXQKCippZjRfZW5kOgoJcmV0c3ViCgovLyBjaGFuZ2VUYXNrRmVlKHVpbnQ2NCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX2NoYW5nZVRhc2tGZWU6CgkvLyBmZWU6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIHRhc2tBcHBJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBjaGFuZ2VUYXNrRmVlKHVpbnQ2NCx1aW50NjQpdm9pZAoJY2FsbHN1YiBjaGFuZ2VUYXNrRmVlCglpbnQgMQoJcmV0dXJuCgovLyBjaGFuZ2VUYXNrRmVlKHRhc2tBcHBJZDogQXBwSUQsIGZlZTogdWludDY0KTogdm9pZAovLwovLyBDcmVhdG9yIG9mIHRoZSB0YXNrIGlzIGFsbG93ZWQgdG8gY2hhbmdlIHRoZSBmZWUKLy8KLy8gQHBhcmFtIHRhc2tBcHBJZCBUaGUgSUQgb2YgdGhlIHRhc2sgdG8gZnVuZAovLyBAcGFyYW0gZmVlIEZlZSBpbiBiYXNlIHVuaXRzIG9mIHRoZSBmZWUgdG9rZW4KY2hhbmdlVGFza0ZlZToKCXByb3RvIDIgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTk5CgkvLyB0YXNrID0gdGhpcy50YXNrcyh0YXNrQXBwSWQpLnZhbHVlCglieXRlIDB4NzQgLy8gInQiCglmcmFtZV9kaWcgLTEgLy8gdGFza0FwcElkOiBBcHBJRAoJaXRvYgoJY29uY2F0CglmcmFtZV9idXJ5IDAgLy8gc3RvcmFnZSBrZXkvL3Rhc2sKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyMDAKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IHRhc2suYXBwLmNyZWF0b3IpCgl0eG4gU2VuZGVyCglpbnQgOCAvLyBoZWFkT2Zmc2V0CglpbnQgOAoJYnl0ZSAweDc0IC8vICJ0IgoJZnJhbWVfZGlnIC0xIC8vIHRhc2tBcHBJZDogQXBwSUQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWFwcF9wYXJhbXNfZ2V0IEFwcENyZWF0b3IKCXBvcAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjIwMQoJLy8gdGFzay5mZWUgPSBmZWUKCWludCAxNiAvLyBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTIgLy8gZmVlOiB1aW50NjQKCWl0b2IKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly90YXNrCgljb3ZlciAyCglib3hfcmVwbGFjZQoJcmV0c3ViCgovLyB1bmZ1bmRUYXNrKHVpbnQ2NCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX3VuZnVuZFRhc2s6CgkvLyBhbW91bnQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIHRhc2tBcHBJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSB1bmZ1bmRUYXNrKHVpbnQ2NCx1aW50NjQpdm9pZAoJY2FsbHN1YiB1bmZ1bmRUYXNrCglpbnQgMQoJcmV0dXJuCgovLyB1bmZ1bmRUYXNrKHRhc2tBcHBJZDogQXBwSUQsIGFtb3VudDogdWludDY0KTogdm9pZAovLwovLyBSZW1vdmUgZnVuZHMgZm9yIGEgdGFzawovLyBDcmVhdG9yIG9mIHRoZSB1bmRlcmx5aW5nIHRhc2sgY2FuIHJlbW92ZSB0aGUgZnVuZHMgZnJvbSB0aGUgcG9vbAovLwovLyBAcGFyYW0gdGFza0FwcElkIFRoZSBJRCBvZiB0aGUgdGFzayB0byBmdW5kCi8vIEBwYXJhbSBhbW91bnQgVGhlIGFtb3VudCB0byB3aXRoZHJhdyBmcm9tIHRoZSBwb29sCnVuZnVuZFRhc2s6Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjIxMgoJLy8gdGFzayA9IHRoaXMudGFza3ModGFza0FwcElkKS52YWx1ZQoJYnl0ZSAweDc0IC8vICJ0IgoJZnJhbWVfZGlnIC0xIC8vIHRhc2tBcHBJZDogQXBwSUQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfYnVyeSAwIC8vIHN0b3JhZ2Uga2V5Ly90YXNrCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjEzCgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSB0YXNrLmFwcC5jcmVhdG9yKQoJdHhuIFNlbmRlcgoJaW50IDggLy8gaGVhZE9mZnNldAoJaW50IDgKCWJ5dGUgMHg3NCAvLyAidCIKCWZyYW1lX2RpZyAtMSAvLyB0YXNrQXBwSWQ6IEFwcElECglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCglwb3AKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyMTQKCS8vIHRhc2suZnVuZHMgLT0gYW1vdW50CglpbnQgMAoJZHVwCglpbnQgOAoJYnl0ZSAweDc0IC8vICJ0IgoJZnJhbWVfZGlnIC0xIC8vIHRhc2tBcHBJZDogQXBwSUQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2RpZyAtMiAvLyBhbW91bnQ6IHVpbnQ2NAoJLQoJaXRvYgoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3Rhc2sKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjE1CgkvLyB0aGlzLmRlcG9zaXRlZEZ1bmRzLnZhbHVlIC09IGFtb3VudAoJYnl0ZSAweDY0IC8vICJkIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAtMiAvLyBhbW91bnQ6IHVpbnQ2NAoJLQoJYnl0ZSAweDY0IC8vICJkIgoJc3dhcAoJYXBwX2dsb2JhbF9wdXQKCgkvLyAqaWY1X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjE2CgkvLyB0aGlzLmZlZUFzc2V0SWQudmFsdWUgPT09IDAKCWJ5dGUgMHg2NjYxIC8vICJmYSIKCWFwcF9nbG9iYWxfZ2V0CglpbnQgMAoJPT0KCWJ6ICppZjVfZWxzZQoKCS8vICppZjVfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjE3CgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgIGFtb3VudDogYW1vdW50LAoJLy8gICAgICAgICByZWNlaXZlcjogdGhpcy50eG4uc2VuZGVyLAoJLy8gICAgICAgICBmZWU6IDAsCgkvLyAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjIxOAoJLy8gYW1vdW50OiBhbW91bnQKCWZyYW1lX2RpZyAtMiAvLyBhbW91bnQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyMTkKCS8vIHJlY2VpdmVyOiB0aGlzLnR4bi5zZW5kZXIKCXR4biBTZW5kZXIKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyMjAKCS8vIGZlZTogMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJYiAqaWY1X2VuZAoKKmlmNV9lbHNlOgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjIzCgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCgkvLyAgICAgICAgIHhmZXJBc3NldDogQXNzZXRJRC5mcm9tVWludDY0KHRoaXMuZmVlQXNzZXRJZC52YWx1ZSksCgkvLyAgICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMudHhuLnNlbmRlciwKCS8vICAgICAgICAgZmVlOiAwLAoJLy8gICAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBheGZlcgoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjIyNAoJLy8gYXNzZXRBbW91bnQ6IGFtb3VudAoJZnJhbWVfZGlnIC0yIC8vIGFtb3VudDogdWludDY0CglpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjI1CgkvLyB4ZmVyQXNzZXQ6IEFzc2V0SUQuZnJvbVVpbnQ2NCh0aGlzLmZlZUFzc2V0SWQudmFsdWUpCglieXRlIDB4NjY2MSAvLyAiZmEiCglhcHBfZ2xvYmFsX2dldAoJaXR4bl9maWVsZCBYZmVyQXNzZXQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyMjYKCS8vIGFzc2V0UmVjZWl2ZXI6IHRoaXMudHhuLnNlbmRlcgoJdHhuIFNlbmRlcgoJaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjI3CgkvLyBmZWU6IDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCippZjVfZW5kOgoJcmV0c3ViCgovLyBwYXltZW50KGFkZHJlc3MsdWludDY0LGFkZHJlc3Msc3RyaW5nKXZvaWQKKmFiaV9yb3V0ZV9wYXltZW50OgoJLy8gbm90ZTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyA0CglleHRyYWN0IDIgMAoKCS8vIHJlY2VpdmVyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gYW1vdW50OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBzZW5kZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBleGVjdXRlIHBheW1lbnQoYWRkcmVzcyx1aW50NjQsYWRkcmVzcyxzdHJpbmcpdm9pZAoJY2FsbHN1YiBwYXltZW50CglpbnQgMQoJcmV0dXJuCgovLyBwYXltZW50KHNlbmRlcjogQWRkcmVzcywgYW1vdW50OiB1aW50NjQsIHJlY2VpdmVyOiBBZGRyZXNzLCBub3RlOiBzdHJpbmcpOiB2b2lkCi8vCi8vIENyZWF0b3IgY2FuIHNlbmQgcGF5L2F4ZmVyIHRyYW5zYWN0aW9uIG91dCBvZiB0aGUgc21hcnQgY29udHJhY3QKLy8KLy8gQHBhcmFtIHNlbmRlciBTZW5kZXIuIFRoaXMgYXBwIGlkIG9yIGFueSByZWtleWVkIGFjY291bnQgdG8gdGhlIGFkZHJlc3Mgb2YgdGhpcyBzYwovLyBAcGFyYW0gYW1vdW50IEFtb3VudAovLyBAcGFyYW0gbm90ZSBOb3RlCi8vIEBwYXJhbSByZWNlaXZlciBSZWNlaXZlcgpwYXltZW50OgoJcHJvdG8gNCAwCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjQxCgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSBnbG9iYWxzLmNyZWF0b3JBZGRyZXNzKQoJdHhuIFNlbmRlcgoJZ2xvYmFsIENyZWF0b3JBZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gKmlmNl9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI0MgoJLy8gdGhpcy5mZWVBc3NldElkLnZhbHVlID09PSAwCglieXRlIDB4NjY2MSAvLyAiZmEiCglhcHBfZ2xvYmFsX2dldAoJaW50IDAKCT09CglieiAqaWY2X2VuZAoKCS8vICppZjZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjQ0CgkvLyBhc3NlcnQoZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLmJhbGFuY2UgLSBhbW91bnQgPj0gdGhpcy5kZXBvc2l0ZWRGdW5kcy52YWx1ZSkKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglhY2N0X3BhcmFtc19nZXQgQWNjdEJhbGFuY2UKCXBvcAoJZnJhbWVfZGlnIC0yIC8vIGFtb3VudDogdWludDY0CgktCglieXRlIDB4NjQgLy8gImQiCglhcHBfZ2xvYmFsX2dldAoJPj0KCWFzc2VydAoKKmlmNl9lbmQ6CgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyNDYKCS8vIHNlbmRQYXltZW50KHsKCS8vICAgICAgIGFtb3VudDogYW1vdW50LAoJLy8gICAgICAgcmVjZWl2ZXI6IHJlY2VpdmVyLAoJLy8gICAgICAgbm90ZTogbm90ZSwKCS8vICAgICAgIHNlbmRlcjogc2VuZGVyLAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnQgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjQ3CgkvLyBhbW91bnQ6IGFtb3VudAoJZnJhbWVfZGlnIC0yIC8vIGFtb3VudDogdWludDY0CglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI0OAoJLy8gcmVjZWl2ZXI6IHJlY2VpdmVyCglmcmFtZV9kaWcgLTMgLy8gcmVjZWl2ZXI6IEFkZHJlc3MKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyNDkKCS8vIG5vdGU6IG5vdGUKCWZyYW1lX2RpZyAtNCAvLyBub3RlOiBzdHJpbmcKCWl0eG5fZmllbGQgTm90ZQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI1MAoJLy8gc2VuZGVyOiBzZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFkZHJlc3MKCWl0eG5fZmllbGQgU2VuZGVyCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgovLyBhc3NldFRyYW5zZmVyKGFkZHJlc3MsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHN0cmluZyl2b2lkCiphYmlfcm91dGVfYXNzZXRUcmFuc2ZlcjoKCS8vIG5vdGU6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQoJZXh0cmFjdCAyIDAKCgkvLyBhc3NldFJlY2VpdmVyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyA0CglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gYXNzZXRBbW91bnQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIHhmZXJBc3NldDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gc2VuZGVyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBhc3NldFRyYW5zZmVyKGFkZHJlc3MsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHN0cmluZyl2b2lkCgljYWxsc3ViIGFzc2V0VHJhbnNmZXIKCWludCAxCglyZXR1cm4KCi8vIGFzc2V0VHJhbnNmZXIoc2VuZGVyOiBBZGRyZXNzLCB4ZmVyQXNzZXQ6IEFzc2V0SUQsIGFzc2V0QW1vdW50OiB1aW50NjQsIGFzc2V0UmVjZWl2ZXI6IEFkZHJlc3MsIG5vdGU6IHN0cmluZyk6IHZvaWQKLy8KLy8gQ3JlYXRvciBjYW4gc2VuZCBwYXkvYXhmZXIgdHJhbnNhY3Rpb24gb3V0IG9mIHRoZSBzbWFydCBjb250cmFjdAovLyBAcGFyYW0gc2VuZGVyIFNlbmRlci4gVGhpcyBhcHAgaWQgb3IgYW55IHJla2V5ZWQgYWNjb3VudCB0byB0aGUgYWRkcmVzcyBvZiB0aGlzIHNjCmFzc2V0VHJhbnNmZXI6Cglwcm90byA1IDAKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyNTkKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IGdsb2JhbHMuY3JlYXRvckFkZHJlc3MpCgl0eG4gU2VuZGVyCglnbG9iYWwgQ3JlYXRvckFkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyAqaWY3X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjYwCgkvLyB0aGlzLmZlZUFzc2V0SWQudmFsdWUgPT09IHhmZXJBc3NldC5pZAoJYnl0ZSAweDY2NjEgLy8gImZhIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAtMiAvLyB4ZmVyQXNzZXQ6IEFzc2V0SUQKCT09CglieiAqaWY3X2VuZAoKCS8vICppZjdfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjYyCgkvLyBhc3NlcnQoZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLmFzc2V0QmFsYW5jZSh4ZmVyQXNzZXQpIC0gYXNzZXRBbW91bnQgPj0gdGhpcy5kZXBvc2l0ZWRGdW5kcy52YWx1ZSkKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglmcmFtZV9kaWcgLTIgLy8geGZlckFzc2V0OiBBc3NldElECglhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKCXBvcAoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QW1vdW50OiB1aW50NjQKCS0KCWJ5dGUgMHg2NCAvLyAiZCIKCWFwcF9nbG9iYWxfZ2V0Cgk+PQoJYXNzZXJ0CgoqaWY3X2VuZDoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI2NAoJLy8gc2VuZEFzc2V0VHJhbnNmZXIoewoJLy8gICAgICAgYXNzZXRBbW91bnQ6IGFzc2V0QW1vdW50LAoJLy8gICAgICAgYXNzZXRSZWNlaXZlcjogYXNzZXRSZWNlaXZlciwKCS8vICAgICAgIHhmZXJBc3NldDogeGZlckFzc2V0LAoJLy8gICAgICAgbm90ZTogbm90ZSwKCS8vICAgICAgIGFzc2V0U2VuZGVyOiBzZW5kZXIsCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBheGZlcgoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI2NQoJLy8gYXNzZXRBbW91bnQ6IGFzc2V0QW1vdW50CglmcmFtZV9kaWcgLTMgLy8gYXNzZXRBbW91bnQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBc3NldEFtb3VudAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI2NgoJLy8gYXNzZXRSZWNlaXZlcjogYXNzZXRSZWNlaXZlcgoJZnJhbWVfZGlnIC00IC8vIGFzc2V0UmVjZWl2ZXI6IEFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI2NwoJLy8geGZlckFzc2V0OiB4ZmVyQXNzZXQKCWZyYW1lX2RpZyAtMiAvLyB4ZmVyQXNzZXQ6IEFzc2V0SUQKCWl0eG5fZmllbGQgWGZlckFzc2V0CgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjY4CgkvLyBub3RlOiBub3RlCglmcmFtZV9kaWcgLTUgLy8gbm90ZTogc3RyaW5nCglpdHhuX2ZpZWxkIE5vdGUKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyNjkKCS8vIGFzc2V0U2VuZGVyOiBzZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRTZW5kZXIKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglyZXRzdWIKCi8vIHNlbmRPbmxpbmVLZXlSZWdpc3RyYXRpb24oYnl0ZVtdLGJ5dGVbXSxieXRlW10sdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX3NlbmRPbmxpbmVLZXlSZWdpc3RyYXRpb246CgkvLyB2b3RlS2V5RGlsdXRpb246IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgoJYnRvaQoKCS8vIHZvdGVMYXN0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDUKCWJ0b2kKCgkvLyB2b3RlRmlyc3Q6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJYnRvaQoKCS8vIHN0YXRlUHJvb2ZQazogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglleHRyYWN0IDIgMAoKCS8vIHNlbGVjdGlvblBrOiBieXRlW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWV4dHJhY3QgMiAwCgoJLy8gdm90ZVBrOiBieXRlW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBzZW5kT25saW5lS2V5UmVnaXN0cmF0aW9uKGJ5dGVbXSxieXRlW10sYnl0ZVtdLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKCWNhbGxzdWIgc2VuZE9ubGluZUtleVJlZ2lzdHJhdGlvbgoJaW50IDEKCXJldHVybgoKLy8gc2VuZE9ubGluZUtleVJlZ2lzdHJhdGlvbih2b3RlUGs6IGJ5dGVzLCBzZWxlY3Rpb25QazogYnl0ZXMsIHN0YXRlUHJvb2ZQazogYnl0ZXMsIHZvdGVGaXJzdDogdWludDY0LCB2b3RlTGFzdDogdWludDY0LCB2b3RlS2V5RGlsdXRpb246IHVpbnQ2NCk6IHZvaWQKLy8KLy8gQ3JlYXRvciBjYW4gcGVyZm9tIGtleSByZWdpc3RyYXRpb24gZm9yIHRoaXMgTFAgcG9vbApzZW5kT25saW5lS2V5UmVnaXN0cmF0aW9uOgoJcHJvdG8gNiAwCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6Mjg0CgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSBnbG9iYWxzLmNyZWF0b3JBZGRyZXNzKQoJdHhuIFNlbmRlcgoJZ2xvYmFsIENyZWF0b3JBZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6Mjg1CgkvLyBzZW5kT25saW5lS2V5UmVnaXN0cmF0aW9uKHsKCS8vICAgICAgIHNlbGVjdGlvblBLOiBzZWxlY3Rpb25QaywKCS8vICAgICAgIHN0YXRlUHJvb2ZQSzogc3RhdGVQcm9vZlBrLAoJLy8gICAgICAgdm90ZUZpcnN0OiB2b3RlRmlyc3QsCgkvLyAgICAgICB2b3RlS2V5RGlsdXRpb246IHZvdGVLZXlEaWx1dGlvbiwKCS8vICAgICAgIHZvdGVMYXN0OiB2b3RlTGFzdCwKCS8vICAgICAgIHZvdGVQSzogdm90ZVBrLAoJLy8gICAgICAgZmVlOiAwLAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnQga2V5cmVnCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6Mjg2CgkvLyBzZWxlY3Rpb25QSzogc2VsZWN0aW9uUGsKCWZyYW1lX2RpZyAtMiAvLyBzZWxlY3Rpb25QazogYnl0ZXMKCWl0eG5fZmllbGQgU2VsZWN0aW9uUEsKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyODcKCS8vIHN0YXRlUHJvb2ZQSzogc3RhdGVQcm9vZlBrCglmcmFtZV9kaWcgLTMgLy8gc3RhdGVQcm9vZlBrOiBieXRlcwoJaXR4bl9maWVsZCBTdGF0ZVByb29mUEsKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyODgKCS8vIHZvdGVGaXJzdDogdm90ZUZpcnN0CglmcmFtZV9kaWcgLTQgLy8gdm90ZUZpcnN0OiB1aW50NjQKCWl0eG5fZmllbGQgVm90ZUZpcnN0CgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6Mjg5CgkvLyB2b3RlS2V5RGlsdXRpb246IHZvdGVLZXlEaWx1dGlvbgoJZnJhbWVfZGlnIC02IC8vIHZvdGVLZXlEaWx1dGlvbjogdWludDY0CglpdHhuX2ZpZWxkIFZvdGVLZXlEaWx1dGlvbgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI5MAoJLy8gdm90ZUxhc3Q6IHZvdGVMYXN0CglmcmFtZV9kaWcgLTUgLy8gdm90ZUxhc3Q6IHVpbnQ2NAoJaXR4bl9maWVsZCBWb3RlTGFzdAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI5MQoJLy8gdm90ZVBLOiB2b3RlUGsKCWZyYW1lX2RpZyAtMSAvLyB2b3RlUGs6IGJ5dGVzCglpdHhuX2ZpZWxkIFZvdGVQSwoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI5MgoJLy8gZmVlOiAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglyZXRzdWIKCi8vIHNlbmRPZmZsaW5lS2V5UmVnaXN0cmF0aW9uKCl2b2lkCiphYmlfcm91dGVfc2VuZE9mZmxpbmVLZXlSZWdpc3RyYXRpb246CgkvLyBleGVjdXRlIHNlbmRPZmZsaW5lS2V5UmVnaXN0cmF0aW9uKCl2b2lkCgljYWxsc3ViIHNlbmRPZmZsaW5lS2V5UmVnaXN0cmF0aW9uCglpbnQgMQoJcmV0dXJuCgovLyBzZW5kT2ZmbGluZUtleVJlZ2lzdHJhdGlvbigpOiB2b2lkCi8vCi8vIENyZWF0b3IgY2FuIHBlcmZvbSBrZXkgdW5yZWdpc3RyYXRpb24gZm9yIHRoaXMgTFAgcG9vbApzZW5kT2ZmbGluZUtleVJlZ2lzdHJhdGlvbjoKCXByb3RvIDAgMAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjMwMAoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjMwMQoJLy8gc2VuZE9mZmxpbmVLZXlSZWdpc3RyYXRpb24oeyBmZWU6IDAgfSkKCWl0eG5fYmVnaW4KCWludCBrZXlyZWcKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czozMDEKCS8vIGZlZTogMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgoqY3JlYXRlX05vT3A6CgltZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbgoJZXJyCgoqY2FsbF9Ob09wOgoJbWV0aG9kICJib290c3RyYXAocGF5LHVpbnQ2NCl2b2lkIgoJbWV0aG9kICJyZWdpc3RlclRhc2socGF5LCh1aW50NjQsdWludDY0LHVpbnQ2NCkpdm9pZCIKCW1ldGhvZCAidW5yZWdpc3RlclRhc2sodWludDY0LHVpbnQ2NCl2b2lkIgoJbWV0aG9kICJleGVjdXRlVGFzayhhcHBsKXZvaWQiCgltZXRob2QgImZ1bmRUYXNrKHVpbnQ2NCx0eG4pdm9pZCIKCW1ldGhvZCAiY2hhbmdlVGFza0ZlZSh1aW50NjQsdWludDY0KXZvaWQiCgltZXRob2QgInVuZnVuZFRhc2sodWludDY0LHVpbnQ2NCl2b2lkIgoJbWV0aG9kICJwYXltZW50KGFkZHJlc3MsdWludDY0LGFkZHJlc3Msc3RyaW5nKXZvaWQiCgltZXRob2QgImFzc2V0VHJhbnNmZXIoYWRkcmVzcyx1aW50NjQsdWludDY0LGFkZHJlc3Msc3RyaW5nKXZvaWQiCgltZXRob2QgInNlbmRPbmxpbmVLZXlSZWdpc3RyYXRpb24oYnl0ZVtdLGJ5dGVbXSxieXRlW10sdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZCIKCW1ldGhvZCAic2VuZE9mZmxpbmVLZXlSZWdpc3RyYXRpb24oKXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2Jvb3RzdHJhcCAqYWJpX3JvdXRlX3JlZ2lzdGVyVGFzayAqYWJpX3JvdXRlX3VucmVnaXN0ZXJUYXNrICphYmlfcm91dGVfZXhlY3V0ZVRhc2sgKmFiaV9yb3V0ZV9mdW5kVGFzayAqYWJpX3JvdXRlX2NoYW5nZVRhc2tGZWUgKmFiaV9yb3V0ZV91bmZ1bmRUYXNrICphYmlfcm91dGVfcGF5bWVudCAqYWJpX3JvdXRlX2Fzc2V0VHJhbnNmZXIgKmFiaV9yb3V0ZV9zZW5kT25saW5lS2V5UmVnaXN0cmF0aW9uICphYmlfcm91dGVfc2VuZE9mZmxpbmVLZXlSZWdpc3RyYXRpb24KCWVycgoKKmNhbGxfVXBkYXRlQXBwbGljYXRpb246CgltZXRob2QgInVwZGF0ZUFwcGxpY2F0aW9uKHN0cmluZyl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV91cGRhdGVBcHBsaWNhdGlvbgoJZXJy\",\n    \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDEw\"\n  },\n  \"contract\": {\n    \"name\": \"BiatecTaskManager\",\n    \"desc\": \"\",\n    \"methods\": [\n      {\n        \"name\": \"createApplication\",\n        \"desc\": \"Initial setup\",\n        \"args\": [],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"updateApplication\",\n        \"desc\": \"Creator can update application\",\n        \"args\": [\n          {\n            \"name\": \"version\",\n            \"type\": \"string\",\n            \"desc\": \"App version\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"bootstrap\",\n        \"desc\": \"Bootstrap the contract to optin to the fee asset and setup basic variables\",\n        \"args\": [\n          {\n            \"name\": \"txBaseDeposit\",\n            \"type\": \"pay\",\n            \"desc\": \"Deposit MBR\"\n          },\n          {\n            \"name\": \"feeAssetId\",\n            \"type\": \"uint64\",\n            \"desc\": \"Fee asset id\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"registerTask\",\n        \"desc\": \"Register a task to be executedOnly app it self can call register task\",\n        \"args\": [\n          {\n            \"name\": \"registrationFeeDeposit\",\n            \"type\": \"pay\",\n            \"desc\": \"The axfer or pay that deposits the initial funds\"\n          },\n          {\n            \"name\": \"task\",\n            \"type\": \"(uint64,uint64,uint64)\",\n            \"desc\": \"The task object\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"unregisterTask\",\n        \"desc\": \"Unregister a task when task is deleted\",\n        \"args\": [\n          {\n            \"name\": \"app\",\n            \"type\": \"uint64\",\n            \"desc\": \"App to unregister\"\n          },\n          {\n            \"name\": \"indexToDelete\",\n            \"type\": \"uint64\",\n            \"desc\": \"App index to delete from user's apps\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"executeTask\",\n        \"desc\": \"Execute a task and get the reward\",\n        \"args\": [\n          {\n            \"name\": \"taskAppCall\",\n            \"type\": \"appl\",\n            \"desc\": \"The call to the task app\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"fundTask\",\n        \"desc\": \"Deposit funds for a task\",\n        \"args\": [\n          {\n            \"name\": \"taskAppId\",\n            \"type\": \"uint64\",\n            \"desc\": \"The ID of the task to fund\"\n          },\n          {\n            \"name\": \"deposit\",\n            \"type\": \"txn\",\n            \"desc\": \"The pay or axfer to fund the task\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"changeTaskFee\",\n        \"desc\": \"Creator of the task is allowed to change the fee\",\n        \"args\": [\n          {\n            \"name\": \"taskAppId\",\n            \"type\": \"uint64\",\n            \"desc\": \"The ID of the task to fund\"\n          },\n          {\n            \"name\": \"fee\",\n            \"type\": \"uint64\",\n            \"desc\": \"Fee in base units of the fee token\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"unfundTask\",\n        \"desc\": \"Remove funds for a taskCreator of the underlying task can remove the funds from the pool\",\n        \"args\": [\n          {\n            \"name\": \"taskAppId\",\n            \"type\": \"uint64\",\n            \"desc\": \"The ID of the task to fund\"\n          },\n          {\n            \"name\": \"amount\",\n            \"type\": \"uint64\",\n            \"desc\": \"The amount to withdraw from the pool\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"payment\",\n        \"desc\": \"Creator can send pay/axfer transaction out of the smart contract\",\n        \"args\": [\n          {\n            \"name\": \"sender\",\n            \"type\": \"address\",\n            \"desc\": \"Sender. This app id or any rekeyed account to the address of this sc\"\n          },\n          {\n            \"name\": \"amount\",\n            \"type\": \"uint64\",\n            \"desc\": \"Amount\"\n          },\n          {\n            \"name\": \"receiver\",\n            \"type\": \"address\",\n            \"desc\": \"Receiver\"\n          },\n          {\n            \"name\": \"note\",\n            \"type\": \"string\",\n            \"desc\": \"Note\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"assetTransfer\",\n        \"desc\": \"Creator can send pay/axfer transaction out of the smart contract\",\n        \"args\": [\n          {\n            \"name\": \"sender\",\n            \"type\": \"address\",\n            \"desc\": \"Sender. This app id or any rekeyed account to the address of this sc\"\n          },\n          {\n            \"name\": \"xferAsset\",\n            \"type\": \"uint64\"\n          },\n          {\n            \"name\": \"assetAmount\",\n            \"type\": \"uint64\"\n          },\n          {\n            \"name\": \"assetReceiver\",\n            \"type\": \"address\"\n          },\n          {\n            \"name\": \"note\",\n            \"type\": \"string\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"sendOnlineKeyRegistration\",\n        \"desc\": \"Creator can perfom key registration for this LP pool\",\n        \"args\": [\n          {\n            \"name\": \"votePk\",\n            \"type\": \"byte[]\"\n          },\n          {\n            \"name\": \"selectionPk\",\n            \"type\": \"byte[]\"\n          },\n          {\n            \"name\": \"stateProofPk\",\n            \"type\": \"byte[]\"\n          },\n          {\n            \"name\": \"voteFirst\",\n            \"type\": \"uint64\"\n          },\n          {\n            \"name\": \"voteLast\",\n            \"type\": \"uint64\"\n          },\n          {\n            \"name\": \"voteKeyDilution\",\n            \"type\": \"uint64\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"sendOfflineKeyRegistration\",\n        \"desc\": \"Creator can perfom key unregistration for this LP pool\",\n        \"args\": [],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      }\n    ]\n  }\n};\nvar BiatecTaskManagerCallFactory = class {\n  /**\n   * Gets available create call factories\n   */\n  static get create() {\n    return {\n      /**\n       * Constructs a create call for the BiatecTaskManager smart contract using the createApplication()void ABI method\n       *\n       * @param args Any args for the contract call\n       * @param params Any additional parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      createApplication(args, params = {}) {\n        return __spreadValues({\n          method: \"createApplication()void\",\n          methodArgs: Array.isArray(args) ? args : []\n        }, params);\n      }\n    };\n  }\n  /**\n   * Gets available update call factories\n   */\n  static get update() {\n    return {\n      /**\n       * Constructs an update call for the BiatecTaskManager smart contract using the updateApplication(string)void ABI method\n       *\n       * @param args Any args for the contract call\n       * @param params Any additional parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      updateApplication(args, params = {}) {\n        return __spreadValues({\n          method: \"updateApplication(string)void\",\n          methodArgs: Array.isArray(args) ? args : [args.version]\n        }, params);\n      }\n    };\n  }\n  /**\n   * Constructs a no op call for the bootstrap(pay,uint64)void ABI method\n   *\n   * Bootstrap the contract to optin to the fee asset and setup basic variables\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static bootstrap(args, params) {\n    return __spreadValues({\n      method: \"bootstrap(pay,uint64)void\",\n      methodArgs: Array.isArray(args) ? args : [args.txBaseDeposit, args.feeAssetId]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the registerTask(pay,(uint64,uint64,uint64))void ABI method\n   *\n   * Register a task to be executedOnly app it self can call register task\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static registerTask(args, params) {\n    return __spreadValues({\n      method: \"registerTask(pay,(uint64,uint64,uint64))void\",\n      methodArgs: Array.isArray(args) ? args : [args.registrationFeeDeposit, args.task]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the unregisterTask(uint64,uint64)void ABI method\n   *\n   * Unregister a task when task is deleted\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static unregisterTask(args, params) {\n    return __spreadValues({\n      method: \"unregisterTask(uint64,uint64)void\",\n      methodArgs: Array.isArray(args) ? args : [args.app, args.indexToDelete]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the executeTask(appl)void ABI method\n   *\n   * Execute a task and get the reward\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static executeTask(args, params) {\n    return __spreadValues({\n      method: \"executeTask(appl)void\",\n      methodArgs: Array.isArray(args) ? args : [args.taskAppCall]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the fundTask(uint64,txn)void ABI method\n   *\n   * Deposit funds for a task\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static fundTask(args, params) {\n    return __spreadValues({\n      method: \"fundTask(uint64,txn)void\",\n      methodArgs: Array.isArray(args) ? args : [args.taskAppId, args.deposit]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the changeTaskFee(uint64,uint64)void ABI method\n   *\n   * Creator of the task is allowed to change the fee\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static changeTaskFee(args, params) {\n    return __spreadValues({\n      method: \"changeTaskFee(uint64,uint64)void\",\n      methodArgs: Array.isArray(args) ? args : [args.taskAppId, args.fee]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the unfundTask(uint64,uint64)void ABI method\n   *\n   * Remove funds for a taskCreator of the underlying task can remove the funds from the pool\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static unfundTask(args, params) {\n    return __spreadValues({\n      method: \"unfundTask(uint64,uint64)void\",\n      methodArgs: Array.isArray(args) ? args : [args.taskAppId, args.amount]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the payment(address,uint64,address,string)void ABI method\n   *\n   * Creator can send pay/axfer transaction out of the smart contract\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static payment(args, params) {\n    return __spreadValues({\n      method: \"payment(address,uint64,address,string)void\",\n      methodArgs: Array.isArray(args) ? args : [args.sender, args.amount, args.receiver, args.note]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the assetTransfer(address,uint64,uint64,address,string)void ABI method\n   *\n   * Creator can send pay/axfer transaction out of the smart contract\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static assetTransfer(args, params) {\n    return __spreadValues({\n      method: \"assetTransfer(address,uint64,uint64,address,string)void\",\n      methodArgs: Array.isArray(args) ? args : [args.sender, args.xferAsset, args.assetAmount, args.assetReceiver, args.note]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64)void ABI method\n   *\n   * Creator can perfom key registration for this LP pool\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static sendOnlineKeyRegistration(args, params) {\n    return __spreadValues({\n      method: \"sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64)void\",\n      methodArgs: Array.isArray(args) ? args : [args.votePk, args.selectionPk, args.stateProofPk, args.voteFirst, args.voteLast, args.voteKeyDilution]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the sendOfflineKeyRegistration()void ABI method\n   *\n   * Creator can perfom key unregistration for this LP pool\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static sendOfflineKeyRegistration(args, params) {\n    return __spreadValues({\n      method: \"sendOfflineKeyRegistration()void\",\n      methodArgs: Array.isArray(args) ? args : []\n    }, params);\n  }\n};\nvar BiatecTaskManagerClient = class _BiatecTaskManagerClient {\n  /**\n   * Creates a new instance of `BiatecTaskManagerClient`\n   *\n   * @param appDetails appDetails The details to identify the app to deploy\n   * @param algod An algod client instance\n   */\n  constructor(appDetails, algod) {\n    this.algod = algod;\n    this.sender = appDetails.sender;\n    this.appClient = algokit.getAppClient(__spreadProps(__spreadValues({}, appDetails), {\n      app: APP_SPEC\n    }), algod);\n  }\n  /**\n   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type\n   *\n   * @param result The AppCallTransactionResult to be mapped\n   * @param returnValueFormatter An optional delegate to format the return value if required\n   * @returns The smart contract response with an updated return value\n   */\n  mapReturnValue(result, returnValueFormatter) {\n    var _a, _b, _c;\n    if ((_a = result.return) == null ? void 0 : _a.decodeError) {\n      throw result.return.decodeError;\n    }\n    const returnValue = ((_b = result.return) == null ? void 0 : _b.returnValue) !== void 0 && returnValueFormatter !== void 0 ? returnValueFormatter(result.return.returnValue) : (_c = result.return) == null ? void 0 : _c.returnValue;\n    return __spreadProps(__spreadValues({}, result), { return: returnValue });\n  }\n  /**\n   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP\n   *\n   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters\n   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type\n   * @returns The result of the smart contract call\n   */\n  call(typedCallParams, returnValueFormatter) {\n    return __async(this, null, function* () {\n      return this.mapReturnValue(yield this.appClient.call(typedCallParams), returnValueFormatter);\n    });\n  }\n  /**\n   * Idempotently deploys the BiatecTaskManager smart contract.\n   *\n   * @param params The arguments for the contract calls and any additional parameters for the call\n   * @returns The deployment result\n   */\n  deploy(params = {}) {\n    var _a, _b;\n    const createArgs = (_a = params.createCall) == null ? void 0 : _a.call(params, BiatecTaskManagerCallFactory.create);\n    const updateArgs = (_b = params.updateCall) == null ? void 0 : _b.call(params, BiatecTaskManagerCallFactory.update);\n    return this.appClient.deploy(__spreadProps(__spreadValues({}, params), {\n      updateArgs,\n      createArgs,\n      createOnCompleteAction: createArgs == null ? void 0 : createArgs.onCompleteAction\n    }));\n  }\n  /**\n   * Gets available create methods\n   */\n  get create() {\n    const $this = this;\n    return {\n      /**\n       * Creates a new instance of the BiatecTaskManager smart contract using the createApplication()void ABI method.\n       *\n       * @param args The arguments for the smart contract call\n       * @param params Any additional parameters for the call\n       * @returns The create result\n       */\n      createApplication(_0) {\n        return __async(this, arguments, function* (args, params = {}) {\n          return $this.mapReturnValue(yield $this.appClient.create(BiatecTaskManagerCallFactory.create.createApplication(args, params)));\n        });\n      }\n    };\n  }\n  /**\n   * Gets available update methods\n   */\n  get update() {\n    const $this = this;\n    return {\n      /**\n       * Updates an existing instance of the BiatecTaskManager smart contract using the updateApplication(string)void ABI method.\n       *\n       * @param args The arguments for the smart contract call\n       * @param params Any additional parameters for the call\n       * @returns The update result\n       */\n      updateApplication(_0) {\n        return __async(this, arguments, function* (args, params = {}) {\n          return $this.mapReturnValue(yield $this.appClient.update(BiatecTaskManagerCallFactory.update.updateApplication(args, params)));\n        });\n      }\n    };\n  }\n  /**\n   * Makes a clear_state call to an existing instance of the BiatecTaskManager smart contract.\n   *\n   * @param args The arguments for the bare call\n   * @returns The clear_state result\n   */\n  clearState(args = {}) {\n    return this.appClient.clearState(args);\n  }\n  /**\n   * Calls the bootstrap(pay,uint64)void ABI method.\n   *\n   * Bootstrap the contract to optin to the fee asset and setup basic variables\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  bootstrap(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.bootstrap(args, params));\n  }\n  /**\n   * Calls the registerTask(pay,(uint64,uint64,uint64))void ABI method.\n   *\n   * Register a task to be executedOnly app it self can call register task\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  registerTask(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.registerTask(args, params));\n  }\n  /**\n   * Calls the unregisterTask(uint64,uint64)void ABI method.\n   *\n   * Unregister a task when task is deleted\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  unregisterTask(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.unregisterTask(args, params));\n  }\n  /**\n   * Calls the executeTask(appl)void ABI method.\n   *\n   * Execute a task and get the reward\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  executeTask(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.executeTask(args, params));\n  }\n  /**\n   * Calls the fundTask(uint64,txn)void ABI method.\n   *\n   * Deposit funds for a task\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  fundTask(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.fundTask(args, params));\n  }\n  /**\n   * Calls the changeTaskFee(uint64,uint64)void ABI method.\n   *\n   * Creator of the task is allowed to change the fee\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  changeTaskFee(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.changeTaskFee(args, params));\n  }\n  /**\n   * Calls the unfundTask(uint64,uint64)void ABI method.\n   *\n   * Remove funds for a taskCreator of the underlying task can remove the funds from the pool\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  unfundTask(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.unfundTask(args, params));\n  }\n  /**\n   * Calls the payment(address,uint64,address,string)void ABI method.\n   *\n   * Creator can send pay/axfer transaction out of the smart contract\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  payment(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.payment(args, params));\n  }\n  /**\n   * Calls the assetTransfer(address,uint64,uint64,address,string)void ABI method.\n   *\n   * Creator can send pay/axfer transaction out of the smart contract\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  assetTransfer(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.assetTransfer(args, params));\n  }\n  /**\n   * Calls the sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64)void ABI method.\n   *\n   * Creator can perfom key registration for this LP pool\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  sendOnlineKeyRegistration(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.sendOnlineKeyRegistration(args, params));\n  }\n  /**\n   * Calls the sendOfflineKeyRegistration()void ABI method.\n   *\n   * Creator can perfom key unregistration for this LP pool\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  sendOfflineKeyRegistration(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.sendOfflineKeyRegistration(args, params));\n  }\n  /**\n   * Extracts a binary state value out of an AppState dictionary\n   *\n   * @param state The state dictionary containing the state value\n   * @param key The key of the state value\n   * @returns A BinaryState instance containing the state value, or undefined if the key was not found\n   */\n  static getBinaryState(state, key) {\n    const value = state[key];\n    if (!value)\n      return void 0;\n    if (!(\"valueRaw\" in value))\n      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`);\n    return {\n      asString() {\n        return value.value;\n      },\n      asByteArray() {\n        return value.valueRaw;\n      }\n    };\n  }\n  /**\n   * Extracts a integer state value out of an AppState dictionary\n   *\n   * @param state The state dictionary containing the state value\n   * @param key The key of the state value\n   * @returns An IntegerState instance containing the state value, or undefined if the key was not found\n   */\n  static getIntegerState(state, key) {\n    const value = state[key];\n    if (!value)\n      return void 0;\n    if (\"valueRaw\" in value)\n      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`);\n    return {\n      asBigInt() {\n        return typeof value.value === \"bigint\" ? value.value : BigInt(value.value);\n      },\n      asNumber() {\n        return typeof value.value === \"bigint\" ? Number(value.value) : value.value;\n      }\n    };\n  }\n  /**\n   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value\n   */\n  getGlobalState() {\n    return __async(this, null, function* () {\n      const state = yield this.appClient.getGlobalState();\n      return {\n        get fa() {\n          return _BiatecTaskManagerClient.getIntegerState(state, \"fa\");\n        },\n        get d() {\n          return _BiatecTaskManagerClient.getIntegerState(state, \"d\");\n        },\n        get scver() {\n          return _BiatecTaskManagerClient.getBinaryState(state, \"scver\");\n        }\n      };\n    });\n  }\n  compose() {\n    const client = this;\n    const atc = new AtomicTransactionComposer();\n    let promiseChain = Promise.resolve();\n    const resultMappers = [];\n    return {\n      bootstrap(args, params) {\n        promiseChain = promiseChain.then(() => client.bootstrap(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      registerTask(args, params) {\n        promiseChain = promiseChain.then(() => client.registerTask(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      unregisterTask(args, params) {\n        promiseChain = promiseChain.then(() => client.unregisterTask(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      executeTask(args, params) {\n        promiseChain = promiseChain.then(() => client.executeTask(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      fundTask(args, params) {\n        promiseChain = promiseChain.then(() => client.fundTask(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      changeTaskFee(args, params) {\n        promiseChain = promiseChain.then(() => client.changeTaskFee(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      unfundTask(args, params) {\n        promiseChain = promiseChain.then(() => client.unfundTask(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      payment(args, params) {\n        promiseChain = promiseChain.then(() => client.payment(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      assetTransfer(args, params) {\n        promiseChain = promiseChain.then(() => client.assetTransfer(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      sendOnlineKeyRegistration(args, params) {\n        promiseChain = promiseChain.then(() => client.sendOnlineKeyRegistration(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      sendOfflineKeyRegistration(args, params) {\n        promiseChain = promiseChain.then(() => client.sendOfflineKeyRegistration(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      get update() {\n        const $this = this;\n        return {\n          updateApplication(args, params) {\n            promiseChain = promiseChain.then(() => client.update.updateApplication(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n            resultMappers.push(void 0);\n            return $this;\n          }\n        };\n      },\n      clearState(args) {\n        promiseChain = promiseChain.then(() => client.clearState(__spreadProps(__spreadValues({}, args), { sendParams: __spreadProps(__spreadValues({}, args == null ? void 0 : args.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      addTransaction(txn, defaultSender) {\n        promiseChain = promiseChain.then(() => __async(this, null, function* () {\n          return atc.addTransaction(yield algokit.getTransactionWithSigner(txn, defaultSender != null ? defaultSender : client.sender));\n        }));\n        return this;\n      },\n      atc() {\n        return __async(this, null, function* () {\n          yield promiseChain;\n          return atc;\n        });\n      },\n      simulate(options) {\n        return __async(this, null, function* () {\n          var _a2;\n          yield promiseChain;\n          const result = yield atc.simulate(client.algod, new modelsv2.SimulateRequest(__spreadValues({ txnGroups: [] }, options)));\n          return __spreadProps(__spreadValues({}, result), {\n            returns: (_a2 = result.methodResults) == null ? void 0 : _a2.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val.returnValue) : val.returnValue)\n          });\n        });\n      },\n      execute(sendParams) {\n        return __async(this, null, function* () {\n          var _a2;\n          yield promiseChain;\n          const result = yield algokit.sendAtomicTransactionComposer({ atc, sendParams }, client.algod);\n          return __spreadProps(__spreadValues({}, result), {\n            returns: (_a2 = result.returns) == null ? void 0 : _a2.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val.returnValue) : val.returnValue)\n          });\n        });\n      }\n    };\n  }\n};\n\n// contracts/clients/BiatecCronJob__SHORT_HASH__Client.ts\nimport * as algokit2 from \"@algorandfoundation/algokit-utils\";\nimport { AtomicTransactionComposer as AtomicTransactionComposer2, modelsv2 as modelsv22 } from \"algosdk\";\nvar APP_SPEC2 = {\n  \"hints\": {\n    \"createApplication()void\": {\n      \"call_config\": {\n        \"no_op\": \"CREATE\"\n      }\n    },\n    \"updateApplication(string,string)void\": {\n      \"call_config\": {\n        \"update_application\": \"CALL\"\n      }\n    },\n    \"deleteApplication()void\": {\n      \"call_config\": {\n        \"delete_application\": \"CALL\"\n      }\n    },\n    \"unregisterApplication(uint64,uint64)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"setPeriod(uint64)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"payment(uint64,address,string)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"assetTransfer(uint64,uint64,address,string)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"bootstrap(uint64,pay,string,uint64,uint64,uint64)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"sendOfflineKeyRegistration()void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"noop()void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"exec()void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    }\n  },\n  \"bare_call_config\": {\n    \"no_op\": \"NEVER\",\n    \"opt_in\": \"NEVER\",\n    \"close_out\": \"NEVER\",\n    \"update_application\": \"NEVER\",\n    \"delete_application\": \"NEVER\"\n  },\n  \"schema\": {\n    \"local\": {\n      \"declared\": {},\n      \"reserved\": {}\n    },\n    \"global\": {\n      \"declared\": {\n        \"id\": {\n          \"type\": \"bytes\",\n          \"key\": \"id\"\n        },\n        \"lastRun\": {\n          \"type\": \"uint64\",\n          \"key\": \"l\"\n        },\n        \"period\": {\n          \"type\": \"uint64\",\n          \"key\": \"p\"\n        },\n        \"start\": {\n          \"type\": \"uint64\",\n          \"key\": \"s\"\n        },\n        \"appPoolManager\": {\n          \"type\": \"uint64\",\n          \"key\": \"pool\"\n        },\n        \"version\": {\n          \"type\": \"bytes\",\n          \"key\": \"scver\"\n        }\n      },\n      \"reserved\": {}\n    }\n  },\n  \"state\": {\n    \"global\": {\n      \"num_byte_slices\": 2,\n      \"num_uints\": 4\n    },\n    \"local\": {\n      \"num_byte_slices\": 0,\n      \"num_uints\": 0\n    }\n  },\n  \"source\": {\n    \"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCgovLyBUaGlzIFRFQUwgd2FzIGdlbmVyYXRlZCBieSBURUFMU2NyaXB0IHYwLjkwLjMKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbnRyYWN0LCBpdHMgcmVzcGVjdGl2ZSBicmFuY2ggd2lsbCBiZSAiKk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCmludCA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCAqY2FsbF9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpjYWxsX1VwZGF0ZUFwcGxpY2F0aW9uICpjYWxsX0RlbGV0ZUFwcGxpY2F0aW9uICpjcmVhdGVfTm9PcCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQKCipOT1RfSU1QTEVNRU5URUQ6CgllcnIKCi8vIGNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkCiphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb246CgkvLyBleGVjdXRlIGNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkCgljYWxsc3ViIGNyZWF0ZUFwcGxpY2F0aW9uCglpbnQgMQoJcmV0dXJuCgovLyBjcmVhdGVBcHBsaWNhdGlvbigpOiB2b2lkCi8vCi8vIEluaXRpYWwgc2V0dXAKY3JlYXRlQXBwbGljYXRpb246Cglwcm90byAwIDAKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czo1MQoJLy8gdGhpcy5sYXN0UnVuLnZhbHVlID0gMAoJYnl0ZSAweDZjIC8vICJsIgoJaW50IDAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6NTIKCS8vIHRoaXMucGVyaW9kLnZhbHVlID0gMAoJYnl0ZSAweDcwIC8vICJwIgoJaW50IDAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6NTMKCS8vIHRoaXMuc3RhcnQudmFsdWUgPSAwCglieXRlIDB4NzMgLy8gInMiCglpbnQgMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czo1NAoJLy8gdGhpcy52ZXJzaW9uLnZhbHVlID0gJ0JJQVRFQy1DUk9OLTAxLTAxLTAxJwoJYnl0ZSAweDczNjM3NjY1NzIgLy8gInNjdmVyIgoJYnl0ZSAweDAwMTQ0MjQ5NDE1NDQ1NDMyZDQzNTI0ZjRlMmQzMDMxMmQzMDMxMmQzMDMxCglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyB1cGRhdGVBcHBsaWNhdGlvbihzdHJpbmcsc3RyaW5nKXZvaWQKKmFiaV9yb3V0ZV91cGRhdGVBcHBsaWNhdGlvbjoKCS8vIGlkOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWV4dHJhY3QgMiAwCgoJLy8gdmVyc2lvbjogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgdXBkYXRlQXBwbGljYXRpb24oc3RyaW5nLHN0cmluZyl2b2lkCgljYWxsc3ViIHVwZGF0ZUFwcGxpY2F0aW9uCglpbnQgMQoJcmV0dXJuCgovLyB1cGRhdGVBcHBsaWNhdGlvbih2ZXJzaW9uOiBzdHJpbmcsIGlkOiBzdHJpbmcpOiB2b2lkCi8vCi8vIENyZWF0b3IgY2FuIHVwZGF0ZSBhcHBsaWNhdGlvbgp1cGRhdGVBcHBsaWNhdGlvbjoKCXByb3RvIDIgMAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjYxCgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSBnbG9iYWxzLmNyZWF0b3JBZGRyZXNzKQoJdHhuIFNlbmRlcgoJZ2xvYmFsIENyZWF0b3JBZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6NjIKCS8vIHRoaXMudmVyc2lvbi52YWx1ZSA9IHZlcnNpb24KCWJ5dGUgMHg3MzYzNzY2NTcyIC8vICJzY3ZlciIKCWZyYW1lX2RpZyAtMSAvLyB2ZXJzaW9uOiBzdHJpbmcKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjYzCgkvLyB0aGlzLmlkLnZhbHVlID0gaWQKCWJ5dGUgMHg2OTY0IC8vICJpZCIKCWZyYW1lX2RpZyAtMiAvLyBpZDogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gZGVsZXRlQXBwbGljYXRpb24oKXZvaWQKKmFiaV9yb3V0ZV9kZWxldGVBcHBsaWNhdGlvbjoKCS8vIGV4ZWN1dGUgZGVsZXRlQXBwbGljYXRpb24oKXZvaWQKCWNhbGxzdWIgZGVsZXRlQXBwbGljYXRpb24KCWludCAxCglyZXR1cm4KCi8vIGRlbGV0ZUFwcGxpY2F0aW9uKCk6IHZvaWQKLy8KLy8gQ3JlYXRvciBjYW4gZGVsZXRlIGFwcGxpY2F0aW9uCmRlbGV0ZUFwcGxpY2F0aW9uOgoJcHJvdG8gMCAwCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6NzAKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IGdsb2JhbHMuY3JlYXRvckFkZHJlc3MpCgl0eG4gU2VuZGVyCglnbG9iYWwgQ3JlYXRvckFkZHJlc3MKCT09Cglhc3NlcnQKCXJldHN1YgoKLy8gdW5yZWdpc3RlckFwcGxpY2F0aW9uKHVpbnQ2NCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX3VucmVnaXN0ZXJBcHBsaWNhdGlvbjoKCS8vIGluZGV4VG9EZWxldGU6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIGFwcFBvb2xNYW5hZ2VyOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIHVucmVnaXN0ZXJBcHBsaWNhdGlvbih1aW50NjQsdWludDY0KXZvaWQKCWNhbGxzdWIgdW5yZWdpc3RlckFwcGxpY2F0aW9uCglpbnQgMQoJcmV0dXJuCgovLyB1bnJlZ2lzdGVyQXBwbGljYXRpb24oYXBwUG9vbE1hbmFnZXI6IEFwcElELCBpbmRleFRvRGVsZXRlOiB1aW50NjQpOiB2b2lkCi8vCi8vIENyZWF0b3IgY2FuIHVucmVnaXN0ZXJBcHBsaWNhdGlvbiBiZWZvcmUgaGUgZGVsZXRlcyBpdAovLwovLyBAcGFyYW0gYXBwUG9vbE1hbmFnZXIgUG9vbCBtYW5hZ2VyIHdoZXJlIHRoZSB0YXNrIGlzIHJlZ2lzdGVyZWQKLy8gQHBhcmFtIGluZGV4VG9EZWxldGUgQXBwIGluZGV4IHRvIGRlbGV0ZSBmcm9tIHVzZXIncyBhcHBzCnVucmVnaXN0ZXJBcHBsaWNhdGlvbjoKCXByb3RvIDIgMAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjgwCgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSBnbG9iYWxzLmNyZWF0b3JBZGRyZXNzKQoJdHhuIFNlbmRlcgoJZ2xvYmFsIENyZWF0b3JBZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6ODEKCS8vIGFzc2VydCh0aGlzLmFwcFBvb2xNYW5hZ2VyLnZhbHVlID09PSBhcHBQb29sTWFuYWdlcikKCWJ5dGUgMHg3MDZmNmY2YyAvLyAicG9vbCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgLTEgLy8gYXBwUG9vbE1hbmFnZXI6IEFwcElECgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6ODIKCS8vIHNlbmRNZXRob2RDYWxsPFtBcHBJRCwgdWludDY0XSwgdm9pZD4oewoJLy8gICAgICAgbmFtZTogJ3VucmVnaXN0ZXJUYXNrJywKCS8vICAgICAgIG1ldGhvZEFyZ3M6IFtnbG9iYWxzLmN1cnJlbnRBcHBsaWNhdGlvbklELCBpbmRleFRvRGVsZXRlXSwKCS8vICAgICAgIGFwcGxpY2F0aW9uSUQ6IGFwcFBvb2xNYW5hZ2VyLAoJLy8gICAgICAgZmVlOiAwLAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnQgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJbWV0aG9kICJ1bnJlZ2lzdGVyVGFzayh1aW50NjQsdWludDY0KXZvaWQiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjg0CgkvLyBtZXRob2RBcmdzOiBbZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25JRCwgaW5kZXhUb0RlbGV0ZV0KCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWZyYW1lX2RpZyAtMiAvLyBpbmRleFRvRGVsZXRlOiB1aW50NjQKCWl0b2IKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6ODUKCS8vIGFwcGxpY2F0aW9uSUQ6IGFwcFBvb2xNYW5hZ2VyCglmcmFtZV9kaWcgLTEgLy8gYXBwUG9vbE1hbmFnZXI6IEFwcElECglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czo4NgoJLy8gZmVlOiAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglyZXRzdWIKCi8vIHNldFBlcmlvZCh1aW50NjQpdm9pZAoqYWJpX3JvdXRlX3NldFBlcmlvZDoKCS8vIHBlcmlvZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBzZXRQZXJpb2QodWludDY0KXZvaWQKCWNhbGxzdWIgc2V0UGVyaW9kCglpbnQgMQoJcmV0dXJuCgovLyBzZXRQZXJpb2QocGVyaW9kOiB1aW50NjQpOiB2b2lkCi8vCi8vIENyZWF0b3IgY2FuIGNoYW5nZSB0aGUgcGVyaW9kIGhvdyBvZnRlciB0aGUgc2NyaXB0IGNhbiBiZSBleGVjdXRlZCBieSBleGVjdXRvcnMKLy8KLy8gQHBhcmFtIHBlcmlvZCBQZXJpb2QgaW4gc2Vjb25kcwpzZXRQZXJpb2Q6Cglwcm90byAxIDAKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czo5NgoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjk3CgkvLyB0aGlzLnBlcmlvZC52YWx1ZSA9IHBlcmlvZAoJYnl0ZSAweDcwIC8vICJwIgoJZnJhbWVfZGlnIC0xIC8vIHBlcmlvZDogdWludDY0CglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyBwYXltZW50KHVpbnQ2NCxhZGRyZXNzLHN0cmluZyl2b2lkCiphYmlfcm91dGVfcGF5bWVudDoKCS8vIG5vdGU6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZXh0cmFjdCAyIDAKCgkvLyByZWNlaXZlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGFtb3VudDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBwYXltZW50KHVpbnQ2NCxhZGRyZXNzLHN0cmluZyl2b2lkCgljYWxsc3ViIHBheW1lbnQKCWludCAxCglyZXR1cm4KCi8vIHBheW1lbnQoYW1vdW50OiB1aW50NjQsIHJlY2VpdmVyOiBBZGRyZXNzLCBub3RlOiBzdHJpbmcpOiB2b2lkCi8vCi8vIENyZWF0b3IgY2FuIHNlbmQgcGF5L2F4ZmVyIHRyYW5zYWN0aW9uIG91dCBvZiB0aGUgc21hcnQgY29udHJhY3QKLy8KLy8gQHBhcmFtIGFtb3VudCBBbW91bnQKLy8gQHBhcmFtIG5vdGUgTm90ZQovLyBAcGFyYW0gcmVjZWl2ZXIgUmVjZWl2ZXIKcGF5bWVudDoKCXByb3RvIDMgMAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjEwOAoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjEwOQoJLy8gc2VuZFBheW1lbnQoewoJLy8gICAgICAgYW1vdW50OiBhbW91bnQsCgkvLyAgICAgICByZWNlaXZlcjogcmVjZWl2ZXIsCgkvLyAgICAgICBub3RlOiBub3RlLAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnQgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTEwCgkvLyBhbW91bnQ6IGFtb3VudAoJZnJhbWVfZGlnIC0xIC8vIGFtb3VudDogdWludDY0CglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjExMQoJLy8gcmVjZWl2ZXI6IHJlY2VpdmVyCglmcmFtZV9kaWcgLTIgLy8gcmVjZWl2ZXI6IEFkZHJlc3MKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxMTIKCS8vIG5vdGU6IG5vdGUKCWZyYW1lX2RpZyAtMyAvLyBub3RlOiBzdHJpbmcKCWl0eG5fZmllbGQgTm90ZQoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxMTQKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IGdsb2JhbHMuY3JlYXRvckFkZHJlc3MpCgl0eG4gU2VuZGVyCglnbG9iYWwgQ3JlYXRvckFkZHJlc3MKCT09Cglhc3NlcnQKCXJldHN1YgoKLy8gYXNzZXRUcmFuc2Zlcih1aW50NjQsdWludDY0LGFkZHJlc3Msc3RyaW5nKXZvaWQKKmFiaV9yb3V0ZV9hc3NldFRyYW5zZmVyOgoJLy8gbm90ZTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyA0CglleHRyYWN0IDIgMAoKCS8vIGFzc2V0UmVjZWl2ZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBhc3NldEFtb3VudDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8geGZlckFzc2V0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGFzc2V0VHJhbnNmZXIodWludDY0LHVpbnQ2NCxhZGRyZXNzLHN0cmluZyl2b2lkCgljYWxsc3ViIGFzc2V0VHJhbnNmZXIKCWludCAxCglyZXR1cm4KCi8vIGFzc2V0VHJhbnNmZXIoeGZlckFzc2V0OiBBc3NldElELCBhc3NldEFtb3VudDogdWludDY0LCBhc3NldFJlY2VpdmVyOiBBZGRyZXNzLCBub3RlOiBzdHJpbmcpOiB2b2lkCi8vCi8vIENyZWF0b3IgY2FuIHNlbmQgcGF5L2F4ZmVyIHRyYW5zYWN0aW9uIG91dCBvZiB0aGUgc21hcnQgY29udHJhY3QKLy8gQHBhcmFtIHhmZXJBc3NldCBBc3NldCBpZAovLyBAcGFyYW0gYXNzZXRBbW91bnQgQW1vdW50Ci8vIEBwYXJhbSBub3RlIE5vdGUKLy8gQHBhcmFtIGFzc2V0UmVjZWl2ZXIgUmVjZWl2ZXIKYXNzZXRUcmFuc2ZlcjoKCXByb3RvIDQgMAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjEyNQoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjEyNgoJLy8gc2VuZEFzc2V0VHJhbnNmZXIoewoJLy8gICAgICAgYXNzZXRBbW91bnQ6IGFzc2V0QW1vdW50LAoJLy8gICAgICAgYXNzZXRSZWNlaXZlcjogYXNzZXRSZWNlaXZlciwKCS8vICAgICAgIHhmZXJBc3NldDogeGZlckFzc2V0LAoJLy8gICAgICAgbm90ZTogbm90ZSwKCS8vICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IGF4ZmVyCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTI3CgkvLyBhc3NldEFtb3VudDogYXNzZXRBbW91bnQKCWZyYW1lX2RpZyAtMiAvLyBhc3NldEFtb3VudDogdWludDY0CglpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTI4CgkvLyBhc3NldFJlY2VpdmVyOiBhc3NldFJlY2VpdmVyCglmcmFtZV9kaWcgLTMgLy8gYXNzZXRSZWNlaXZlcjogQWRkcmVzcwoJaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTI5CgkvLyB4ZmVyQXNzZXQ6IHhmZXJBc3NldAoJZnJhbWVfZGlnIC0xIC8vIHhmZXJBc3NldDogQXNzZXRJRAoJaXR4bl9maWVsZCBYZmVyQXNzZXQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxMzAKCS8vIG5vdGU6IG5vdGUKCWZyYW1lX2RpZyAtNCAvLyBub3RlOiBzdHJpbmcKCWl0eG5fZmllbGQgTm90ZQoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCXJldHN1YgoKLy8gYm9vdHN0cmFwKHVpbnQ2NCxwYXksc3RyaW5nLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKKmFiaV9yb3V0ZV9ib290c3RyYXA6CgkvLyBmZWU6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQoJYnRvaQoKCS8vIHN0YXJ0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWJ0b2kKCgkvLyBwZXJpb2Q6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIGlkOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWV4dHJhY3QgMiAwCgoJLy8gdHhCYXNlRGVwb3NpdDogcGF5Cgl0eG4gR3JvdXBJbmRleAoJaW50IDEKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludCBwYXkKCT09Cglhc3NlcnQKCgkvLyBhcHBQb29sTWFuYWdlcjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBib290c3RyYXAodWludDY0LHBheSxzdHJpbmcsdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZAoJY2FsbHN1YiBib290c3RyYXAKCWludCAxCglyZXR1cm4KCi8vIGJvb3RzdHJhcChhcHBQb29sTWFuYWdlcjogQXBwSUQsIHR4QmFzZURlcG9zaXQ6IFBheVR4biwgaWQ6IHN0cmluZywgcGVyaW9kOiB1aW50NjQsIHN0YXJ0OiB1aW50NjQsIGZlZTogdWludDY0KTogdm9pZAovLwovLyBCb290c3RyYXAgdGhlIGNvbnRyYWN0IHRvIG9wdGluIHRvIHRoZSBmZWUgYXNzZXQgYW5kIHNldHVwIGJhc2ljIHZhcmlhYmxlcwovLwovLyBAcGFyYW0gYXBwUG9vbE1hbmFnZXIgVGFza3MgUG9vbCBtYW5hZ2VyIGFwcAovLyBAcGFyYW0gdHhCYXNlRGVwb3NpdCBEZXBvc2l0IE1CUgovLyBAcGFyYW0gaWQgSGFzaCBpZCBvZiB0aGUgaW5wdXQgYXBwCi8vIEBwYXJhbSBwZXJpb2QgIFBlcmlvZCBpbiBzZWNvbmRzIGhvdyBvZnRlbiB0aGlzIHNtYXJ0IGNvbnRyYWN0IGNhbiBiZSBydW4KLy8gQHBhcmFtIHN0YXJ0IFN0YXJ0IHRpbWUgaW4gdW5peCB0aW1lc3RhbXAgc2Vjb25kcy4gQ29udHJhY3QgY2FuIGJlIGV4ZWN0dXRlZCB3aGVuIE1hdGguZmxvb3IoKGN1cnJlbnRUaW1lICsgc3RhcnQpIC8gcGVyaW9kKSA+IE1hdGguZmxvb3IoKGxhc3RSdW4gKyBzdGFydCkgLyBwZXJpb2QpCi8vIEBwYXJhbSBmZWUgRXhlY3V0aW9uIGZlZSBmb3IgdGhlIHRhc2sKYm9vdHN0cmFwOgoJcHJvdG8gNiAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjE1MgoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjE1MwoJLy8gdmVyaWZ5UGF5VHhuKHR4QmFzZURlcG9zaXQsIHsKCS8vICAgICAgIHJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgYW1vdW50OiB7IGdyZWF0ZXJUaGFuRXF1YWxUbzogMCB9LAoJLy8gICAgIH0pCgkvLyB2ZXJpZnkgcmVjZWl2ZXIKCWZyYW1lX2RpZyAtMiAvLyB0eEJhc2VEZXBvc2l0OiBQYXlUeG4KCWd0eG5zIFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSBhbW91bnQKCWZyYW1lX2RpZyAtMiAvLyB0eEJhc2VEZXBvc2l0OiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJaW50IDAKCT49Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxNTgKCS8vIGtlZXAgPSAxMDAwMDAKCWludCAxMDAwMDAKCWZyYW1lX2J1cnkgMCAvLyBrZWVwOiB1aW50NjQKCgkvLyAqaWYwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTU5CgkvLyBnbG9iYWxzLm1pbkJhbGFuY2UgPiBrZWVwCglnbG9iYWwgTWluQmFsYW5jZQoJZnJhbWVfZGlnIDAgLy8ga2VlcDogdWludDY0Cgk+CglieiAqaWYwX2VuZAoKCS8vICppZjBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTU5CgkvLyBrZWVwID0gZ2xvYmFscy5taW5CYWxhbmNlCglnbG9iYWwgTWluQmFsYW5jZQoJZnJhbWVfYnVyeSAwIC8vIGtlZXA6IHVpbnQ2NAoKKmlmMF9lbmQ6CgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxNjMKCS8vIHRhc2s6IFRhc2sgPSB7CgkvLyAgICAgICBhcHA6IGdsb2JhbHMuY3VycmVudEFwcGxpY2F0aW9uSUQsCgkvLyAgICAgICBmZWU6IGZlZSwKCS8vICAgICAgIGZ1bmRzOiAwLAoJLy8gICAgIH0KCWJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uSUQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfZGlnIC02IC8vIGZlZTogdWludDY0CglpdG9iCgljb25jYXQKCWZyYW1lX2J1cnkgMSAvLyB0YXNrOiBUYXNrCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTY5CgkvLyBzZW5kTWV0aG9kQ2FsbDxbUGF5VHhuLCBUYXNrXSwgdm9pZD4oewoJLy8gICAgICAgbmFtZTogJ3JlZ2lzdGVyVGFzaycsCgkvLyAgICAgICBtZXRob2RBcmdzOiBbCgkvLyAgICAgICAgIHsKCS8vICAgICAgICAgICBhbW91bnQ6IGdsb2JhbHMuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcy5iYWxhbmNlIC0ga2VlcCwKCS8vICAgICAgICAgICBub3RlOiAncmVnJywKCS8vICAgICAgICAgICByZWNlaXZlcjogYXBwUG9vbE1hbmFnZXIuYWRkcmVzcywKCS8vICAgICAgICAgICBmZWU6IDAsCgkvLyAgICAgICAgIH0sCgkvLyAgICAgICAgIHRhc2ssCgkvLyAgICAgICBdLAoJLy8gICAgICAgYXBwbGljYXRpb25JRDogYXBwUG9vbE1hbmFnZXIsCgkvLyAgICAgICBmZWU6IDAsCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxNzMKCS8vIGFtb3VudDogZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLmJhbGFuY2UgLSBrZWVwCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCglwb3AKCWZyYW1lX2RpZyAwIC8vIGtlZXA6IHVpbnQ2NAoJLQoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxNzQKCS8vIG5vdGU6ICdyZWcnCglieXRlIDB4NzI2NTY3IC8vICJyZWciCglpdHhuX2ZpZWxkIE5vdGUKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxNzUKCS8vIHJlY2VpdmVyOiBhcHBQb29sTWFuYWdlci5hZGRyZXNzCglmcmFtZV9kaWcgLTEgLy8gYXBwUG9vbE1hbmFnZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxNzYKCS8vIGZlZTogMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCglpdHhuX25leHQKCWludCBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgltZXRob2QgInJlZ2lzdGVyVGFzayhwYXksKHVpbnQ2NCx1aW50NjQsdWludDY0KSl2b2lkIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxNzEKCS8vIG1ldGhvZEFyZ3M6IFsKCS8vICAgICAgICAgewoJLy8gICAgICAgICAgIGFtb3VudDogZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLmJhbGFuY2UgLSBrZWVwLAoJLy8gICAgICAgICAgIG5vdGU6ICdyZWcnLAoJLy8gICAgICAgICAgIHJlY2VpdmVyOiBhcHBQb29sTWFuYWdlci5hZGRyZXNzLAoJLy8gICAgICAgICAgIGZlZTogMCwKCS8vICAgICAgICAgfSwKCS8vICAgICAgICAgdGFzaywKCS8vICAgICAgIF0KCWZyYW1lX2RpZyAxIC8vIHRhc2s6IFRhc2sKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTgwCgkvLyBhcHBsaWNhdGlvbklEOiBhcHBQb29sTWFuYWdlcgoJZnJhbWVfZGlnIC0xIC8vIGFwcFBvb2xNYW5hZ2VyOiBBcHBJRAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTgxCgkvLyBmZWU6IDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxODQKCS8vIGFzc2VydChwZXJpb2QgPiAwKQoJZnJhbWVfZGlnIC00IC8vIHBlcmlvZDogdWludDY0CglpbnQgMAoJPgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTg1CgkvLyB0aGlzLmlkLnZhbHVlID0gaWQKCWJ5dGUgMHg2OTY0IC8vICJpZCIKCWZyYW1lX2RpZyAtMyAvLyBpZDogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxODYKCS8vIHRoaXMucGVyaW9kLnZhbHVlID0gcGVyaW9kCglieXRlIDB4NzAgLy8gInAiCglmcmFtZV9kaWcgLTQgLy8gcGVyaW9kOiB1aW50NjQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTg3CgkvLyB0aGlzLnN0YXJ0LnZhbHVlID0gc3RhcnQKCWJ5dGUgMHg3MyAvLyAicyIKCWZyYW1lX2RpZyAtNSAvLyBzdGFydDogdWludDY0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjE4OAoJLy8gdGhpcy5hcHBQb29sTWFuYWdlci52YWx1ZSA9IGFwcFBvb2xNYW5hZ2VyCglieXRlIDB4NzA2ZjZmNmMgLy8gInBvb2wiCglmcmFtZV9kaWcgLTEgLy8gYXBwUG9vbE1hbmFnZXI6IEFwcElECglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyBzZW5kT25saW5lS2V5UmVnaXN0cmF0aW9uKGJ5dGVbXSxieXRlW10sYnl0ZVtdLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKKmFiaV9yb3V0ZV9zZW5kT25saW5lS2V5UmVnaXN0cmF0aW9uOgoJLy8gdm90ZUtleURpbHV0aW9uOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDYKCWJ0b2kKCgkvLyB2b3RlTGFzdDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA1CglidG9pCgoJLy8gdm90ZUZpcnN0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWJ0b2kKCgkvLyBzdGF0ZVByb29mUGs6IGJ5dGVbXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZXh0cmFjdCAyIDAKCgkvLyBzZWxlY3Rpb25QazogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglleHRyYWN0IDIgMAoKCS8vIHZvdGVQazogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgc2VuZE9ubGluZUtleVJlZ2lzdHJhdGlvbihieXRlW10sYnl0ZVtdLGJ5dGVbXSx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkCgljYWxsc3ViIHNlbmRPbmxpbmVLZXlSZWdpc3RyYXRpb24KCWludCAxCglyZXR1cm4KCi8vIHNlbmRPbmxpbmVLZXlSZWdpc3RyYXRpb24odm90ZVBrOiBieXRlcywgc2VsZWN0aW9uUGs6IGJ5dGVzLCBzdGF0ZVByb29mUGs6IGJ5dGVzLCB2b3RlRmlyc3Q6IHVpbnQ2NCwgdm90ZUxhc3Q6IHVpbnQ2NCwgdm90ZUtleURpbHV0aW9uOiB1aW50NjQpOiB2b2lkCi8vCi8vIENyZWF0b3IgY2FuIHBlcmZvbSBrZXkgcmVnaXN0cmF0aW9uIGZvciB0aGlzIExQIHBvb2wKc2VuZE9ubGluZUtleVJlZ2lzdHJhdGlvbjoKCXByb3RvIDYgMAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjIwMgoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjIwMwoJLy8gc2VuZE9ubGluZUtleVJlZ2lzdHJhdGlvbih7CgkvLyAgICAgICBzZWxlY3Rpb25QSzogc2VsZWN0aW9uUGssCgkvLyAgICAgICBzdGF0ZVByb29mUEs6IHN0YXRlUHJvb2ZQaywKCS8vICAgICAgIHZvdGVGaXJzdDogdm90ZUZpcnN0LAoJLy8gICAgICAgdm90ZUtleURpbHV0aW9uOiB2b3RlS2V5RGlsdXRpb24sCgkvLyAgICAgICB2b3RlTGFzdDogdm90ZUxhc3QsCgkvLyAgICAgICB2b3RlUEs6IHZvdGVQaywKCS8vICAgICAgIGZlZTogMCwKCS8vICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IGtleXJlZwoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjIwNAoJLy8gc2VsZWN0aW9uUEs6IHNlbGVjdGlvblBrCglmcmFtZV9kaWcgLTIgLy8gc2VsZWN0aW9uUGs6IGJ5dGVzCglpdHhuX2ZpZWxkIFNlbGVjdGlvblBLCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MjA1CgkvLyBzdGF0ZVByb29mUEs6IHN0YXRlUHJvb2ZQawoJZnJhbWVfZGlnIC0zIC8vIHN0YXRlUHJvb2ZQazogYnl0ZXMKCWl0eG5fZmllbGQgU3RhdGVQcm9vZlBLCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MjA2CgkvLyB2b3RlRmlyc3Q6IHZvdGVGaXJzdAoJZnJhbWVfZGlnIC00IC8vIHZvdGVGaXJzdDogdWludDY0CglpdHhuX2ZpZWxkIFZvdGVGaXJzdAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjIwNwoJLy8gdm90ZUtleURpbHV0aW9uOiB2b3RlS2V5RGlsdXRpb24KCWZyYW1lX2RpZyAtNiAvLyB2b3RlS2V5RGlsdXRpb246IHVpbnQ2NAoJaXR4bl9maWVsZCBWb3RlS2V5RGlsdXRpb24KCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoyMDgKCS8vIHZvdGVMYXN0OiB2b3RlTGFzdAoJZnJhbWVfZGlnIC01IC8vIHZvdGVMYXN0OiB1aW50NjQKCWl0eG5fZmllbGQgVm90ZUxhc3QKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoyMDkKCS8vIHZvdGVQSzogdm90ZVBrCglmcmFtZV9kaWcgLTEgLy8gdm90ZVBrOiBieXRlcwoJaXR4bl9maWVsZCBWb3RlUEsKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoyMTAKCS8vIGZlZTogMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgovLyBzZW5kT2ZmbGluZUtleVJlZ2lzdHJhdGlvbigpdm9pZAoqYWJpX3JvdXRlX3NlbmRPZmZsaW5lS2V5UmVnaXN0cmF0aW9uOgoJLy8gZXhlY3V0ZSBzZW5kT2ZmbGluZUtleVJlZ2lzdHJhdGlvbigpdm9pZAoJY2FsbHN1YiBzZW5kT2ZmbGluZUtleVJlZ2lzdHJhdGlvbgoJaW50IDEKCXJldHVybgoKLy8gc2VuZE9mZmxpbmVLZXlSZWdpc3RyYXRpb24oKTogdm9pZAovLwovLyBDcmVhdG9yIGNhbiBwZXJmb20ga2V5IHVucmVnaXN0cmF0aW9uIGZvciB0aGlzIExQIHBvb2wKc2VuZE9mZmxpbmVLZXlSZWdpc3RyYXRpb246Cglwcm90byAwIDAKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoyMTgKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IGdsb2JhbHMuY3JlYXRvckFkZHJlc3MpCgl0eG4gU2VuZGVyCglnbG9iYWwgQ3JlYXRvckFkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoyMTkKCS8vIHNlbmRPZmZsaW5lS2V5UmVnaXN0cmF0aW9uKHsgZmVlOiAwIH0pCglpdHhuX2JlZ2luCglpbnQga2V5cmVnCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MjE5CgkvLyBmZWU6IDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCXJldHN1YgoKLy8gbm9vcCgpdm9pZAoqYWJpX3JvdXRlX25vb3A6CgkvLyBleGVjdXRlIG5vb3AoKXZvaWQKCWNhbGxzdWIgbm9vcAoJaW50IDEKCXJldHVybgoKLy8gbm9vcCgpOiB2b2lkCi8vCi8vIE5vIG9wLCBmb3IgcHVycG9zZSBvZiBhZGRpbmcgZXh0cmEgcmVzb3VyY2VzIHRvIHRoZSB0eCBncm91cApub29wOgoJcHJvdG8gMCAwCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MjI2CgkvLyBsb2coJzEnKQoJYnl0ZSAweDMxIC8vICIxIgoJbG9nCglyZXRzdWIKCi8vIGV4ZWMoKXZvaWQKKmFiaV9yb3V0ZV9leGVjOgoJLy8gZXhlY3V0ZSBleGVjKCl2b2lkCgljYWxsc3ViIGV4ZWMKCWludCAxCglyZXR1cm4KCi8vIGV4ZWMoKTogdm9pZAovLwovLyBBbnlvbmUgY2FuIGV4ZWN1dGUgdGhpcyBzY2hlZHVsZXIgbWV0aG9kIHdoZW4gdGltZSBpcyByaWdodCBhbmQgaGUgd2lsbCBiZSByZXdhcmRlZCB0aGUgZmVlCmV4ZWM6Cglwcm90byAwIDAKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoyMzMKCS8vIGFzc2VydCh0aGlzLnN0YXJ0LnZhbHVlIDw9IGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wLCAnRVJSX05PX1NUQVJUX1lFVCcpCglieXRlIDB4NzMgLy8gInMiCglhcHBfZ2xvYmFsX2dldAoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJPD0KCgkvLyBFUlJfTk9fU1RBUlRfWUVUCglhc3NlcnQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoyMzQKCS8vIGFzc2VydCgKCS8vICAgICAgIChnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCArIHRoaXMuc3RhcnQudmFsdWUpIC8gdGhpcy5wZXJpb2QudmFsdWUgPgoJLy8gICAgICAgICAodGhpcy5sYXN0UnVuLnZhbHVlICsgdGhpcy5zdGFydC52YWx1ZSkgLyB0aGlzLnBlcmlvZC52YWx1ZSwKCS8vICAgICAgICdFUlJfTk9fVElNRV9ZRVQnCgkvLyAgICAgKQoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJYnl0ZSAweDczIC8vICJzIgoJYXBwX2dsb2JhbF9nZXQKCSsKCWJ5dGUgMHg3MCAvLyAicCIKCWFwcF9nbG9iYWxfZ2V0CgkvCglieXRlIDB4NmMgLy8gImwiCglhcHBfZ2xvYmFsX2dldAoJYnl0ZSAweDczIC8vICJzIgoJYXBwX2dsb2JhbF9nZXQKCSsKCWJ5dGUgMHg3MCAvLyAicCIKCWFwcF9nbG9iYWxfZ2V0CgkvCgk+CgoJLy8gRVJSX05PX1RJTUVfWUVUCglhc3NlcnQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoyMzkKCS8vIHRoaXMubGFzdFJ1bi52YWx1ZSA9IGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wCglieXRlIDB4NmMgLy8gImwiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgoqY3JlYXRlX05vT3A6CgltZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbgoJZXJyCgoqY2FsbF9Ob09wOgoJbWV0aG9kICJ1bnJlZ2lzdGVyQXBwbGljYXRpb24odWludDY0LHVpbnQ2NCl2b2lkIgoJbWV0aG9kICJzZXRQZXJpb2QodWludDY0KXZvaWQiCgltZXRob2QgInBheW1lbnQodWludDY0LGFkZHJlc3Msc3RyaW5nKXZvaWQiCgltZXRob2QgImFzc2V0VHJhbnNmZXIodWludDY0LHVpbnQ2NCxhZGRyZXNzLHN0cmluZyl2b2lkIgoJbWV0aG9kICJib290c3RyYXAodWludDY0LHBheSxzdHJpbmcsdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZCIKCW1ldGhvZCAic2VuZE9ubGluZUtleVJlZ2lzdHJhdGlvbihieXRlW10sYnl0ZVtdLGJ5dGVbXSx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkIgoJbWV0aG9kICJzZW5kT2ZmbGluZUtleVJlZ2lzdHJhdGlvbigpdm9pZCIKCW1ldGhvZCAibm9vcCgpdm9pZCIKCW1ldGhvZCAiZXhlYygpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfdW5yZWdpc3RlckFwcGxpY2F0aW9uICphYmlfcm91dGVfc2V0UGVyaW9kICphYmlfcm91dGVfcGF5bWVudCAqYWJpX3JvdXRlX2Fzc2V0VHJhbnNmZXIgKmFiaV9yb3V0ZV9ib290c3RyYXAgKmFiaV9yb3V0ZV9zZW5kT25saW5lS2V5UmVnaXN0cmF0aW9uICphYmlfcm91dGVfc2VuZE9mZmxpbmVLZXlSZWdpc3RyYXRpb24gKmFiaV9yb3V0ZV9ub29wICphYmlfcm91dGVfZXhlYwoJZXJyCgoqY2FsbF9VcGRhdGVBcHBsaWNhdGlvbjoKCW1ldGhvZCAidXBkYXRlQXBwbGljYXRpb24oc3RyaW5nLHN0cmluZyl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV91cGRhdGVBcHBsaWNhdGlvbgoJZXJyCgoqY2FsbF9EZWxldGVBcHBsaWNhdGlvbjoKCW1ldGhvZCAiZGVsZXRlQXBwbGljYXRpb24oKXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2RlbGV0ZUFwcGxpY2F0aW9uCgllcnI=\",\n    \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDEw\"\n  },\n  \"contract\": {\n    \"name\": \"BiatecCronJob__SHORT_HASH__\",\n    \"desc\": \"\",\n    \"methods\": [\n      {\n        \"name\": \"createApplication\",\n        \"desc\": \"Initial setup\",\n        \"args\": [],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"updateApplication\",\n        \"desc\": \"Creator can update application\",\n        \"args\": [\n          {\n            \"name\": \"version\",\n            \"type\": \"string\"\n          },\n          {\n            \"name\": \"id\",\n            \"type\": \"string\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"deleteApplication\",\n        \"desc\": \"Creator can delete application\",\n        \"args\": [],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"unregisterApplication\",\n        \"desc\": \"Creator can unregisterApplication before he deletes it\",\n        \"args\": [\n          {\n            \"name\": \"appPoolManager\",\n            \"type\": \"uint64\",\n            \"desc\": \"Pool manager where the task is registered\"\n          },\n          {\n            \"name\": \"indexToDelete\",\n            \"type\": \"uint64\",\n            \"desc\": \"App index to delete from user's apps\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"setPeriod\",\n        \"desc\": \"Creator can change the period how ofter the script can be executed by executors\",\n        \"args\": [\n          {\n            \"name\": \"period\",\n            \"type\": \"uint64\",\n            \"desc\": \"Period in seconds\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"payment\",\n        \"desc\": \"Creator can send pay/axfer transaction out of the smart contract\",\n        \"args\": [\n          {\n            \"name\": \"amount\",\n            \"type\": \"uint64\",\n            \"desc\": \"Amount\"\n          },\n          {\n            \"name\": \"receiver\",\n            \"type\": \"address\",\n            \"desc\": \"Receiver\"\n          },\n          {\n            \"name\": \"note\",\n            \"type\": \"string\",\n            \"desc\": \"Note\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"assetTransfer\",\n        \"desc\": \"Creator can send pay/axfer transaction out of the smart contract\",\n        \"args\": [\n          {\n            \"name\": \"xferAsset\",\n            \"type\": \"uint64\",\n            \"desc\": \"Asset id\"\n          },\n          {\n            \"name\": \"assetAmount\",\n            \"type\": \"uint64\",\n            \"desc\": \"Amount\"\n          },\n          {\n            \"name\": \"assetReceiver\",\n            \"type\": \"address\",\n            \"desc\": \"Receiver\"\n          },\n          {\n            \"name\": \"note\",\n            \"type\": \"string\",\n            \"desc\": \"Note\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"bootstrap\",\n        \"desc\": \"Bootstrap the contract to optin to the fee asset and setup basic variables\",\n        \"args\": [\n          {\n            \"name\": \"appPoolManager\",\n            \"type\": \"uint64\",\n            \"desc\": \"Tasks Pool manager app\"\n          },\n          {\n            \"name\": \"txBaseDeposit\",\n            \"type\": \"pay\",\n            \"desc\": \"Deposit MBR\"\n          },\n          {\n            \"name\": \"id\",\n            \"type\": \"string\",\n            \"desc\": \"Hash id of the input app\"\n          },\n          {\n            \"name\": \"period\",\n            \"type\": \"uint64\",\n            \"desc\": \"Period in seconds how often this smart contract can be run\"\n          },\n          {\n            \"name\": \"start\",\n            \"type\": \"uint64\",\n            \"desc\": \"Start time in unix timestamp seconds. Contract can be exectuted when Math.floor((currentTime + start) / period)>Math.floor((lastRun + start) / period)\"\n          },\n          {\n            \"name\": \"fee\",\n            \"type\": \"uint64\",\n            \"desc\": \"Execution fee for the task\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"sendOnlineKeyRegistration\",\n        \"desc\": \"Creator can perfom key registration for this LP pool\",\n        \"args\": [\n          {\n            \"name\": \"votePk\",\n            \"type\": \"byte[]\"\n          },\n          {\n            \"name\": \"selectionPk\",\n            \"type\": \"byte[]\"\n          },\n          {\n            \"name\": \"stateProofPk\",\n            \"type\": \"byte[]\"\n          },\n          {\n            \"name\": \"voteFirst\",\n            \"type\": \"uint64\"\n          },\n          {\n            \"name\": \"voteLast\",\n            \"type\": \"uint64\"\n          },\n          {\n            \"name\": \"voteKeyDilution\",\n            \"type\": \"uint64\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"sendOfflineKeyRegistration\",\n        \"desc\": \"Creator can perfom key unregistration for this LP pool\",\n        \"args\": [],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"noop\",\n        \"desc\": \"No op, for purpose of adding extra resources to the tx group\",\n        \"args\": [],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"exec\",\n        \"desc\": \"Anyone can execute this scheduler method when time is right and he will be rewarded the fee\",\n        \"args\": [],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      }\n    ]\n  }\n};\nvar BiatecCronJobShortHashCallFactory = class {\n  /**\n   * Gets available create call factories\n   */\n  static get create() {\n    return {\n      /**\n       * Constructs a create call for the BiatecCronJob__SHORT_HASH__ smart contract using the createApplication()void ABI method\n       *\n       * @param args Any args for the contract call\n       * @param params Any additional parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      createApplication(args, params = {}) {\n        return __spreadValues({\n          method: \"createApplication()void\",\n          methodArgs: Array.isArray(args) ? args : []\n        }, params);\n      }\n    };\n  }\n  /**\n   * Gets available update call factories\n   */\n  static get update() {\n    return {\n      /**\n       * Constructs an update call for the BiatecCronJob__SHORT_HASH__ smart contract using the updateApplication(string,string)void ABI method\n       *\n       * @param args Any args for the contract call\n       * @param params Any additional parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      updateApplication(args, params = {}) {\n        return __spreadValues({\n          method: \"updateApplication(string,string)void\",\n          methodArgs: Array.isArray(args) ? args : [args.version, args.id]\n        }, params);\n      }\n    };\n  }\n  /**\n   * Gets available delete call factories\n   */\n  static get delete() {\n    return {\n      /**\n       * Constructs a delete call for the BiatecCronJob__SHORT_HASH__ smart contract using the deleteApplication()void ABI method\n       *\n       * @param args Any args for the contract call\n       * @param params Any additional parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      deleteApplication(args, params = {}) {\n        return __spreadValues({\n          method: \"deleteApplication()void\",\n          methodArgs: Array.isArray(args) ? args : []\n        }, params);\n      }\n    };\n  }\n  /**\n   * Constructs a no op call for the unregisterApplication(uint64,uint64)void ABI method\n   *\n   * Creator can unregisterApplication before he deletes it\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static unregisterApplication(args, params) {\n    return __spreadValues({\n      method: \"unregisterApplication(uint64,uint64)void\",\n      methodArgs: Array.isArray(args) ? args : [args.appPoolManager, args.indexToDelete]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the setPeriod(uint64)void ABI method\n   *\n   * Creator can change the period how ofter the script can be executed by executors\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static setPeriod(args, params) {\n    return __spreadValues({\n      method: \"setPeriod(uint64)void\",\n      methodArgs: Array.isArray(args) ? args : [args.period]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the payment(uint64,address,string)void ABI method\n   *\n   * Creator can send pay/axfer transaction out of the smart contract\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static payment(args, params) {\n    return __spreadValues({\n      method: \"payment(uint64,address,string)void\",\n      methodArgs: Array.isArray(args) ? args : [args.amount, args.receiver, args.note]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the assetTransfer(uint64,uint64,address,string)void ABI method\n   *\n   * Creator can send pay/axfer transaction out of the smart contract\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static assetTransfer(args, params) {\n    return __spreadValues({\n      method: \"assetTransfer(uint64,uint64,address,string)void\",\n      methodArgs: Array.isArray(args) ? args : [args.xferAsset, args.assetAmount, args.assetReceiver, args.note]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the bootstrap(uint64,pay,string,uint64,uint64,uint64)void ABI method\n   *\n   * Bootstrap the contract to optin to the fee asset and setup basic variables\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static bootstrap(args, params) {\n    return __spreadValues({\n      method: \"bootstrap(uint64,pay,string,uint64,uint64,uint64)void\",\n      methodArgs: Array.isArray(args) ? args : [args.appPoolManager, args.txBaseDeposit, args.id, args.period, args.start, args.fee]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64)void ABI method\n   *\n   * Creator can perfom key registration for this LP pool\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static sendOnlineKeyRegistration(args, params) {\n    return __spreadValues({\n      method: \"sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64)void\",\n      methodArgs: Array.isArray(args) ? args : [args.votePk, args.selectionPk, args.stateProofPk, args.voteFirst, args.voteLast, args.voteKeyDilution]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the sendOfflineKeyRegistration()void ABI method\n   *\n   * Creator can perfom key unregistration for this LP pool\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static sendOfflineKeyRegistration(args, params) {\n    return __spreadValues({\n      method: \"sendOfflineKeyRegistration()void\",\n      methodArgs: Array.isArray(args) ? args : []\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the noop()void ABI method\n   *\n   * No op, for purpose of adding extra resources to the tx group\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static noop(args, params) {\n    return __spreadValues({\n      method: \"noop()void\",\n      methodArgs: Array.isArray(args) ? args : []\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the exec()void ABI method\n   *\n   * Anyone can execute this scheduler method when time is right and he will be rewarded the fee\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static exec(args, params) {\n    return __spreadValues({\n      method: \"exec()void\",\n      methodArgs: Array.isArray(args) ? args : []\n    }, params);\n  }\n};\nvar BiatecCronJobShortHashClient = class _BiatecCronJobShortHashClient {\n  /**\n   * Creates a new instance of `BiatecCronJobShortHashClient`\n   *\n   * @param appDetails appDetails The details to identify the app to deploy\n   * @param algod An algod client instance\n   */\n  constructor(appDetails, algod) {\n    this.algod = algod;\n    this.sender = appDetails.sender;\n    this.appClient = algokit2.getAppClient(__spreadProps(__spreadValues({}, appDetails), {\n      app: APP_SPEC2\n    }), algod);\n  }\n  /**\n   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type\n   *\n   * @param result The AppCallTransactionResult to be mapped\n   * @param returnValueFormatter An optional delegate to format the return value if required\n   * @returns The smart contract response with an updated return value\n   */\n  mapReturnValue(result, returnValueFormatter) {\n    var _a, _b, _c;\n    if ((_a = result.return) == null ? void 0 : _a.decodeError) {\n      throw result.return.decodeError;\n    }\n    const returnValue = ((_b = result.return) == null ? void 0 : _b.returnValue) !== void 0 && returnValueFormatter !== void 0 ? returnValueFormatter(result.return.returnValue) : (_c = result.return) == null ? void 0 : _c.returnValue;\n    return __spreadProps(__spreadValues({}, result), { return: returnValue });\n  }\n  /**\n   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP\n   *\n   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters\n   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type\n   * @returns The result of the smart contract call\n   */\n  call(typedCallParams, returnValueFormatter) {\n    return __async(this, null, function* () {\n      return this.mapReturnValue(yield this.appClient.call(typedCallParams), returnValueFormatter);\n    });\n  }\n  /**\n   * Idempotently deploys the BiatecCronJob__SHORT_HASH__ smart contract.\n   *\n   * @param params The arguments for the contract calls and any additional parameters for the call\n   * @returns The deployment result\n   */\n  deploy(params = {}) {\n    var _a, _b, _c;\n    const createArgs = (_a = params.createCall) == null ? void 0 : _a.call(params, BiatecCronJobShortHashCallFactory.create);\n    const updateArgs = (_b = params.updateCall) == null ? void 0 : _b.call(params, BiatecCronJobShortHashCallFactory.update);\n    const deleteArgs = (_c = params.deleteCall) == null ? void 0 : _c.call(params, BiatecCronJobShortHashCallFactory.delete);\n    return this.appClient.deploy(__spreadProps(__spreadValues({}, params), {\n      updateArgs,\n      deleteArgs,\n      createArgs,\n      createOnCompleteAction: createArgs == null ? void 0 : createArgs.onCompleteAction\n    }));\n  }\n  /**\n   * Gets available create methods\n   */\n  get create() {\n    const $this = this;\n    return {\n      /**\n       * Creates a new instance of the BiatecCronJob__SHORT_HASH__ smart contract using the createApplication()void ABI method.\n       *\n       * @param args The arguments for the smart contract call\n       * @param params Any additional parameters for the call\n       * @returns The create result\n       */\n      createApplication(_0) {\n        return __async(this, arguments, function* (args, params = {}) {\n          return $this.mapReturnValue(yield $this.appClient.create(BiatecCronJobShortHashCallFactory.create.createApplication(args, params)));\n        });\n      }\n    };\n  }\n  /**\n   * Gets available update methods\n   */\n  get update() {\n    const $this = this;\n    return {\n      /**\n       * Updates an existing instance of the BiatecCronJob__SHORT_HASH__ smart contract using the updateApplication(string,string)void ABI method.\n       *\n       * @param args The arguments for the smart contract call\n       * @param params Any additional parameters for the call\n       * @returns The update result\n       */\n      updateApplication(_0) {\n        return __async(this, arguments, function* (args, params = {}) {\n          return $this.mapReturnValue(yield $this.appClient.update(BiatecCronJobShortHashCallFactory.update.updateApplication(args, params)));\n        });\n      }\n    };\n  }\n  /**\n   * Gets available delete methods\n   */\n  get delete() {\n    const $this = this;\n    return {\n      /**\n       * Deletes an existing instance of the BiatecCronJob__SHORT_HASH__ smart contract using the deleteApplication()void ABI method.\n       *\n       * @param args The arguments for the smart contract call\n       * @param params Any additional parameters for the call\n       * @returns The delete result\n       */\n      deleteApplication(_0) {\n        return __async(this, arguments, function* (args, params = {}) {\n          return $this.mapReturnValue(yield $this.appClient.delete(BiatecCronJobShortHashCallFactory.delete.deleteApplication(args, params)));\n        });\n      }\n    };\n  }\n  /**\n   * Makes a clear_state call to an existing instance of the BiatecCronJob__SHORT_HASH__ smart contract.\n   *\n   * @param args The arguments for the bare call\n   * @returns The clear_state result\n   */\n  clearState(args = {}) {\n    return this.appClient.clearState(args);\n  }\n  /**\n   * Calls the unregisterApplication(uint64,uint64)void ABI method.\n   *\n   * Creator can unregisterApplication before he deletes it\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  unregisterApplication(args, params = {}) {\n    return this.call(BiatecCronJobShortHashCallFactory.unregisterApplication(args, params));\n  }\n  /**\n   * Calls the setPeriod(uint64)void ABI method.\n   *\n   * Creator can change the period how ofter the script can be executed by executors\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  setPeriod(args, params = {}) {\n    return this.call(BiatecCronJobShortHashCallFactory.setPeriod(args, params));\n  }\n  /**\n   * Calls the payment(uint64,address,string)void ABI method.\n   *\n   * Creator can send pay/axfer transaction out of the smart contract\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  payment(args, params = {}) {\n    return this.call(BiatecCronJobShortHashCallFactory.payment(args, params));\n  }\n  /**\n   * Calls the assetTransfer(uint64,uint64,address,string)void ABI method.\n   *\n   * Creator can send pay/axfer transaction out of the smart contract\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  assetTransfer(args, params = {}) {\n    return this.call(BiatecCronJobShortHashCallFactory.assetTransfer(args, params));\n  }\n  /**\n   * Calls the bootstrap(uint64,pay,string,uint64,uint64,uint64)void ABI method.\n   *\n   * Bootstrap the contract to optin to the fee asset and setup basic variables\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  bootstrap(args, params = {}) {\n    return this.call(BiatecCronJobShortHashCallFactory.bootstrap(args, params));\n  }\n  /**\n   * Calls the sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64)void ABI method.\n   *\n   * Creator can perfom key registration for this LP pool\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  sendOnlineKeyRegistration(args, params = {}) {\n    return this.call(BiatecCronJobShortHashCallFactory.sendOnlineKeyRegistration(args, params));\n  }\n  /**\n   * Calls the sendOfflineKeyRegistration()void ABI method.\n   *\n   * Creator can perfom key unregistration for this LP pool\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  sendOfflineKeyRegistration(args, params = {}) {\n    return this.call(BiatecCronJobShortHashCallFactory.sendOfflineKeyRegistration(args, params));\n  }\n  /**\n   * Calls the noop()void ABI method.\n   *\n   * No op, for purpose of adding extra resources to the tx group\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  noop(args, params = {}) {\n    return this.call(BiatecCronJobShortHashCallFactory.noop(args, params));\n  }\n  /**\n   * Calls the exec()void ABI method.\n   *\n   * Anyone can execute this scheduler method when time is right and he will be rewarded the fee\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  exec(args, params = {}) {\n    return this.call(BiatecCronJobShortHashCallFactory.exec(args, params));\n  }\n  /**\n   * Extracts a binary state value out of an AppState dictionary\n   *\n   * @param state The state dictionary containing the state value\n   * @param key The key of the state value\n   * @returns A BinaryState instance containing the state value, or undefined if the key was not found\n   */\n  static getBinaryState(state, key) {\n    const value = state[key];\n    if (!value)\n      return void 0;\n    if (!(\"valueRaw\" in value))\n      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`);\n    return {\n      asString() {\n        return value.value;\n      },\n      asByteArray() {\n        return value.valueRaw;\n      }\n    };\n  }\n  /**\n   * Extracts a integer state value out of an AppState dictionary\n   *\n   * @param state The state dictionary containing the state value\n   * @param key The key of the state value\n   * @returns An IntegerState instance containing the state value, or undefined if the key was not found\n   */\n  static getIntegerState(state, key) {\n    const value = state[key];\n    if (!value)\n      return void 0;\n    if (\"valueRaw\" in value)\n      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`);\n    return {\n      asBigInt() {\n        return typeof value.value === \"bigint\" ? value.value : BigInt(value.value);\n      },\n      asNumber() {\n        return typeof value.value === \"bigint\" ? Number(value.value) : value.value;\n      }\n    };\n  }\n  /**\n   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value\n   */\n  getGlobalState() {\n    return __async(this, null, function* () {\n      const state = yield this.appClient.getGlobalState();\n      return {\n        get id() {\n          return _BiatecCronJobShortHashClient.getBinaryState(state, \"id\");\n        },\n        get l() {\n          return _BiatecCronJobShortHashClient.getIntegerState(state, \"l\");\n        },\n        get p() {\n          return _BiatecCronJobShortHashClient.getIntegerState(state, \"p\");\n        },\n        get s() {\n          return _BiatecCronJobShortHashClient.getIntegerState(state, \"s\");\n        },\n        get pool() {\n          return _BiatecCronJobShortHashClient.getIntegerState(state, \"pool\");\n        },\n        get scver() {\n          return _BiatecCronJobShortHashClient.getBinaryState(state, \"scver\");\n        }\n      };\n    });\n  }\n  compose() {\n    const client = this;\n    const atc = new AtomicTransactionComposer2();\n    let promiseChain = Promise.resolve();\n    const resultMappers = [];\n    return {\n      unregisterApplication(args, params) {\n        promiseChain = promiseChain.then(() => client.unregisterApplication(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      setPeriod(args, params) {\n        promiseChain = promiseChain.then(() => client.setPeriod(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      payment(args, params) {\n        promiseChain = promiseChain.then(() => client.payment(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      assetTransfer(args, params) {\n        promiseChain = promiseChain.then(() => client.assetTransfer(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      bootstrap(args, params) {\n        promiseChain = promiseChain.then(() => client.bootstrap(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      sendOnlineKeyRegistration(args, params) {\n        promiseChain = promiseChain.then(() => client.sendOnlineKeyRegistration(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      sendOfflineKeyRegistration(args, params) {\n        promiseChain = promiseChain.then(() => client.sendOfflineKeyRegistration(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      noop(args, params) {\n        promiseChain = promiseChain.then(() => client.noop(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      exec(args, params) {\n        promiseChain = promiseChain.then(() => client.exec(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      get update() {\n        const $this = this;\n        return {\n          updateApplication(args, params) {\n            promiseChain = promiseChain.then(() => client.update.updateApplication(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n            resultMappers.push(void 0);\n            return $this;\n          }\n        };\n      },\n      get delete() {\n        const $this = this;\n        return {\n          deleteApplication(args, params) {\n            promiseChain = promiseChain.then(() => client.delete.deleteApplication(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n            resultMappers.push(void 0);\n            return $this;\n          }\n        };\n      },\n      clearState(args) {\n        promiseChain = promiseChain.then(() => client.clearState(__spreadProps(__spreadValues({}, args), { sendParams: __spreadProps(__spreadValues({}, args == null ? void 0 : args.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      addTransaction(txn, defaultSender) {\n        promiseChain = promiseChain.then(() => __async(this, null, function* () {\n          return atc.addTransaction(yield algokit2.getTransactionWithSigner(txn, defaultSender != null ? defaultSender : client.sender));\n        }));\n        return this;\n      },\n      atc() {\n        return __async(this, null, function* () {\n          yield promiseChain;\n          return atc;\n        });\n      },\n      simulate(options) {\n        return __async(this, null, function* () {\n          var _a2;\n          yield promiseChain;\n          const result = yield atc.simulate(client.algod, new modelsv22.SimulateRequest(__spreadValues({ txnGroups: [] }, options)));\n          return __spreadProps(__spreadValues({}, result), {\n            returns: (_a2 = result.methodResults) == null ? void 0 : _a2.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val.returnValue) : val.returnValue)\n          });\n        });\n      },\n      execute(sendParams) {\n        return __async(this, null, function* () {\n          var _a2;\n          yield promiseChain;\n          const result = yield algokit2.sendAtomicTransactionComposer({ atc, sendParams }, client.algod);\n          return __spreadProps(__spreadValues({}, result), {\n            returns: (_a2 = result.returns) == null ? void 0 : _a2.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val.returnValue) : val.returnValue)\n          });\n        });\n      }\n    };\n  }\n};\nexport {\n  BiatecCronJobShortHashClient,\n  BiatecTaskManagerClient,\n  getBoxReferenceApp_default as getBoxReferenceApp,\n  getBoxReferenceUser_default as getBoxReferenceUser,\n  getPoolManagerApp_default as getPoolManagerApp,\n  parseBoxData_default as parseBoxData\n};\n//# sourceMappingURL=index.mjs.map"],"names":["base642base64url","input","replaceAll","CAsset","constructor","_defineProperty","toNumber","value","BigInt","Number","MAX_SAFE_INTEGER","UnsafeConversionError","MIN_SAFE_INTEGER","Error","isNode","process","versions","node","consoleLogger","error","console","warn","info","verbose","debug","nullLogger","trace","message","optionalParams","UpdatableConfig","populateAppCallResources","this","config","logger","projectRoot","traceAll","traceBufferSizeMb","maxSearchDepth","getLogger","returnNullLogger","withDebug","lambda","original","configureProjectRoot","fs","path","_dirname","then","async","dirname","url","fileURLToPath","currentPath","resolve","i","existsSync","configure","newConfig","modelsv2","performAtomicTransactionComposerSimulate","atc","algod","unsignedTransactionsSigners","buildGroup","decodedSignedTransactions","map","ts","txn","simulateRequest","SimulateRequest","allowEmptySignatures","allowMoreLogging","execTraceConfig","SimulateTraceConfig","enable","scratchChange","stackChange","stateChange","txnGroups","SimulateRequestTransactionGroup","txns","simulateResult","simulateTransactions","do","TRACES_FILE_EXT","DEBUG_TRACES_DIR","simulateAndPersistResponse","bufferSizeMb","atcToSimulate","clone","txnTypesCount","reduce","acc","txnGroup","txnType","txnResults","txnResult","type","txnTypesStr","Object","entries","count","join","timestamp","Date","toISOString","replace","outputRootDir","outputFileName","lastRound","outputFilePath","promises","access","err","code","mkdir","recursive","totalSize","Promise","all","readdir","file","stat","size","a","b","sortedFiles","stats","mtime","resolvedFiles","sort","getTime","oldestFilePromise","shift","oldestFile","unlink","writeFile","JSON","stringify","get_obj_for_encoding","String","stack","AtomicTransactionComposer","MAX_APP_CALL_FOREIGN_REFERENCES","MAX_APP_CALL_ACCOUNT_REFERENCES","note","Uint8Array","arc2Payload","dAppName","format","data","encoder","TextEncoder","encode","n","lease","length","lease32","set","sender","addr","address","getTransactionWithSigner","transaction","defaultSender","undefined","signer","getSenderTransactionSigner","memoize","fn","cache","Map","cached","val","has","call","get","signTransaction","signTxn","sk","blob","sign","send","from","sendParams","skipSending","skipWaiting","fee","maxFee","suppressLog","maxRoundsToWaitForConfirmation","controlFees","addTransaction","txnToSend","populateResources","appl","newAtc","packed","signedTransaction","confirmation","sendRawTransaction","txID","waitForConfirmation","getUnnamedAppCallResourcesAccessed","simReq","allowUnnamedResources","signerWithFixedSgnr","indexes","stxns","stxn","decodedStxn","publicKey","authAddr","accountInformation","stxnObj","sgnr","Buffer","emptySignerAtc","forEach","t","result","simulate","groupResponse","simulateResponse","failureMessage","failedAt","group","unnamedResourcesAccessed","r","boxes","extraBoxRefs","appLocals","assetHoldings","accounts","appAccounts","apps","appForeignApps","assets","appForeignAssets","populateGroupResource","reference","isApplBelowLimit","account","txnIndex","findIndex","includes","values","f","asset","app","appIndex","name","toString","g","filter","ref","atcSend","givenAtc","transactionsWithSigner","transactionsToSend","groupId","execute","confirmations","PendingTransactionResponse","from_obj_for_encoding","pendingTransactionInformation","txIds","transactions","returns","methodResults","decodeError","returnValue","rawReturnValue","e","response","headers","traces","push","execTrace","appBudget","appBudgetConsumed","logicSigBudget","logicSigBudgetConsumed","logs","transactionId","maxRoundsToWait","status","NodeStatusResponse","startRound","currentRound","pendingInfo","confirmedRound","poolError","statusAfterBlock","capTransactionFee","maxAcceptableFee","flatFee","microAlgos","feeControl","params","getTransactionParams","getAtomicTransactionComposerTransactions","UPDATABLE_TEMPLATE_NAME","DELETABLE_TEMPLATE_NAME","APP_DEPLOY_NOTE_DAPP","APP_PAGE_MAX_SIZE","OnUpdate","OnSchemaBreak","ABIMethod","OnApplicationComplete","SourceMap","createApp","create","approvalProgram","approval","clearStateProgram","clear","schema","transactionParams","args","onCompleteAction","compiledApproval","compileTeal","compiledBase64ToBytes","compiledClear","clearProgram","method","attachATC","before","addMethodCall","appID","numLocalInts","localInts","numLocalByteSlices","localByteSlices","numGlobalInts","globalInts","numGlobalByteSlices","globalByteSlices","extraPages","Math","floor","onComplete","getAppOnCompleteAction","suggestedParams","getAppArgsForABICall","after","slice","appId","appAddress","applicationIndex","return","getABIReturn","getAppArgsForTransaction","rekeyTo","updateApp","update","UpdateApplicationOC","onCompletionAction","NoOpOC","OptInOC","CloseOutOC","ClearStateOC","DeleteApplicationOC","callApp","callType","appCallParams","resultDummy","parseMethodResponse","getAppGlobalState","appInfo","getAppById","globalState","decodeAppState","getAppLocalState","accountAddress","AccountApplicationResponse","accountApplicationInformation","appLocalState","keyValue","getAppBoxNames","boxResult","getApplicationBoxes","nameRaw","nameBase64","getAppBoxValue","boxName","getApplicationBoxByName","getAppBoxValueFromABIType","request","decode","state","stateValues","stateVal","keyBase64","key","keyRaw","tealValue","dataTypeFlag","action","valueBase64","valueRaw","bytes","uint","_getAccountAddress","appArgs","getBoxReference","foreignApps","foreignAssets","methodArgs","index","box","Application","getApplicationByID","tealCode","compiled","compile","sourcemap","teal","compiledHash","hash","sourceMap","getABIMethodSignature","getSignature","DEFAULT_INDEXER_MAX_API_RESOURCES_PER_ACCOUNT","lookupAccountCreatedApplicationByAddress","indexer","getAll","paginationLimit","executePaginatedRequest","applications","nextToken","s","lookupAccountCreatedApplications","includeAll","limit","searchTransactions","searchCriteria","searchForTransactions","extractItems","buildRequest","results","items","getApplicationAddress","TransactionType","deployApp","deployment","metadata","deployTimeParams","deployTimeParameters","onSchemaBreak","onUpdate","existingDeployments","createArgs","updateArgs","deleteArgs","createOnCompleteAction","appParams","creator","performTemplateSubstitutionAndCompile","getCreatorAppsByName","getAppDeploymentTransactionNote","createdMetadata","createdRound","updatedRound","deleted","operationPerformed","existingApp","version","existingAppRecord","existingApproval","existingClear","existingGlobalSchema","globalStateSchema","existingLocalSchema","localStateSchema","newGlobalSchema","ApplicationStateSchema","numByteSlice","numUint","newLocalSchema","newApproval","newClear","isUpdate","isSchemaBreak","isSchemaIsBroken","createTransaction","createTransactions","deleteTransaction","createConfirmation","deleteConfirmation","newAppIndex","deleteReturn","deleteResult","global","local","to","Fail","AppendApp","deletable","UpdateApp","updatable","ReplaceApp","creatorAccount","appLookup","creatorAddress","createdApps","id","createdAtRound","createdApp","appTransactions","minRound","txType","applicationID","addressRole","notePrefix","appCreationTransaction","latestAppUpdateTransaction","parseNote","decoder","TextDecoder","noteAsBase64","noteAsString","startsWith","parse","substring","creationNote","updateNote","replaceDeployTimeControlParams","RegExp","performTemplateSubstitution","templateParams","token","ArrayBuffer","isView","deploymentMetadata","stripTealComments","regex","split","tealCodeLine","trim","AVMDebuggerSourceMapEntry","location","programHash","equals","other","AVMDebuggerSourceMap","txnGroupSources","fromDict","item","toDict","PersistSourceMapInput","appName","fileName","rawTeal","compiledTeal","_rawTeal","_fileName","stripTealExtension","fromRawTeal","fromCompiledTeal","endsWith","ALGOKIT_DIR","SOURCES_DIR","SOURCES_FILE","TEAL_FILE_EXT","TEAL_SOURCEMAP_EXT","loadOrCreateSources","sourcesPath","readFile","upsertDebugSourcemaps","sourceMaps","sources","sourceFilePath","splice","writeToFile","filePath","content","buildAVMSourcemap","outputPath","client","withSources","digest","outputDirPath","sourceMapOutputPath","tealOutputPath","persistSourceMaps","source","transfer","amount","closeRemainderTo","encodedLease","addLease","LOGIC_ERROR","LogicError","parseLogicError","errorMessage","res","exec","txId","msg","desc","pc","parseInt","errorDetails","program","super","lines","teal_line","led","line","getLineForPc","start","stop","stack_lines","ValidationType","Indexer","getDeployTimeControl","appSpec","templateVariableName","callConfigKey","bareCallConfig","bare_call_config","hints","some","h","abiCallConfig","call_config","appDetails","appIdentifier","_appName","contract","resolveBy","_appId","_creator","findExistingUsing","_appAddress","compilation","approvalTemplate","approvalCompiled","_approvalSourceMap","clearTemplate","clearCompiled","_clearSourceMap","exportSourceMaps","approvalSourceMap","clearSourceMap","importSourceMaps","deploy","deploySender","allowUpdate","allowDelete","deployArgs","getAppReference","num_byte_slices","num_uints","getCallArgs","appMetadata","exposeLogicError","createSender","updateSender","getABIMethod","read_only","callOfType","find","x","at","optIn","closeOut","clearState","callSender","fundAppAccount","fund","getGlobalState","appRef","getLocalState","getBoxNames","getBoxValue","getBoxValueFromABIType","getBoxValues","names","_","getBoxValuesFromABIType","abiMethod","getABIMethodParams","methodSignature","arg","argName","defaultValueStrategy","default_arguments","methods","m","methodParams","isClear","getAppClient","DispenserAssetName","Algo","URLTokenBaseHTTPError","URLTokenBaseHTTPClient","tokenHeader","baseServer","port","defaultHeaders","fixedBaseServer","baseServerURL","URL","protocol","baseURL","getURL","relativePath","query","fixedRelativePath","searchParams","formatFetchResponseHeaders","headersObj","checkHttpError","ok","body","bodyErrorMessage","arrayBuffer","decoded","statusText","formatFetchResponse","requestHeaders","fetch","mode","post","callWithRetry","func","numTries","MAX_TRIES","RETRY_ERROR_CODES","RETRY_STATUS_CODES","delayTimeMs","min","pow","MAX_BACKOFF_MS","setTimeout","delete","amountInMicroAlgos","algos","toLocaleString","valueOf","Algos","MicroAlgos","prototype","__defProp","defineProperty","__defProps","defineProperties","__getOwnPropDescs","getOwnPropertyDescriptors","__getOwnPropSymbols","getOwnPropertySymbols","__hasOwnProp","hasOwnProperty","__propIsEnum","propertyIsEnumerable","__defNormalProp","obj","enumerable","configurable","writable","__spreadValues","prop","__spreadProps","__async","__this","__arguments","generator","reject","fulfilled","step","next","rejected","throw","done","apply","getBoxReferenceApp","appPoolId","taskAppId","concat","getBoxReferenceApp_default","getBoxReferenceUser","userAddress","getBoxReferenceUser_default","getPoolManagerApp","env","getPoolManagerApp_default","parseBoxData","ret","funds","subarray","parseBoxData_default","APP_SPEC","BiatecTaskManagerCallFactory","createApplication","Array","isArray","updateApplication","bootstrap","txBaseDeposit","feeAssetId","registerTask","registrationFeeDeposit","task","unregisterTask","indexToDelete","executeTask","taskAppCall","fundTask","deposit","changeTaskFee","unfundTask","payment","receiver","assetTransfer","xferAsset","assetAmount","assetReceiver","sendOnlineKeyRegistration","votePk","selectionPk","stateProofPk","voteFirst","voteLast","voteKeyDilution","sendOfflineKeyRegistration","BiatecTaskManagerClient","_BiatecTaskManagerClient","appClient","mapReturnValue","returnValueFormatter","_a","_b","_c","typedCallParams","createCall","updateCall","$this","_0","arguments","getBinaryState","asString","asByteArray","getIntegerState","asBigInt","asNumber","fa","d","scver","compose","promiseChain","resultMappers","options","_a2","APP_SPEC2","BiatecCronJobShortHashCallFactory","deleteApplication","unregisterApplication","appPoolManager","setPeriod","period","noop","BiatecCronJobShortHashClient","_BiatecCronJobShortHashClient","deleteCall","l","p","pool"],"sourceRoot":""}